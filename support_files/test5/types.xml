<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="C:\HaxeToolkit\haxe\std/Any.hx">
		<from><icast><d/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<meta><m n=":forward.variance"/></meta>
		<impl><class path="_Any.Any_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Any.hx" private="1" module="Any" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="Array" params="T" file="C:\HaxeToolkit\haxe\std/lua/_std/Array.hx">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method" line="33">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method" line="40">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method" line="48">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method" line="57">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method" line="62">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method" line="73">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method" line="87">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method" line="105">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method" line="127">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method" line="145">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method" line="153">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" get="inline" set="null" line="160">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method" line="176">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<contains public="1" set="method" line="195">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether `this` Array contains `x`.

		If `x` is found by checking standard equality, the function returns `true`, otherwise
		the function returns `false`.</haxe_doc>
		</contains>
		<indexOf public="1" set="method" line="203">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method" line="219">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" get="inline" set="null" line="237">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<map public="1" params="S" get="inline" set="null" line="241">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="245">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<iterator public="1" get="inline" set="null" line="249">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="253">
			<f a=""><c path="haxe.iterators.ArrayKeyValueIterator"><c path="Array.T"/></c></f>
			<haxe_doc>Returns an iterator of the Array indices and values.</haxe_doc>
		</keyValueIterator>
		<resize public="1" set="method" line="257">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="C:\HaxeToolkit\haxe\std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="sunaba.ui.Widget" params="" file="G:\sunaba\sunaba/ui/Widget.hx">
		<rootElement public="1"><c path="sunaba.ui.Control"/></rootElement>
		<io public="1"><c path="sunaba.core.io.IoManager"/></io>
		<keepChildren public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</keepChildren>
		<elementdb expr="[]">
			<c path="Array"><c path="sunaba.core.Element"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</elementdb>
		<init public="1" set="method" line="40"><f a=""><x path="Void"/></f></init>
		<load public="1" set="method" line="44"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></load>
		<parseMarkup public="1" set="method" line="61"><f a="markup">
	<c path="String"/>
	<x path="Void"/>
</f></parseMarkup>
		<instantiate set="method" line="66"><f a="xml">
	<c path="Xml"/>
	<x path="Void"/>
</f></instantiate>
		<constructNodes set="method" line="148"><f a="nodes">
	<t path="Iterator"><c path="Xml"/></t>
	<x path="Void"/>
</f></constructNodes>
		<construct set="method" line="164">
			<f a="xml">
				<c path="Xml"/>
				<c path="sunaba.core.Element"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</construct>
		<setObjectValues set="method" line="191"><f a="element:xml">
	<c path="sunaba.core.Element"/>
	<c path="Xml"/>
	<x path="Void"/>
</f></setObjectValues>
		<constructChildren set="method" line="431"><f a="element:xml">
	<c path="sunaba.core.Element"/>
	<c path="Xml"/>
	<x path="Void"/>
</f></constructChildren>
		<hasField get="inline" set="null" line="444">
			<f a="object:field">
				<x path="Any"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</hasField>
		<field set="method" line="449">
			<f a="obj:field">
				<x path="Any"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</field>
		<setProperty get="inline" set="null" line="456">
			<f a="obj:field:value">
				<x path="Any"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setProperty>
		<isAnElementClass set="method" line="465">
			<f a="classInfo">
				<x path="Class"><d/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isAnElementClass>
		<camelToPascal set="method" line="473"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></camelToPascal>
		<camelToSnake set="method" line="478"><f a="input">
	<c path="String"/>
	<c path="String"/>
</f></camelToSnake>
		<new public="1" set="method" line="33">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</new>
	</class>
	<class path="ClickerCounter" params="" file="G:/sunaba/support_files/test5/src/ClickerCounter.hx">
		<extends path="sunaba.ui.Widget"/>
		<label><c path="sunaba.ui.Label"/></label>
		<counter expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</counter>
		<init public="1" set="method" line="12" override="1"><f a=""><x path="Void"/></f></init>
		<onClick set="method" line="32"><f a=""><x path="Void"/></f></onClick>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="EReg" params="" file="G:\sunaba/EReg.hx">
		<escape public="1" set="method" line="253" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape the string `s` for use as a part of regular expression.

		If `s` is null, the result is unspecified.</haxe_doc>
		</escape>
		<pattern><c path="String"/></pattern>
		<options><c path="String"/></options>
		<regex><c path="sunaba.core.RegEx"/></regex>
		<lastMatch><c path="sunaba.core.RegExMatch"/></lastMatch>
		<lastInput><c path="String"/></lastInput>
		<match public="1" set="method" line="56">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="78">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, the result is unspecified.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="98">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the left of the last matched substring.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, only the
		substring to the left of the leftmost match is returned.

		The result does not include the matched part.</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="116">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the right of the last matched substring.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, only the
		substring to the right of the leftmost match is returned.

		The result does not include the matched part.</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="135">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<matchSub public="1" set="method" line="155">
			<f a="s:pos:?len" v="::-1">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ len : -1 }</e></m></meta>
			<haxe_doc>Tells if `this` regular expression matches a substring of String `s`.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.match(s.substr(pos,len))` can be used instead.

		This method modifies the internal state.

		If `s` is null, the result is unspecified.</haxe_doc>
		</matchSub>
		<split public="1" set="method" line="182">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits String `s` at all substrings `this` EReg matches.

		If a match is found at the start of `s`, the result contains a leading
		empty String "" entry.

		If a match is found at the end of `s`, the result contains a trailing
		empty String "" entry.

		If two matching substrings appear next to each other, the result
		contains the empty String `""` between them.

		By default, this method splits `s` into two parts at the first matched
		substring. If the global g modifier is in place, `s` is split at each
		matched substring.

		If `s` is null, the result is unspecified.</haxe_doc>
		</split>
		<replace public="1" set="method" line="211">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.

		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<map public="1" set="method" line="229">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>Calls the function `f` for the substring of `s` which `this` EReg matches
		and replaces that substring with the result of `f` call.

		The `f` function takes `this` EReg object as its first argument and should
		return a replacement string for the substring matched.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `s` or `f` are null, the result is unspecified.</haxe_doc>
		</map>
		<new public="1" set="method" line="22">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="C:\HaxeToolkit\haxe\std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="C:\HaxeToolkit\haxe\std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="C:\HaxeToolkit\haxe\std/EnumValue.hx" private="1" module="EnumValue" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="sunaba.App" params="" file="G:\sunaba\sunaba/App.hx">
		<rootElement public="1" get="accessor"><c path="sunaba.core.Element"/></rootElement>
		<get_rootElement set="method" line="8">
			<f a=""><c path="sunaba.core.Element"/></f>
			<meta><m n=":has_untyped"/></meta>
		</get_rootElement>
		<globalObjectStack public="1" get="accessor"><c path="sunaba.core.GlobalObjectStack"/></globalObjectStack>
		<get_globalObjectStack set="method" line="13"><f a=""><c path="sunaba.core.GlobalObjectStack"/></f></get_globalObjectStack>
		<init public="1" set="method" line="22"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="Main" params="" file="G:/sunaba/support_files/test5/src/Main.hx">
		<extends path="sunaba.App"/>
		<main public="1" set="method" line="6" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
		<init public="1" set="method" line="10" override="1"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="Map" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="C:\HaxeToolkit\haxe\std/lua/_std/Math.hx">
		<isNaN public="1" set="method" line="49" static="1"><f a="f">
	<x path="Float"/>
	<x path="Bool"/>
</f></isNaN>
		<isFinite public="1" set="method" line="51" static="1"><f a="f">
	<x path="Float"/>
	<x path="Bool"/>
</f></isFinite>
		<min public="1" set="method" line="101" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></min>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Reflect" params="" file="C:\HaxeToolkit\haxe\std/lua/_std/Reflect.hx">
		<field public="1" set="method" line="38" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.</haxe_doc>
		</field>
		<setProperty public="1" set="method" line="65" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.

		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" line="74" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method `func` with the given arguments `args`.

		The object `o` is ignored in most cases. It serves as the `this`-context in the following
		situations:

		* (neko) Allows switching the context to `o` in all cases.
		* (macro) Same as neko for Haxe 3. No context switching in Haxe 4.
		* (js, lua) Require the `o` argument if `func` does not, but should have a context.
			This can occur by accessing a function field natively, e.g. through `Reflect.field`
			or by using `(object : Dynamic).field`. However, if `func` has a context, `o` is
			ignored like on other targets.</haxe_doc>
		</callMethod>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="String" params="" file="C:\HaxeToolkit\haxe\std/lua/_std/String.hx">
		<__oldindex static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></__oldindex>
		<__index set="method" line="43" static="1">
			<f a="s:k">
				<d/>
				<d/>
				<d/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</__index>
		<indexOfEmpty set="method" line="80" static="1"><f a="s:startIndex">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></indexOfEmpty>
		<fromCharCode public="1" get="inline" set="null" line="166" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" get="inline" set="null" line="60">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" get="inline" set="null" line="63">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<indexOf public="1" set="method" line="65">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method" line="89">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method" line="102">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<toString public="1" get="inline" set="null" line="127">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method" line="131">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<charAt public="1" get="inline" set="null" line="146">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" get="inline" set="null" line="150">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<substr public="1" set="method" line="154">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<new public="1" get="inline" set="null" line="40">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="C:\HaxeToolkit\haxe\std/lua/_std/Std.hx">
		<string public="1" set="method" line="47" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="51" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="58" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		`x` may optionally start with a + or - to denote a postive or negative value respectively.

		If the optional sign is followed 0x or 0X, hexadecimal notation is recognized where the following
		digits may contain 0-9 and A-F. Both the prefix and digits are case insensitive.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. Octal and binary
		notations are not supported.

		Parsing continues until an invalid character is detected, in which case the result up to
		that point is returned. Scientific notation is not supported. That is `Std.parseInt('10e2')` produces `10`.

		If `x` is `null`, the result is `null`.
		If `x` cannot be parsed as integer or is empty, the result is `null`.

		If `x` starts with a hexadecimal prefix which is not followed by at least one valid hexadecimal
		digit, the result is unspecified.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="75" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of `null`. Also, hexadecimal support is **not** specified.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.

		It may also end with `e` or `E` followed by optional minus or plus sign and a sequence of
		digits (defines exponent to base 10).</haxe_doc>
		</parseFloat>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<typedef path="_String.BaseString" params="" file="C:\HaxeToolkit\haxe\std/lua/_std/String.hx" private="1" module="String"><c path="lua.NativeStringTools"/></typedef>
	<class path="StringBuf" params="" file="C:\HaxeToolkit\haxe\std/lua/_std/StringBuf.hx">
		<b><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></b>
		<length public="1" get="null" set="null"><x path="Int"/></length>
		<new public="1" get="inline" set="null" line="30"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="C:\HaxeToolkit\haxe\std/StringTools.hx">
		<htmlEscape public="1" set="method" line="158" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:

		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;

		If `quotes` is true, the following characters are also replaced:

		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<isSpace public="1" set="method" line="282" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String `""`, or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="300" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="325" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="347" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for `ltrim(rtrim(s))`.</haxe_doc>
		</trim>
		<replace public="1" set="method" line="416" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurrences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s` except the last one. If `by` is also the empty String `""`, `s`
		remains unchanged.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Type" params="" file="C:\HaxeToolkit\haxe\std/lua/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<resolveEnum public="1" set="method" line="79" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="XmlType" params="" file="C:\HaxeToolkit\haxe\std/Xml.hx" module="Xml">
		<this><x path="Int"/></this>
		<haxe_doc>Xml node types.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="_Xml.XmlType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Xml.hx" private="1" module="Xml" final="1">
	<toString public="1" set="method" line="64" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="_Xml.XmlType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Xml.hx" private="1" module="Xml" final="1">
		<toString public="1" set="method" line="64" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="Xml" params="" file="C:\HaxeToolkit\haxe\std/Xml.hx">
		<Element public="1" set="null" expr="XmlType.Element" line="86" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Element</e></m></meta>
			<haxe_doc>XML element type.</haxe_doc>
		</Element>
		<PCData public="1" set="null" expr="XmlType.PCData" line="91" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.PCData</e></m></meta>
			<haxe_doc>XML parsed character data type.</haxe_doc>
		</PCData>
		<CData public="1" set="null" expr="XmlType.CData" line="96" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.CData</e></m></meta>
			<haxe_doc>XML character data type.</haxe_doc>
		</CData>
		<Comment public="1" set="null" expr="XmlType.Comment" line="101" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Comment</e></m></meta>
			<haxe_doc>XML comment type.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" expr="XmlType.DocType" line="106" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.DocType</e></m></meta>
			<haxe_doc>XML doctype element type.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" expr="XmlType.ProcessingInstruction" line="111" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.ProcessingInstruction</e></m></meta>
			<haxe_doc>XML processing instruction type.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" expr="XmlType.Document" line="116" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Document</e></m></meta>
			<haxe_doc>XML document type.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="121" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parses the String into an Xml document.</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="182" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="191" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="200" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="209" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="218" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProcessingInstruction public="1" set="method" line="227" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProcessingInstruction>
		<createDocument public="1" set="method" line="236" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<x path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<nodeName public="1" get="null" set="null">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="null" set="null">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<parent public="1" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be `null`, an Element or a Document.</haxe_doc>
		</parent>
		<children><c path="Array"><c path="Xml"/></c></children>
		<attributeMap><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></attributeMap>
		<get public="1" set="method" line="244">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns `null` if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<set public="1" set="method" line="255">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<exists public="1" set="method" line="277">
			<f a="att">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="287">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an `Iterator` on all the attribute names.</haxe_doc>
		</attributes>
		<elements public="1" set="method" line="307">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<firstElement public="1" set="method" line="337">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="353">
			<f a="x">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		A child node can only be inside one given parent node, which is indicated by the `parent` property.
		If the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.
		If the child node was previously inside a different node, it will be moved to this Document or Element.</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="366">
			<f a="x">
				<c path="Xml"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<toString public="1" get="inline" set="null" line="393">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<new set="method" line="397"><f a="nodeType">
	<x path="XmlType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Cross-platform Xml API.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.CallStack" params="" file="C:\HaxeToolkit\haxe\std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1"><meta>
	<m n=":keep"/>
	<m n=":using"><e>haxe.CallStack</e></m>
	<m n=":allow"><e>haxe.Exception</e></m>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Function" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.NotVoid" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints" interface="1"><meta><m n=":keep"/></meta></class>
	<abstract path="haxe.DynamicAccess" params="T" file="C:\HaxeToolkit\haxe\std/haxe/DynamicAccess.hx">
		<from><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></from>
		<this><d><c path="haxe.DynamicAccess.T"/></d></this>
		<to><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></to>
		<haxe_doc>DynamicAccess is an abstract type for working with anonymous structures
	that are intended to hold collections of objects by the string key.

	For example, these types of structures are often created from JSON.

	Basically, it wraps `Reflect` calls in a `Map`-like interface.</haxe_doc>
		<impl><class path="haxe._DynamicAccess.DynamicAccess_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/DynamicAccess.hx" private="1" module="haxe.DynamicAccess" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:

			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="138" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="149" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="163" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="175" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.Exception" params="" file="C:\HaxeToolkit\haxe\std/lua/_std/haxe/Exception.hx">
		<caught set="method" line="17" static="1"><f a="value">
	<x path="Any"/>
	<c path="haxe.Exception"/>
</f></caught>
		<thrown set="method" line="25" static="1"><f a="value">
	<x path="Any"/>
	<x path="Any"/>
</f></thrown>
		<message public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>Exception message.</haxe_doc>
		</message>
		<native public="1" get="accessor" set="null">
			<x path="Any"/>
			<haxe_doc>Native exception, which caused this exception.</haxe_doc>
		</native>
		<__exceptionMessage>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__exceptionMessage>
		<__nativeStack>
			<c path="Array"><c path="String"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__nativeStack>
		<__skipStack expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
			</meta>
		</__skipStack>
		<__nativeException>
			<x path="Any"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeException>
		<__previousException>
			<x path="Null"><c path="haxe.Exception"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__previousException>
		<unwrap set="method" line="48"><f a=""><x path="Any"/></f></unwrap>
		<toString public="1" set="method" line="53">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<get_message set="method" line="67"><f a=""><c path="String"/></f></get_message>
		<get_native final="1" set="method" line="75"><f a=""><x path="Any"/></f></get_native>
		<new public="1" set="method" line="35">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.Int32" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int32.hx" private="1" module="haxe.Int32" final="1">
	<shr set="method" line="209" static="1">
		<f a="a:b">
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
	</shr>
	<clamp set="method" line="267" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></clamp>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe._Int32.Int32_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int32.hx" private="1" module="haxe.Int32" final="1">
		<shr set="method" line="209" static="1">
			<f a="a:b">
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
		</shr>
		<clamp set="method" line="267" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></clamp>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.Int64" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>This typedef will fool `@:coreApi` into thinking that we are using
	the same underlying type, even though it might be different on
	specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe._Int64.___Int64" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<high public="1"><x path="haxe.Int32"/></high>
		<low public="1"><x path="haxe.Int32"/></low>
		<new public="1" get="inline" set="null" line="473"><f a="high:low">
	<x path="haxe.Int32"/>
	<x path="haxe.Int32"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Log" params="" file="C:\HaxeToolkit\haxe\std/haxe/Log.hx">
		<formatOutput public="1" set="method" line="33" static="1">
			<f a="v:infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format the output of `trace` before printing it.</haxe_doc>
		</formatOutput>
		<trace public="1" set="dynamic" line="62" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:

			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.NativeStackTrace" params="" file="C:\HaxeToolkit\haxe\std/lua/_std/haxe/NativeStackTrace.hx">
		<saveStack public="1" get="inline" set="null" line="12" static="1">
			<f a="exception">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":ifFeature"><e>"haxe.NativeStackTrace.exceptionStack"</e></m></meta>
		</saveStack>
		<callStack public="1" set="method" line="15" static="1"><f a=""><c path="Array"><c path="String"/></c></f></callStack>
		<exceptionStack public="1" set="method" line="22" static="1"><f a=""><c path="Array"><c path="String"/></c></f></exceptionStack>
		<haxe_doc>Do not use manually.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\HaxeToolkit\haxe\std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<typedef path="haxe._Rest.NativeRest" params="T" file="C:\HaxeToolkit\haxe\std/lua/_std/haxe/Rest.hx" private="1" module="haxe.Rest"><c path="lua.Table">
	<x path="Int"/>
	<c path="haxe._Rest.NativeRest.T"/>
</c></typedef>
	<abstract path="haxe.Rest" params="T" file="C:\HaxeToolkit\haxe\std/lua/_std/haxe/Rest.hx">
		<from><icast field="of"><c path="Array"><c path="of.T"/></c></icast></from>
		<this><t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t></this>
		<to><icast field="toArray"><c path="Array"><c path="haxe.Rest.T"/></c></icast></to>
		<meta><m n=":coreApi"/></meta>
		<impl><class path="haxe._Rest.Rest_Impl_" params="" file="C:\HaxeToolkit\haxe\std/lua/_std/haxe/Rest.hx" private="1" module="haxe.Rest" final="1"><meta>
	<m n=":keep"/>
	<m n=":coreApi"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.ValueException" params="" file="C:\HaxeToolkit\haxe\std/haxe/ValueException.hx">
		<extends path="haxe.Exception"/>
		<value public="1" set="null">
			<x path="Any"/>
			<haxe_doc>Thrown value.</haxe_doc>
		</value>
		<unwrap set="method" line="35" override="1">
			<f a=""><x path="Any"/></f>
			<haxe_doc>Extract an originally thrown value.

		This method must return the same value on subsequent calls.
		Used internally for catching non-native exceptions.
		Do _not_ override unless you know what you are doing.</haxe_doc>
		</unwrap>
		<new public="1" set="method" line="23"><f a="value:?previous:?native">
	<x path="Any"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception containing arbitrary value.

	This class is automatically used for throwing values, which don't extend `haxe.Exception`
	or native exception type.
	For example:
	```haxe
	throw "Terrible error";
	```
	will be compiled to
	```haxe
	throw new ValueException("Terrible error");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="lua.Table" params="A:B" file="C:\HaxeToolkit\haxe\std/lua/Table.hx" extern="1">
		<create public="1" params="A:B" set="method" static="1"><f a="?arr:?hsh">
	<c path="Array"><c path="create.B"/></c>
	<d/>
	<c path="lua.Table">
		<c path="create.A"/>
		<c path="create.B"/>
	</c>
</f></create>
		<fromArray public="1" params="T" get="inline" set="null" line="37" static="1"><f a="arr">
	<c path="Array"><c path="fromArray.T"/></c>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="fromArray.T"/>
	</c>
</f></fromArray>
		<fromMap public="1" params="A:B" get="inline" set="null" line="45" static="1">
			<f a="map">
				<t path="Map">
					<c path="fromMap.A"/>
					<c path="fromMap.B"/>
				</t>
				<c path="lua.Table">
					<c path="fromMap.A"/>
					<c path="fromMap.B"/>
				</c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromMap>
		<fromDynamic public="1" params="A:B" get="inline" set="null" line="53" static="1">
			<f a="dyn">
				<d/>
				<c path="lua.Table">
					<c path="fromDynamic.A"/>
					<c path="fromDynamic.B"/>
				</c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromDynamic>
		<toMap public="1" params="A:B" get="inline" set="null" line="61" static="1"><f a="tbl">
	<c path="lua.Table">
		<c path="toMap.A"/>
		<c path="toMap.B"/>
	</c>
	<t path="Map">
		<c path="toMap.A"/>
		<c path="toMap.B"/>
	</t>
</f></toMap>
		<toObject public="1" params="T" get="inline" set="null" line="73" static="1">
			<f a="t">
				<c path="lua.Table">
					<c path="String"/>
					<c path="toObject.T"/>
				</c>
				<d><c path="toObject.T"/></d>
			</f>
			<haxe_doc>Copies the table argument and converts it to an Object.</haxe_doc>
		</toObject>
		<toArray public="1" params="T" get="inline" set="null" line="78" static="1"><f a="tbl:?length">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="toArray.T"/>
	</c>
	<x path="Int"/>
	<c path="Array"><c path="toArray.T"/></c>
</f></toArray>
		<concat public="1" params="A:B" set="method" static="1">
			<f a="table:?sep:?i:?j">
				<c path="lua.Table">
					<c path="concat.A"/>
					<c path="concat.B"/>
				</c>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<overloads><concat public="1" params="A:B" set="method"><f a="table">
	<c path="lua.Table">
		<c path="concat.A"/>
		<c path="concat.B"/>
	</c>
	<x path="Void"/>
</f></concat></overloads>
		</concat>
		<sort public="1" params="A:B" set="method" static="1"><f a="table:?order">
	<c path="lua.Table">
		<c path="sort.A"/>
		<c path="sort.B"/>
	</c>
	<f a=":">
		<c path="sort.A"/>
		<c path="sort.A"/>
		<x path="Bool"/>
	</f>
	<x path="Void"/>
</f></sort>
		<insert public="1" params="B" set="method" static="1">
			<f a="table:pos:value">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="insert.B"/>
				</c>
				<x path="Int"/>
				<c path="insert.B"/>
				<x path="Void"/>
			</f>
			<overloads><insert public="1" params="B" set="method"><f a="table:value">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="insert.B"/>
	</c>
	<c path="insert.B"/>
	<x path="Void"/>
</f></insert></overloads>
		</insert>
		<remove public="1" params="B" set="method" static="1">
			<f a="table:?pos">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="remove.B"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads><remove public="1" params="B" set="method"><f a="table">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="remove.B"/>
	</c>
	<x path="Void"/>
</f></remove></overloads>
		</remove>
		<haxe_doc>This library provides generic functions for table manipulation.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G.table"</e></m>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta>
			<m n=":transitive"/>
			<m n=":multiType"><e>@:followWithAbstracts K</e></m>
		</meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>keyValueIterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>contains</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="C:\HaxeToolkit\haxe\std/lua/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<tnull expr="lua.Table.create()" line="30" static="1">
			<d/>
			<meta><m n=":value"><e>lua.Table.create()</e></m></meta>
		</tnull>
		<h><c path="lua.Table">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
</c></h>
		<keys public="1" set="method" line="69"><f a=""><t path="Iterator"><c path="String"/></t></f></keys>
		<new public="1" get="inline" set="null" line="32"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="lua.Table">
	<x path="Int"/>
	<c path="haxe.ds._Vector.VectorData.T"/>
</c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.exceptions.PosException" params="" file="C:\HaxeToolkit\haxe\std/haxe/exceptions/PosException.hx">
		<extends path="haxe.Exception"/>
		<posInfos final="1" public="1">
			<t path="haxe.PosInfos"/>
			<haxe_doc>Position where this exception was created.</haxe_doc>
		</posInfos>
		<toString public="1" set="method" line="24" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<new public="1" set="method" line="12"><f a="message:?previous:?pos">
	<c path="String"/>
	<c path="haxe.Exception"/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception that carry position information of a place where it was created.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.exceptions.NotImplementedException" params="" file="C:\HaxeToolkit\haxe\std/haxe/exceptions/NotImplementedException.hx">
		<extends path="haxe.exceptions.PosException"/>
		<new public="1" set="method" line="7">
			<f a="?message:?previous:?pos" v="&quot;Not implemented&quot;::">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : "Not implemented" }</e></m></meta>
		</new>
		<haxe_doc>An exception that is thrown when requested function or operation does not have an implementation.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="C:\HaxeToolkit\haxe\std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</to>
		<haxe_doc><![CDATA[An abstract type allowing values to be either of `T1` or `T2` type.
	Supports implicit casts from/to either types.

	It is useful for interfacing with external code on dynamic platforms
	such as JavaScript or Python.

	Otherwise, use of this type is discouraged.

	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.extern.Rest" params="T" file="C:\HaxeToolkit\haxe\std/haxe/extern/Rest.hx">
		<x path="haxe.Rest"><c path="haxe.extern.Rest.T"/></x>
		<haxe_doc><![CDATA[DEPRECATED: use haxe.Rest instead.
	
	A special type that represents "rest" function argument.
	Should be used as a type for the last argument of an extern method,
	representing that arbitrary number of arguments of given type can be
	passed to that method.
	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
	</typedef>
	<typedef path="haxe.io.BytesData" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/BytesData.hx"><c path="Array"><x path="Int"/></c></typedef>
	<class path="haxe.iterators.ArrayIterator" params="T" file="C:\HaxeToolkit\haxe\std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="44">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="52">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.iterators.ArrayKeyValueIterator" params="T" file="C:\HaxeToolkit\haxe\std/haxe/iterators/ArrayKeyValueIterator.hx">
		<array><c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c></array>
		<new public="1" get="inline" set="null" line="30"><f a="array">
	<c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":ifFeature">
				<e>"anon_read.keyValueIterator"</e>
				<e>"dynamic_read.keyValueIterator"</e>
			</m>
		</meta>
	</class>
	<abstract path="haxe.xml._Parser.S" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.xml._Parser.S_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.xml.XmlParserException" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Parser.hx" module="haxe.xml.Parser">
		<message public="1">
			<c path="String"/>
			<haxe_doc>the XML parsing error message</haxe_doc>
		</message>
		<lineNumber public="1">
			<x path="Int"/>
			<haxe_doc>the line number at which the XML parsing error occurred</haxe_doc>
		</lineNumber>
		<positionAtLine public="1">
			<x path="Int"/>
			<haxe_doc>the character position in the reported line at which the parsing error occurred</haxe_doc>
		</positionAtLine>
		<position public="1">
			<x path="Int"/>
			<haxe_doc>the character position in the XML string at which the parsing error occurred</haxe_doc>
		</position>
		<xml public="1">
			<c path="String"/>
			<haxe_doc>the invalid XML string</haxe_doc>
		</xml>
		<toString public="1" set="method" line="94"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="75"><f a="message:xml:position">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml.Parser" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Parser.hx">
		<escapes expr="{
	var h = new haxe.ds.StringMap();
	h.set(&quot;lt&quot;, &quot;&lt;&quot;);
	h.set(&quot;gt&quot;, &quot;&gt;&quot;);
	h.set(&quot;amp&quot;, &quot;&amp;&quot;);
	h.set(&quot;quot&quot;, &quot;\&quot;&quot;);
	h.set(&quot;apos&quot;, &quot;&apos;&quot;);
	h;
}" line="100" static="1">
			<c path="haxe.ds.StringMap"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[{
	var h = new haxe.ds.StringMap();
	h.set("lt", "<");
	h.set("gt", ">");
	h.set("amp", "&");
	h.set("quot", "\"");
	h.set("apos", "'");
	h;
}]]></e></m></meta>
		</escapes>
		<parse public="1" set="method" line="115" static="1">
			<f a="str:?strict" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="Xml"/>
			</f>
			<meta><m n=":value"><e>{ strict : false }</e></m></meta>
			<haxe_doc>Parses the String into an XML Document. Set strict parsing to true in order to enable a strict check of XML attributes and entities.

		@throws haxe.xml.XmlParserException</haxe_doc>
		</parse>
		<doParse set="method" line="121" static="1">
			<f a="str:strict:?p:?parent" v="::0:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Xml"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ p : 0 }</e></m></meta>
		</doParse>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml.Printer" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Printer.hx">
		<print public="1" set="method" line="35" static="1">
			<f a="xml:?pretty" v=":false">
				<c path="Xml"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ pretty : false }</e></m></meta>
			<haxe_doc>Convert `Xml` to string representation.

		Set `pretty` to `true` to prettify the result.</haxe_doc>
		</print>
		<output><c path="StringBuf"/></output>
		<pretty><x path="Bool"/></pretty>
		<writeNode set="method" line="49"><f a="value:tabs">
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeNode>
		<hasChildren set="method" line="114"><f a="value">
	<c path="Xml"/>
	<x path="Bool"/>
</f></hasChildren>
		<new set="method" line="44"><f a="pretty">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>This class provides utility methods to convert Xml instances to
	String representation.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="lua.NativeStringTools" params="" file="C:\HaxeToolkit\haxe\std/lua/NativeStringTools.hx" extern="1">
		<len public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Receives a string and returns its length. The empty string `""` has
		length `0`. Embedded zeros are counted, so `"a\000bc\000"` has length `5`.</haxe_doc>
		</len>
		<char public="1" set="method" static="1">
			<f a="codes">
				<t path="haxe.extern.Rest"><x path="Int"/></t>
				<c path="String"/>
			</f>
			<haxe_doc>Receives zero or more integers. Returns a string with length equal to the
		number of arguments, in which each character has the internal numerical
		code equal to its corresponding argument.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</char>
		<sub public="1" set="method" static="1">
			<f a="str:start:?end">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.StringSub"/>
			</f>
			<haxe_doc>Returns the substring of `str` that starts at `start` and continues until `end`;
		`start` and `end` can be negative. If `end` is absent, then it is assumed to be
		equal to `-1` (which is the same as the string length).
		In particular, the call `sub(str,1,end)` returns a prefix of `str`
		with length `end`, and `sub(str, -end)` returns a suffix of `str` with
		length `start`.</haxe_doc>
		</sub>
		<find public="1" set="method" static="1">
			<f a="str:target:?start:?plain">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="lua.StringFind"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string `str`.
		If it finds a match, then `find` returns the indices of `str` where this
		occurrence starts and ends.

		@param target If the target has captures, then in a successful match the
			   captured values are also returned, after the two indices.
		@param start specifies where to start the search; its default value is `1`
			   and can be negative.
		@param plain turns off the pattern matching facilities, so the function does
			   a plain "find substring" operation, with no characters in pattern
			   being considered "magic". Note that if plain is given, then `start` must be given as well.</haxe_doc>
		</find>
		<byte public="1" set="method" static="1">
			<f a="str:?index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the internal numerical codes of the characters `str[index]`.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</byte>
		<format public="1" set="method" static="1">
			<f a="str:?e1:?e2:?e3:?e4">
				<c path="String"/>
				<d/>
				<d/>
				<d/>
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a formatted version of its variable number of arguments following
		the description given in its first argument (which must be a string).
		The format string follows the same rules as the printf family of standard C
		functions. The only differences are that the options/modifiers
		`*`, `l`, `L`, `n`, `p`, and `h` are not supported and that there is an
		extra option, `q`. The `q` option formats a string in a form suitable to be
		safely read back by the Lua interpreter: the string is written between
		double quotes, and all double quotes, newlines, embedded zeros,
		and backslashes in the string are correctly escaped when written.
		For instance, the call
		   `string.format('%q', 'a string with "quotes" and \n new line')`
		will produce the string:
		`"a string with \"quotes\" and \
			  new line"`

		The options `c`, `d` `E`, `e`, `f`, `g`, `G`, `i`, `o`, `u, `X-, and `x` all
		expect a number as argument, whereas `q` and `s` expect a string.

		This function does not accept string values containing embedded zeros,
		except as arguments to the `q` option.</haxe_doc>
		</format>
		<gsub public="1" set="method" static="1">
			<f a="str:pattern:replace:?n">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
			<overloads>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<x path="Void"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<c path="String"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
			</overloads>
		</gsub>
		<gmatch public="1" set="method" static="1">
			<f a="str:pattern">
				<c path="String"/>
				<c path="String"/>
				<f a=""><c path="String"/></f>
			</f>
			<haxe_doc>Returns an iterator function that, each time it is called, returns the next
		captures from pattern over string `str`. If `pattern` specifies no captures,
		then the whole match is produced in each call.</haxe_doc>
			<overloads><gmatch public="1" set="method">
	<f a="str:pattern:match:?n">
		<c path="String"/>
		<c path="String"/>
		<f a=""><c path="String"/></f>
		<x path="Int"/>
		<f a="">
			<c path="String"/>
			<x path="Void"/>
		</f>
	</f>
	<haxe_doc>Returns an iterator function that, each time it is called, returns the next
		captures from pattern over string `str`. If `pattern` specifies no captures,
		then the whole match is produced in each call.</haxe_doc>
</gmatch></overloads>
		</gmatch>
		<match public="1" set="method" static="1">
			<f a="str:pattern:?n">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string s. If it finds one,
		then match returns the captures from the pattern; otherwise it returns `null`.
		If pattern specifies no captures, then the whole match is returned.
		The optional argument `n` specifies where to start the search;
		its default value is `1` and can be negative.</haxe_doc>
		</match>
		<upper public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all lowercase
		letters changed to uppercase. All other characters are left unchanged.
		The definition of what a lowercase letter is depends on the current locale.</haxe_doc>
		</upper>
		<lower public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all uppercase
		letters changed to lowercase. All other characters are left unchanged.
		The definition of what an uppercase letter is depends on the current locale.</haxe_doc>
		</lower>
		<dump public="1" set="method" static="1">
			<f a="d">
				<d/>
				<d/>
			</f>
			<haxe_doc>Returns a string containing a binary representation of the given function,
		so that a later loadstring on this string returns a copy of the function.
		function must be a Lua function without upvalues.</haxe_doc>
		</dump>
		<rep public="1" set="method" static="1">
			<f a="s:n:?sep">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string that is the concatenation of n copies of
        the string s separated by the string sep. The default value
        for sep is the empty string (that is, no separator).
        Returns the empty string if n is not positive.  (Note that
        it is very easy to exhaust the memory of your machine with
        a single call to this function.)</haxe_doc>
		</rep>
		<haxe_doc>These are all externs for the base Lua "string" class, which functions
	as an additional set of string tools.

	Note that all relevant indexes are "1" based.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G.string"</e></m>
		</meta>
	</class>
	<class path="lua.Boot" params="" file="C:\HaxeToolkit\haxe\std/lua/Boot.hx">
		<__instanceof set="method" line="89" static="1">
			<f a="o:cl">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"typed_catch"</e></m>
			</meta>
			<haxe_doc>Indicates if the given object is an instance of the given Type</haxe_doc>
		</__instanceof>
		<isArray set="method" line="130" static="1">
			<f a="o">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isArray>
		<extendsOrImplements public="1" set="method" line="226" static="1">
			<f a="cl1:cl2">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Helper method to determine if class cl1 extends, implements, or otherwise equals cl2</haxe_doc>
		</extendsOrImplements>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="lua.Debug" params="" file="C:\HaxeToolkit\haxe\std/lua/Debug.hx" extern="1">
		<getlocal public="1" set="method" static="1">
			<f a="stackLevel:idx">
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>This function returns the name and the value of the local variable with
		index local of the function at level level of the stack.</haxe_doc>
		</getlocal>
		<setlocal public="1" set="method" static="1">
			<f a="stackLevel:varName:value">
				<x path="Int"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>This function assigns the value value to the local variable with index
		local of the function at level level of the stack.
		Call `getinfo` to check whether the level is valid.</haxe_doc>
		</setlocal>
		<getinfo public="1" set="method" static="1">
			<f a="stackLevel">
				<x path="Int"/>
				<t path="lua.DebugInfo"/>
			</f>
			<haxe_doc>Returns a table with information about a function.</haxe_doc>
		</getinfo>
		<sethook public="1" set="method" static="1">
			<f a="?fun:?monitor">
				<x path="haxe.Function"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the given function as a hook.
		When called without arguments, `Debug.sethook` turns off the hook.</haxe_doc>
		</sethook>
		<debug public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Enters an interactive mode with the user, running each string that the user enters.
		Using simple commands and other debug facilities, the user can inspect
		global and local variables, change their values, evaluate expressions,
		and so on. A line containing only the word `cont` finishes this function,
		so that the caller continues its execution.

		Note that commands for `Debug.debug` are not lexically nested within any
		function, and so have no direct access to local variables.</haxe_doc>
		</debug>
		<gethook public="1" set="method" static="1">
			<f a="thread">
				<c path="lua.Thread"/>
				<x path="haxe.Function"/>
			</f>
			<haxe_doc>Returns the current hook settings of the thread, as three values:
		the current hook function, the current hook mask, and the current hook count
		(as set by the `Debug.sethook` function).</haxe_doc>
		</gethook>
		<getregistry public="1" set="method" static="1">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns the registry table.</haxe_doc>
		</getregistry>
		<getmetatable public="1" set="method" static="1">
			<f a="value">
				<t path="lua.AnyTable"/>
				<t path="lua.AnyTable"/>
			</f>
			<haxe_doc>Returns the metatable of the given `value` or `null` if it does not have a metatable.</haxe_doc>
		</getmetatable>
		<setmetatable public="1" set="method" static="1">
			<f a="value:table">
				<t path="lua.AnyTable"/>
				<t path="lua.AnyTable"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the metatable for the given `value` to the given `table` (can be `null`).</haxe_doc>
		</setmetatable>
		<getupvalue public="1" set="method" static="1">
			<f a="f:up">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>This function returns the name and the value of the upvalue with index `up`
		of the function `f`. The function returns `null` if there is no upvalue with
		the given index.</haxe_doc>
		</getupvalue>
		<setupvalue public="1" set="method" static="1">
			<f a="f:up:val">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>This function assigns the value value to the upvalue with index up of
		the function `f`. The function returns `null` if there is no upvalue with
		the given index. Otherwise, it returns the name of the upvalue.</haxe_doc>
		</setupvalue>
		<getuservalue public="1" set="method" static="1">
			<f a="val">
				<d/>
				<d/>
			</f>
			<haxe_doc>Returns the Lua value associated to `val`.
		If `val` is not a `UserData`, returns `null`.</haxe_doc>
		</getuservalue>
		<setuservalue public="1" set="method" static="1">
			<f a="udata:val">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the given value as the Lua value associated to the given udata.
		`udata` must be a full `UserData`.</haxe_doc>
		</setuservalue>
		<traceback public="1" set="method" static="1">
			<f a="?thread:?message:?level">
				<c path="lua.Thread"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a traceback of the call stack.
		@param message (optional) is appended at the beginning of the traceback.
		@param level (optional) tells at which level to start the traceback.
			   default is `1`, the function calling traceback.</haxe_doc>
		</traceback>
		<upvalueid public="1" set="method" static="1">
			<f a="f:n">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Returns a unique identifier (as a light userdata) for the upvalue numbered
		`n` from the given function `f`.</haxe_doc>
		</upvalueid>
		<upvaluejoin public="1" set="method" static="1">
			<f a="f1:n1:f2:n2">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<x path="haxe.Function"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Make the `n1`-th upvalue of the Lua closure `f1` refer to the `n2`-th
		upvalue of the Lua closure `f2`.</haxe_doc>
		</upvaluejoin>
		<haxe_doc>Externs for the "debug" class for Haxe lua</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"debug"</e></m>
		</meta>
	</class>
	<typedef path="lua.DebugInfo" params="" file="C:\HaxeToolkit\haxe\std/lua/Debug.hx" module="lua.Debug">
		<a>
			<what><c path="String"/></what>
			<source><c path="String"/></source>
			<short_src><c path="String"/></short_src>
			<nups><x path="Int"/></nups>
			<nparams><x path="Int"/></nparams>
			<namewhat><c path="String"/></namewhat>
			<name><c path="String"/></name>
			<linedefined><x path="Int"/></linedefined>
			<lastlinedefined><x path="Int"/></lastlinedefined>
			<isvararg><x path="Bool"/></isvararg>
			<istailcall><x path="Bool"/></istailcall>
			<func><x path="haxe.Function"/></func>
			<currentline><x path="Int"/></currentline>
		</a>
		<haxe_doc>A enumerator that describes the output of `Debug.getinfo()`.</haxe_doc>
	</typedef>
	<class path="lua.UserData" params="" file="C:\HaxeToolkit\haxe\std/lua/UserData.hx"><meta>
	<m n=":keep"/>
	<m n=":directlyUsed"/>
</meta></class>
	<class path="lua.FileHandle" params="" file="C:\HaxeToolkit\haxe\std/lua/FileHandle.hx" extern="1">
		<extends path="lua.UserData"/>
		<flush public="1" set="method"><f a=""><x path="Void"/></f></flush>
		<read public="1" set="method"><f a="arg">
	<t path="haxe.extern.Rest"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<x path="Int"/>
</x></t>
	<c path="String"/>
</f></read>
		<lines public="1" set="method"><f a=""><x path="lua.NativeIterator"><c path="String"/></x></f></lines>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<write public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<seek public="1" set="method">
			<f a="arg:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<seek public="1" set="method"><f a=""><x path="Int"/></f></seek>
				<seek public="1" set="method"><f a="arg">
	<c path="String"/>
	<x path="Int"/>
</f></seek>
			</overloads>
		</seek>
	</class>
	<class path="lua.Io" params="" file="C:\HaxeToolkit\haxe\std/lua/Io.hx" extern="1">
		<stdin public="1" static="1"><c path="lua.FileHandle"/></stdin>
		<stderr public="1" static="1"><c path="lua.FileHandle"/></stderr>
		<stdout public="1" static="1"><c path="lua.FileHandle"/></stdout>
		<close public="1" set="method" static="1">
			<f a="?file">
				<c path="lua.FileHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Function to close regular files.</haxe_doc>
		</close>
		<flush public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Saves any written data to file.</haxe_doc>
		</flush>
		<input public="1" set="method" static="1">
			<f a="file">
				<c path="lua.FileHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>When called with a file name, it opens the named file (in text mode),
		and sets its handle as the default input file. When called with a file handle,
		it simply sets this file handle as the default input file.
		When called without parameters, it returns the current default input file.

		In case of errors this function raises the error, instead of returning an
		error code.</haxe_doc>
			<overloads><input public="1" set="method">
	<f a="file">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>When called with a file name, it opens the named file (in text mode),
		and sets its handle as the default input file. When called with a file handle,
		it simply sets this file handle as the default input file.
		When called without parameters, it returns the current default input file.

		In case of errors this function raises the error, instead of returning an
		error code.</haxe_doc>
</input></overloads>
		</input>
		<lines public="1" set="method" static="1">
			<f a="?file">
				<c path="String"/>
				<x path="lua.NativeIterator"><c path="String"/></x>
			</f>
			<haxe_doc>Opens the given file name in read mode and returns an iterator function that,
		each time it is called, returns a new line from the file.</haxe_doc>
		</lines>
		<open public="1" set="method" static="1">
			<f a="filename:?mode">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.FileHandle"/>
			</f>
			<haxe_doc>This function opens a file, in the mode specified in the string mode.
		It returns a new file handle, or, in case of errors, `null` plus an error message.

		The mode string can be any of the following:

		* `"r"`: read mode (the default)
		* `"w"`: write mode
		* `"a"`: append mode
		* `"r+"`: update mode, all previous data is preserved
		* `"w+"`: update mode, all previous data is erased
		* `"a+"`: append update mode, previous data is preserved, writing is only
			allowed at the end of file

		The mode string can also have a `b` at the end, which is needed in some systems
		to open the file in binary mode. This string is exactly what is used in the
		standard C function fopen.</haxe_doc>
		</open>
		<popen public="1" set="method" static="1">
			<f a="command:?mode">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.FileHandle"/>
			</f>
			<haxe_doc>Starts program `command` in a separated process and returns a file handle that
		you can use to read data from this program (if mode is `"r"`, the default)
		or to write data to this program (if mode is `"w"`).

		This function is system dependent and is not available on all platforms.</haxe_doc>
		</popen>
		<read public="1" set="method" static="1">
			<f a="?filename">
				<c path="String"/>
				<c path="String"/>
			</f>
			<overloads><read public="1" set="method"><f a="?count">
	<x path="Int"/>
	<c path="String"/>
</f></read></overloads>
		</read>
		<write public="1" set="method" static="1">
			<f a="v">
				<t path="haxe.extern.Rest"><c path="String"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes the value of each of its arguments to the file. The arguments must
		be strings or numbers.
		To write other values, use `Lua.tostring` or `NativeStringTools.format`
		before write.</haxe_doc>
		</write>
		<output public="1" set="method" static="1"><f a="?file">
	<c path="String"/>
	<c path="lua.FileHandle"/>
</f></output>
		<tmpfile public="1" set="method" static="1">
			<f a=""><c path="lua.FileHandle"/></f>
			<haxe_doc>Returns a handle for a temporary file. This file is opened in update mode
		and it is automatically removed when the program ends.</haxe_doc>
		</tmpfile>
		<type public="1" set="method" static="1">
			<f a="obj">
				<c path="lua.FileHandle"/>
				<x path="lua.IoType"/>
			</f>
			<haxe_doc>Checks whether `obj` is a valid file handle.</haxe_doc>
		</type>
		<haxe_doc>Input and Output Facilities</haxe_doc>
		<meta><m n=":native"><e>"_G.io"</e></m></meta>
	</class>
	<abstract path="lua.IoType" params="" file="C:\HaxeToolkit\haxe\std/lua/Io.hx" module="lua.Io">
		<this><c path="String"/></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<haxe_doc>A enumerator that describes the output of `Io.type()`.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._Io.IoType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/lua/Io.hx" private="1" module="lua.Io" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="lua.LocaleCategory" params="" file="C:\HaxeToolkit\haxe\std/lua/LocaleCategory.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._LocaleCategory.LocaleCategory_Impl_" params="" file="C:\HaxeToolkit\haxe\std/lua/LocaleCategory.hx" private="1" module="lua.LocaleCategory" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.Lua" params="" file="C:\HaxeToolkit\haxe\std/lua/Lua.hx" extern="1">
		<_VERSION public="1" static="1">
			<c path="String"/>
			<haxe_doc>A global variable that holds a string containing the current interpreter
		version.</haxe_doc>
		</_VERSION>
		<arg public="1" static="1"><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></arg>
		<getmetatable public="1" set="method" static="1">
			<f a="tbl">
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
			</f>
			<haxe_doc>Pushes onto the stack the metatable in the registry.</haxe_doc>
		</getmetatable>
		<setmetatable public="1" set="method" static="1">
			<f a="tbl:mtbl">
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
			</f>
			<haxe_doc>Pops a table from the stack and sets it as the new metatable for the value
		at the given acceptable index.</haxe_doc>
		</setmetatable>
		<setfenv public="1" set="method" static="1">
			<f a="i:tbl">
				<x path="Int"/>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<x path="Void"/>
			</f>
			<haxe_doc>Pops a table from the stack and sets it as the new environment for the value
		at the given index. If the value at the given index is neither a function nor
		a thread nor a userdata, lua_setfenv returns `0`.
		Otherwise it returns `1`.</haxe_doc>
		</setfenv>
		<next public="1" params="K:V" set="method" static="1">
			<f a="k:?i">
				<c path="lua.Table">
					<c path="next.K"/>
					<c path="next.V"/>
				</c>
				<c path="next.K"/>
				<c path="lua.NextResult">
					<c path="next.K"/>
					<c path="next.V"/>
				</c>
			</f>
			<haxe_doc>Allows a program to traverse all fields of a table.
		Its first argument is a table and its second argument is an index in this
		table. `next` returns the next index of the table and its associated value.
		When `i` is `null`, `next` returns an initial index and its associated value.
		When called with the last index, or with `null` in an empty table, `next`
		returns `null`.  In particular, you can use `next(t)` to check whether a
		table is empty.

		The order in which the indices are enumerated is not specified, even for
		numeric indices. (To traverse a table in numeric order, use a numerical for
		or the `ipairs` function).

		The behavior of next is undefined if, during the traversal, any value
		to a non-existent field in the table is assigned. Existing fields may
		however be modified. In particular, existing fields may be cleared.</haxe_doc>
		</next>
		<tostring public="1" set="method" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives an argument of any type and converts it to a string in a reasonable
		format.

		For complete control of how numbers are converted, use`NativeStringTools.format`.</haxe_doc>
		</tostring>
		<ipairs public="1" params="K:V" set="method" static="1"><f a="t">
	<c path="lua.Table">
		<c path="ipairs.K"/>
		<c path="ipairs.V"/>
	</c>
	<c path="lua.IPairsResult">
		<c path="ipairs.K"/>
		<c path="ipairs.V"/>
	</c>
</f></ipairs>
		<pairs public="1" params="K:V" set="method" static="1"><f a="t">
	<c path="lua.Table">
		<c path="pairs.K"/>
		<c path="pairs.V"/>
	</c>
	<c path="lua.PairsResult">
		<c path="pairs.K"/>
		<c path="pairs.V"/>
	</c>
</f></pairs>
		<require public="1" set="method" static="1"><f a="module">
	<c path="String"/>
	<d/>
</f></require>
		<tonumber public="1" set="method" static="1">
			<f a="str:?base">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts the Lua value at the given acceptable base to `Int`.
		The Lua value must be a number or a string convertible to a number,
		otherwise `tonumber` returns `0`.</haxe_doc>
		</tonumber>
		<type public="1" set="method" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the Lua type of its only argument as a string.
		The possible results of this function are:

		* `"nil"` (a string, not the Lua value nil),
		* `"number"`
		* `"string"`
		* `"boolean"`
		* `"table"`
		* `"function"`
		* `"thread"`
		* `"userdata"`</haxe_doc>
		</type>
		<print public="1" set="method" static="1">
			<f a="v">
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Receives any number of arguments, and prints their values to stdout,
		using the tostring function to convert them to strings.
		`print` is not intended for formatted output, but only as a quick way to show
		a value, typically for debugging.

		For complete control of how numbers are converted, use `NativeStringTools.format`.</haxe_doc>
		</print>
		<select public="1" set="method" static="1">
			<f a="n:rest">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<d/>
			</f>
			<haxe_doc>If `n` is a number, returns all arguments after argument number `n`.
		Otherwise, `n` must be the string `"#"`, and select returns the total
		number of extra arguments it received.</haxe_doc>
		</select>
		<rawget public="1" params="K:V" set="method" static="1">
			<f a="t:k">
				<c path="lua.Table">
					<c path="rawget.K"/>
					<c path="rawget.V"/>
				</c>
				<c path="rawget.K"/>
				<c path="rawget.V"/>
			</f>
			<haxe_doc>Gets the real value of `table[index]`, without invoking any metamethod.</haxe_doc>
		</rawget>
		<rawset public="1" params="K:V" set="method" static="1">
			<f a="t:k:v">
				<c path="lua.Table">
					<c path="rawset.K"/>
					<c path="rawset.V"/>
				</c>
				<c path="rawset.K"/>
				<c path="rawset.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the real value of `table[index]` to value, without invoking any metamethod.</haxe_doc>
		</rawset>
		<collectgarbage public="1" set="method" static="1">
			<f a="opt:?arg">
				<x path="lua.CollectGarbageOption"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>This function is a generic interface to the garbage collector.
		It performs different functions according to its first argument.</haxe_doc>
		</collectgarbage>
		<assert public="1" params="T" set="method" static="1">
			<f a="v:?message">
				<c path="assert.T"/>
				<c path="String"/>
				<c path="assert.T"/>
			</f>
			<haxe_doc>Issues an error when the value of its argument `v` is `false` (i.e., `null`
		or `false`) otherwise, returns all its arguments. message is an error message.
		when absent, it defaults to "assertion failed!"</haxe_doc>
		</assert>
		<dofile public="1" set="method" static="1">
			<f a="filename">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Loads and runs the given file.</haxe_doc>
		</dofile>
		<error public="1" set="method" static="1">
			<f a="message:?level">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Generates a Lua error. The error message (which can actually be a Lua value
		of any type) must be on the stack top. This function does a long jump,
		and therefore never returns.</haxe_doc>
		</error>
		<pcall public="1" set="method" static="1">
			<f a="f:rest">
				<x path="haxe.Function"/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="lua.PCallResult"/>
			</f>
			<haxe_doc>Calls a function in protected mode.</haxe_doc>
		</pcall>
		<rawequal public="1" set="method" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the two values in acceptable indices `v1` and `v2` are
		primitively equal (that is, without calling metamethods).
		Otherwise returns `false`.
		Also returns `false` if any of the indices are non valid.</haxe_doc>
		</rawequal>
		<xpcall public="1" set="method" static="1">
			<f a="f:msgh:rest">
				<x path="haxe.Function"/>
				<x path="haxe.Function"/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="lua.PCallResult"/>
			</f>
			<haxe_doc>This function is similar to pcall, except that you can set a new error
		handler.</haxe_doc>
		</xpcall>
		<loadfile public="1" set="method" static="1">
			<f a="filename">
				<c path="String"/>
				<c path="lua.LoadResult"/>
			</f>
			<haxe_doc>Loads the chunk from file filename or from the standard input if no filename
		is given.</haxe_doc>
		</loadfile>
		<load public="1" set="method" static="1">
			<f a="code">
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<f a=""><c path="String"/></f>
				</x>
				<c path="lua.LoadResult"/>
			</f>
			<haxe_doc>Loads the chunk from given string.</haxe_doc>
		</load>
		<haxe_doc>These are all global static methods within Lua.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<abstract path="lua.CollectGarbageOption" params="" file="C:\HaxeToolkit\haxe\std/lua/Lua.hx" module="lua.Lua">
		<this><c path="String"/></this>
		<haxe_doc>Enum for describing garbage collection options</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._Lua.CollectGarbageOption_Impl_" params="" file="C:\HaxeToolkit\haxe\std/lua/Lua.hx" private="1" module="lua.Lua" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.PCallResult" params="" file="C:\HaxeToolkit\haxe\std/lua/Lua.hx" module="lua.Lua" extern="1">
		<status public="1"><x path="Bool"/></status>
		<value public="1"><d/></value>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.NextResult" params="K:V" file="C:\HaxeToolkit\haxe\std/lua/Lua.hx" module="lua.Lua" extern="1">
		<index public="1"><c path="lua.NextResult.K"/></index>
		<value public="1"><c path="lua.NextResult.V"/></value>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.IPairsResult" params="K:V" file="C:\HaxeToolkit\haxe\std/lua/Lua.hx" module="lua.Lua" extern="1">
		<next public="1"><f a=":">
	<c path="lua.Table">
		<c path="lua.IPairsResult.K"/>
		<c path="lua.IPairsResult.V"/>
	</c>
	<x path="Int"/>
	<c path="lua.NextResult">
		<x path="Int"/>
		<c path="lua.IPairsResult.V"/>
	</c>
</f></next>
		<table public="1"><c path="lua.Table">
	<c path="lua.IPairsResult.K"/>
	<c path="lua.IPairsResult.V"/>
</c></table>
		<index public="1"><x path="Int"/></index>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.PairsResult" params="K:V" file="C:\HaxeToolkit\haxe\std/lua/Lua.hx" module="lua.Lua" extern="1">
		<next public="1"><f a=":">
	<c path="lua.Table">
		<c path="lua.PairsResult.K"/>
		<c path="lua.PairsResult.V"/>
	</c>
	<c path="lua.PairsResult.K"/>
	<c path="lua.NextResult">
		<c path="lua.PairsResult.K"/>
		<c path="lua.PairsResult.V"/>
	</c>
</f></next>
		<table public="1"><c path="lua.Table">
	<c path="lua.PairsResult.K"/>
	<c path="lua.PairsResult.V"/>
</c></table>
		<index public="1"><c path="lua.PairsResult.K"/></index>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.LoadResult" params="" file="C:\HaxeToolkit\haxe\std/lua/Lua.hx" module="lua.Lua" extern="1">
		<func public="1"><x path="haxe.Function"/></func>
		<message public="1"><c path="String"/></message>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.Math" params="" file="C:\HaxeToolkit\haxe\std/lua/Math.hx" extern="1">
		<pi public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>The value of pi.</haxe_doc>
		</pi>
		<huge public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>The value HUGE_VAL, a value larger than or equal to any other numerical value.</haxe_doc>
		</huge>
		<abs public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of x.</haxe_doc>
		</abs>
		<ceil public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer larger than or equal to x.</haxe_doc>
		</ceil>
		<floor public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer smaller than or equal to x.</haxe_doc>
		</floor>
		<acos public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the arc cosine of x (in radians).</haxe_doc>
		</acos>
		<asin public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the arc sine of x (in radians).</haxe_doc>
		</asin>
		<atan public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the arc tangent of x (in radians).</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result.
		(It also handles correctly the case of x being zero.)</haxe_doc>
		</atan2>
		<cos public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the cosine of x (assumed to be in radians).</haxe_doc>
		</cos>
		<cosh public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the hyperbolic cosine of x.</haxe_doc>
		</cosh>
		<sin public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the sine of x (assumed to be in radians).</haxe_doc>
		</sin>
		<sinh public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the hyperbolic sine of x.</haxe_doc>
		</sinh>
		<tan public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the tangent of x (assumed to be in radians)</haxe_doc>
		</tan>
		<tanh public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the hyperbolic tangent of x.</haxe_doc>
		</tanh>
		<rad public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the angle x (given in degrees) in radians.</haxe_doc>
		</rad>
		<modf public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns two numbers, the integral part of x and the fractional part of x.</haxe_doc>
		</modf>
		<fmod public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the remainder of the division of x by y that rounds the quotient towards zero.</haxe_doc>
		</fmod>
		<pow public="1" set="method" static="1">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns y-th power of x.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of x.</haxe_doc>
		</sqrt>
		<exp public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the value e^x.</haxe_doc>
		</exp>
		<frexp public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<c path="lua.MathFrexpResult"/>
			</f>
			<haxe_doc>Returns m and e such that x = m2^e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero).</haxe_doc>
		</frexp>
		<ldexp public="1" set="method" static="1">
			<f a="m:e">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns m2^e (e should be an integer).</haxe_doc>
		</ldexp>
		<log public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of x.</haxe_doc>
		</log>
		<log10 public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the base-10 logarithm of x.</haxe_doc>
		</log10>
		<max public="1" set="method" static="1">
			<f a="x:numbers">
				<x path="Float"/>
				<t path="haxe.extern.Rest"><x path="Float"/></t>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the maximum value among its arguments.</haxe_doc>
		</max>
		<min public="1" set="method" static="1">
			<f a="x:numbers">
				<x path="Float"/>
				<t path="haxe.extern.Rest"><x path="Float"/></t>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the minimum value among its arguments.</haxe_doc>
		</min>
		<deg public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the angle x (given in radians) in degrees.</haxe_doc>
		</deg>
		<random public="1" set="method" static="1">
			<f a="?m:?n">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>This function is an interface to the simple pseudo-random generator function rand provided by ANSI C.
		(No guarantees can be given for its statistical properties.)

		When called without arguments, returns a uniform pseudo-random real number in the range [0,1).
		When called with an integer number `m`, returns a uniform pseudo-random integer in the range [1, m].
		When called with two integer numbers `m` and `n`, returns a uniform pseudo-random integer in the range [m, n].</haxe_doc>
		</random>
		<randomseed public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Sets `x` as the "seed" for the pseudo-random generator: equal seeds produce equal sequences of numbers.</haxe_doc>
		</randomseed>
		<haxe_doc>Mathematical Functions</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G.math"</e></m>
		</meta>
	</class>
	<class path="lua.MathFrexpResult" params="" file="C:\HaxeToolkit\haxe\std/lua/Math.hx" module="lua.Math" extern="1">
		<m public="1"><x path="Float"/></m>
		<e public="1"><x path="Int"/></e>
		<haxe_doc>The return value of `Math.frexp`.</haxe_doc>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<abstract path="lua.NativeIterator" params="T" file="C:\HaxeToolkit\haxe\std/lua/NativeIterator.hx">
		<from><icast field="fromF"><f a=""><c path="fromF.T"/></f></icast></from>
		<this><f a=""><c path="lua.NativeIterator.T"/></f></this>
		<to><icast field="toIterator"><a>
	<next set="method">
		<f a=""><c path="lua.NativeIterator.T"/></f>
		<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
	</next>
	<hasNext set="method">
		<f a=""><x path="Bool"/></f>
		<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
	</hasNext>
</a></icast></to>
		<haxe_doc>This abstract enables easy conversion from basic lua iterators
	(i.e., a function that is called until it returns null), and
	Haxe iterators, which provide a next/hasNext interface.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="lua._NativeIterator.NativeIterator_Impl_" params="" file="C:\HaxeToolkit\haxe\std/lua/NativeIterator.hx" private="1" module="lua.NativeIterator" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="lua.StringFind" params="" file="C:\HaxeToolkit\haxe\std/lua/NativeStringTools.hx" module="lua.NativeStringTools" extern="1">
		<begin public="1"><x path="Int"/></begin>
		<end public="1"><x path="Int"/></end>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.StringSub" params="" file="C:\HaxeToolkit\haxe\std/lua/NativeStringTools.hx" module="lua.NativeStringTools" extern="1">
		<match public="1"><c path="String"/></match>
		<count public="1"><x path="Int"/></count>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.Os" params="" file="C:\HaxeToolkit\haxe\std/lua/Os.hx" extern="1">
		<clock public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns an approximation of the amount in seconds of CPU time used by the
		program.</haxe_doc>
		</clock>
		<date public="1" set="method" static="1">
			<f a=""><t path="lua.DateType"/></f>
			<overloads>
				<date public="1" set="method"><f a="format:time">
	<c path="String"/>
	<t path="lua.Time"/>
	<t path="lua.DateType"/>
</f></date>
				<date public="1" set="method"><f a="format">
	<c path="String"/>
	<t path="lua.DateType"/>
</f></date>
			</overloads>
		</date>
		<difftime public="1" set="method" static="1">
			<f a="t2:t1">
				<t path="lua.Time"/>
				<t path="lua.Time"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the number of seconds from time `t1` to time `t2`.
		In POSIX, Windows, and some other systems, this value is exactly `t2-t1`.</haxe_doc>
		</difftime>
		<execute public="1" set="method" static="1">
			<f a="?command">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>This function is equivalent to the C function system. It passes command to
		be executed by an operating system shell. It returns a status code,
		which is system-dependent. If command is absent, then it returns
		nonzero if a shell is available and zero otherwise.</haxe_doc>
		</execute>
		<exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Calls the C function exit, with an optional code, to terminate the host program.
		The default value for code is the success code.</haxe_doc>
		</exit>
		<getenv public="1" set="method" static="1">
			<f a="varname">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the process environment variable `varname`, or `null`
		if the variable is not defined.</haxe_doc>
		</getenv>
		<remove public="1" set="method" static="1">
			<f a="filename">
				<c path="String"/>
				<c path="lua.OsSuccess"/>
			</f>
			<haxe_doc>Deletes the file or directory with the given name.
		Directories must be empty to be removed.</haxe_doc>
		</remove>
		<rename public="1" set="method" static="1">
			<f a="oldname:newname">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.OsSuccess"/>
			</f>
			<haxe_doc>Renames file or directory named `oldname` to `newname`.</haxe_doc>
		</rename>
		<setlocale public="1" set="method" static="1">
			<f a="locale:?category">
				<c path="String"/>
				<x path="lua.LocaleCategory"/>
				<c path="String"/>
			</f>
			<haxe_doc>Sets the current locale of the program.</haxe_doc>
		</setlocale>
		<time public="1" set="method" static="1">
			<f a="?arg">
				<x path="Null"><t path="lua.TimeParam"/></x>
				<t path="lua.Time"/>
			</f>
			<haxe_doc>Returns the current time when called without arguments, or a time
		representing the date and time specified by the given table.

		The returned value is a number, whose meaning depends on your system.
		In POSIX, Windows, and some other systems, this number counts the number
		of seconds since some given start time (the "epoch").
		In other systems, the meaning is not specified, and the number returned
		by time can be used only as an argument to date and difftime.</haxe_doc>
		</time>
		<tmpname public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string with a file name that can be used for a temporary file.
		The file must be explicitly opened before its use and explicitly removed
		when no longer needed.

		When possible, you may prefer to use `Io.tmpfile`, which automatically
		removes the file when the program ends.</haxe_doc>
		</tmpname>
		<haxe_doc>Operating System Facilities.</haxe_doc>
		<meta><m n=":native"><e>"_G.os"</e></m></meta>
	</class>
	<typedef path="lua.TimeParam" params="" file="C:\HaxeToolkit\haxe\std/lua/Os.hx" module="lua.Os">
		<a>
			<year><x path="Int"/></year>
			<sec>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
			</sec>
			<month><x path="Int"/></month>
			<min>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
			</min>
			<isdst>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</isdst>
			<hour>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
			</hour>
			<day><x path="Int"/></day>
		</a>
		<haxe_doc>A typedef that matches the date parameter `Os.time()` will accept.</haxe_doc>
	</typedef>
	<typedef path="lua.DateType" params="" file="C:\HaxeToolkit\haxe\std/lua/Os.hx" module="lua.Os">
		<a>
			<year><x path="Int"/></year>
			<yday><x path="Int"/></yday>
			<wday><x path="Int"/></wday>
			<sec><x path="Int"/></sec>
			<month><x path="Int"/></month>
			<min><x path="Int"/></min>
			<isdst><x path="Bool"/></isdst>
			<hour><x path="Int"/></hour>
			<day><x path="Int"/></day>
		</a>
		<haxe_doc>A typedef that describes the output of `Os.date()`.</haxe_doc>
	</typedef>
	<class path="lua.OsExecute" params="" file="C:\HaxeToolkit\haxe\std/lua/Os.hx" module="lua.Os" extern="1">
		<success public="1"><x path="Bool"/></success>
		<output public="1"><c path="String"/></output>
		<status public="1"><x path="Int"/></status>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.OsSuccess" params="" file="C:\HaxeToolkit\haxe\std/lua/Os.hx" module="lua.Os" extern="1">
		<success public="1"><x path="Bool"/></success>
		<message public="1"><c path="String"/></message>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.PairTools" params="" file="C:\HaxeToolkit\haxe\std/lua/PairTools.hx">
		<copy public="1" params="A:B" set="method" line="87" static="1">
			<f a="table1">
				<c path="lua.Table">
					<c path="copy.A"/>
					<c path="copy.B"/>
				</c>
				<c path="lua.Table">
					<c path="copy.A"/>
					<c path="copy.B"/>
				</c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</copy>
		<haxe_doc>A set of utility methods for working with the Lua table extern.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="lua.Result" params="T" file="C:\HaxeToolkit\haxe\std/lua/Result.hx" extern="1">
		<result public="1"><c path="lua.Result.T"/></result>
		<message public="1"><c path="String"/></message>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<typedef path="lua.AnyTable" params="" file="C:\HaxeToolkit\haxe\std/lua/Table.hx" module="lua.Table"><c path="lua.Table">
	<d/>
	<d/>
</c></typedef>
	<class path="lua.TableTools" params="" file="C:\HaxeToolkit\haxe\std/lua/TableTools.hx" extern="1">
		<pack public="1" params="T" set="method" static="1"><f a="args">
	<t path="haxe.extern.Rest"><c path="pack.T"/></t>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="pack.T"/>
	</c>
</f></pack>
		<unpack public="1" params="Int:V" set="method" static="1"><f a="args:?min:?max">
	<c path="lua.Table">
		<c path="unpack.Int"/>
		<c path="unpack.V"/>
	</c>
	<c path="unpack.Int"/>
	<c path="unpack.Int"/>
	<d/>
</f></unpack>
		<maxn public="1" set="method" static="1"><f a="t">
	<t path="lua.AnyTable"/>
	<x path="Int"/>
</f></maxn>
		<haxe_doc>This library is an extern for a polyfill library of common lua table
    methods.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_hx_table"</e></m>
		</meta>
	</class>
	<class path="lua.Thread" params="" file="C:\HaxeToolkit\haxe\std/lua/Thread.hx">
		<haxe_doc>The sole purpose of this extern is to provide a concrete type for
	basic reflection purposes.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="lua.Time" params="" file="C:\HaxeToolkit\haxe\std/lua/Time.hx"><x path="Float"/></typedef>
	<class path="lua.lib.luautf8.Utf8" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luautf8/Utf8.hx" extern="1">
		<len public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Receives a string and returns its length. The empty string `""` has
		length `0`. Embedded zeros are counted, so `"a\000bc\000"` has length `5`.</haxe_doc>
		</len>
		<char public="1" set="method" static="1">
			<f a="codes">
				<t path="haxe.extern.Rest"><x path="Int"/></t>
				<c path="String"/>
			</f>
			<haxe_doc>Receives zero or more integers. Returns a string with length equal to the
		number of arguments, in which each character has the internal numerical
		code equal to its corresponding argument.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</char>
		<sub public="1" set="method" static="1">
			<f a="str:start:?end">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.lib.luautf8.StringSub"/>
			</f>
			<haxe_doc>Returns the substring of `str` that starts at `start` and continues until `end`;
		`start` and `end` can be negative. If `end` is absent, then it is assumed to be
		equal to `-1` (which is the same as the string length).
		In particular, the call `sub(str,1,end)` returns a prefix of `str`
		with length `end`, and `sub(str, -end)` returns a suffix of `str` with
		length `start`.</haxe_doc>
		</sub>
		<find public="1" set="method" static="1">
			<f a="str:target:?start:?plain">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="lua.lib.luautf8.StringFind"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string `str`.
		If it finds a match, then `find` returns the indices of `str` where this
		occurrence starts and ends.

		@param target If the target has captures, then in a successful match the
			   captured values are also returned, after the two indices.
		@param start specifies where to start the search; its default value is `1`
			   and can be negative.
		@param plain turns off the pattern matching facilities, so the function does
			   a plain "find substring" operation, with no characters in pattern
			   being considered "magic". Note that if plain is given, then `start` must be given as well.</haxe_doc>
		</find>
		<byte public="1" set="method" static="1">
			<f a="str:?index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the internal numerical codes of the characters `str[index]`.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</byte>
		<gsub public="1" set="method" static="1">
			<f a="str:pattern:replace:?n">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
			<overloads>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<x path="Void"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<c path="String"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
			</overloads>
		</gsub>
		<gmatch public="1" set="method" static="1">
			<f a="str:pattern">
				<c path="String"/>
				<c path="String"/>
				<f a=""><c path="String"/></f>
			</f>
			<haxe_doc>Returns an iterator function that, each time it is called, returns the next
		captures from pattern over string `str`. If `pattern` specifies no captures,
		then the whole match is produced in each call.</haxe_doc>
			<overloads><gmatch public="1" set="method">
	<f a="str:pattern:match:?n">
		<c path="String"/>
		<c path="String"/>
		<f a=""><c path="String"/></f>
		<x path="Int"/>
		<f a="">
			<c path="String"/>
			<x path="Void"/>
		</f>
	</f>
	<haxe_doc>Returns an iterator function that, each time it is called, returns the next
		captures from pattern over string `str`. If `pattern` specifies no captures,
		then the whole match is produced in each call.</haxe_doc>
</gmatch></overloads>
		</gmatch>
		<match public="1" set="method" static="1">
			<f a="str:pattern:?n">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string s. If it finds one,
		then match returns the captures from the pattern; otherwise it returns `null`.
		If pattern specifies no captures, then the whole match is returned.
		The optional argument `n` specifies where to start the search;
		its default value is `1` and can be negative.</haxe_doc>
		</match>
		<upper public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all lowercase
		letters changed to uppercase. All other characters are left unchanged.
		The definition of what a lowercase letter is depends on the current locale.</haxe_doc>
		</upper>
		<lower public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all uppercase
		letters changed to lowercase. All other characters are left unchanged.
		The definition of what an uppercase letter is depends on the current locale.</haxe_doc>
		</lower>
		<codes public="1" set="method" static="1"><f a="str">
	<c path="String"/>
	<f a=":">
		<c path="String"/>
		<x path="Int"/>
		<c path="lua.lib.luautf8.StringCodePoint"/>
	</f>
</f></codes>
		<haxe_doc>These are all externs for the lua-utf8 library, which functions
	as an additional set of string tools.

	Note that all relevant indexes are "1" based.</haxe_doc>
		<meta><m n=":luaRequire"><e>"lua-utf8"</e></m></meta>
	</class>
	<class path="lua.lib.luautf8.StringFind" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luautf8/Utf8.hx" module="lua.lib.luautf8.Utf8" extern="1">
		<begin public="1"><x path="Int"/></begin>
		<end public="1"><x path="Int"/></end>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luautf8.StringSub" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luautf8/Utf8.hx" module="lua.lib.luautf8.Utf8" extern="1">
		<match public="1"><c path="String"/></match>
		<count public="1"><x path="Int"/></count>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luautf8.StringCodePoint" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luautf8/Utf8.hx" module="lua.lib.luautf8.Utf8" extern="1">
		<position public="1"><x path="Int"/></position>
		<codepoint public="1"><x path="Int"/></codepoint>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luv.Handle" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Handle.hx" extern="1">
		<is_active public="1" set="method"><f a=""><x path="Bool"/></f></is_active>
		<is_closing public="1" set="method"><f a=""><x path="Bool"/></f></is_closing>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<ref public="1" set="method"><f a=""><x path="Void"/></f></ref>
		<unref public="1" set="method"><f a=""><x path="Void"/></f></unref>
		<has_ref public="1" set="method"><f a=""><x path="Bool"/></f></has_ref>
		<send_buffer_size public="1" set="method"><f a="size">
	<x path="Int"/>
	<x path="Int"/>
</f></send_buffer_size>
		<recv_buffer_size public="1" set="method"><f a="size">
	<x path="Int"/>
	<x path="Int"/>
</f></recv_buffer_size>
		<fileno public="1" set="method"><f a=""><x path="Int"/></f></fileno>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Loop" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Loop.hx" extern="1">
		<loop_close public="1" set="method" static="1"><f a=""><x path="Bool"/></f></loop_close>
		<run public="1" set="method" static="1">
			<f a="?mode">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Runs the event loop of libuv.

		Haxe compiler automatically inserts a call to this function at the end of user's code if needed.</haxe_doc>
		</run>
		<loop_alive public="1" set="method" static="1"><f a=""><x path="Bool"/></f></loop_alive>
		<stop public="1" set="method" static="1"><f a=""><x path="Void"/></f></stop>
		<backend_fd public="1" set="method" static="1"><f a=""><x path="Int"/></f></backend_fd>
		<backend_timeout public="1" set="method" static="1"><f a=""><x path="Int"/></f></backend_timeout>
		<now public="1" set="method" static="1"><f a=""><x path="Int"/></f></now>
		<update_time public="1" set="method" static="1"><f a=""><x path="Void"/></f></update_time>
		<walk public="1" set="method" static="1"><f a="cb">
	<f a="">
		<c path="lua.lib.luv.Handle"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></walk>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Misc" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Misc.hx" extern="1">
		<chdir public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></chdir>
		<cpu_info public="1" set="method" static="1"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<t path="lua.lib.luv.CpuInfo"/>
</c></f></cpu_info>
		<cwd public="1" set="method" static="1"><f a=""><c path="String"/></f></cwd>
		<exepath public="1" set="method" static="1"><f a=""><c path="String"/></f></exepath>
		<get_process_title public="1" set="method" static="1"><f a=""><c path="String"/></f></get_process_title>
		<get_total_memory public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_total_memory>
		<get_free_memory public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_free_memory>
		<getpid public="1" set="method" static="1"><f a=""><x path="Int"/></f></getpid>
		<getrusage public="1" set="method" static="1"><f a=""><t path="lua.lib.luv.ResourceUsage"/></f></getrusage>
		<guess_handle public="1" set="method" static="1"><f a="handle">
	<x path="Int"/>
	<c path="String"/>
</f></guess_handle>
		<hrtime public="1" set="method" static="1"><f a=""><x path="Float"/></f></hrtime>
		<gettimeofday public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.TimeOfDay"/></f></gettimeofday>
		<interface_addresses public="1" set="method" static="1"><f a=""><d/></f></interface_addresses>
		<loadavg public="1" set="method" static="1"><f a=""><x path="Float"/></f></loadavg>
		<resident_set_memory public="1" set="method" static="1"><f a=""><x path="Int"/></f></resident_set_memory>
		<set_process_title public="1" set="method" static="1"><f a="title">
	<c path="String"/>
	<x path="Bool"/>
</f></set_process_title>
		<uptime public="1" set="method" static="1"><f a=""><x path="Int"/></f></uptime>
		<version public="1" set="method" static="1"><f a=""><x path="Int"/></f></version>
		<version_string public="1" set="method" static="1"><f a=""><c path="String"/></f></version_string>
		<getuid public="1" set="method" static="1"><f a=""><x path="Int"/></f></getuid>
		<setuid public="1" set="method" static="1"><f a="from:to">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></setuid>
		<getgid public="1" set="method" static="1"><f a=""><x path="Int"/></f></getgid>
		<setgid public="1" set="method" static="1"><f a="from:to">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setgid>
		<print_all_handles public="1" set="method" static="1"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></f></print_all_handles>
		<print_active_handles public="1" set="method" static="1"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></f></print_active_handles>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.CpuInfo" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc"><a>
	<times><t path="lua.lib.luv.CpuTimes"/></times>
	<speed><x path="Int"/></speed>
	<model><c path="String"/></model>
</a></typedef>
	<typedef path="lua.lib.luv.CpuTimes" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc"><a>
	<user><x path="Int"/></user>
	<sys><x path="Int"/></sys>
	<irq><x path="Int"/></irq>
	<idle><x path="Int"/></idle>
</a></typedef>
	<typedef path="lua.lib.luv.ResourceUsage" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc"><a>
	<utime><t path="lua.lib.luv.MicroTimeStamp"/></utime>
	<stime><t path="lua.lib.luv.MicroTimeStamp"/></stime>
	<oublock><x path="Int"/></oublock>
	<nvcsw><x path="Int"/></nvcsw>
	<nswap><x path="Int"/></nswap>
	<nsignals><x path="Int"/></nsignals>
	<nivcsw><x path="Int"/></nivcsw>
	<msgsnd><x path="Int"/></msgsnd>
	<msgrcv><x path="Int"/></msgrcv>
	<minflt><x path="Int"/></minflt>
	<maxrss><x path="Int"/></maxrss>
	<majflt><x path="Int"/></majflt>
	<ixrss><x path="Int"/></ixrss>
	<isrss><x path="Int"/></isrss>
	<inblock><x path="Int"/></inblock>
	<idrss><x path="Int"/></idrss>
</a></typedef>
	<typedef path="lua.lib.luv.MicroTimeStamp" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc"><a>
	<usec><x path="Int"/></usec>
	<sec><x path="Int"/></sec>
</a></typedef>
	<class path="lua.lib.luv.TimeOfDay" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc" extern="1">
		<seconds public="1"><x path="Int"/></seconds>
		<microseconds public="1"><x path="Int"/></microseconds>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luv.Os" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Os.hx" extern="1">
		<homedir public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"os_homedir"</e></m></meta>
		</homedir>
		<tmpdir public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"os_tmpdir"</e></m></meta>
		</tmpdir>
		<get_passwd public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"os_get_passwd"</e></m></meta>
		</get_passwd>
		<getenv public="1" set="method" static="1">
			<f a="env">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"os_getenv"</e></m></meta>
		</getenv>
		<setenv public="1" set="method" static="1">
			<f a="env:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"os_setenv"</e></m></meta>
		</setenv>
		<unsetenv public="1" set="method" static="1">
			<f a="env">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"os_unsetenv"</e></m></meta>
		</unsetenv>
		<gethostname public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"os_gethostname"</e></m></meta>
		</gethostname>
		<environ public="1" set="method" static="1">
			<f a=""><c path="lua.Table">
	<c path="String"/>
	<c path="String"/>
</c></f>
			<meta><m n=":native"><e>"os_environ"</e></m></meta>
		</environ>
		<uname public="1" set="method" static="1">
			<f a=""><t path="lua.lib.luv.Uname"/></f>
			<meta><m n=":native"><e>"os_uname"</e></m></meta>
		</uname>
		<getpid public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"os_getpid"</e></m></meta>
		</getpid>
		<getppid public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"os_getppid"</e></m></meta>
		</getppid>
		<getpriority public="1" set="method" static="1">
			<f a="pid">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"os_getpriority"</e></m></meta>
		</getpriority>
		<setpriority public="1" set="method" static="1">
			<f a="pid:priority">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"os_setpriority"</e></m></meta>
		</setpriority>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.Uname" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Os.hx" module="lua.lib.luv.Os"><a>
	<version><c path="String"/></version>
	<sysname><c path="String"/></sysname>
	<release><c path="String"/></release>
	<machine><c path="String"/></machine>
</a></typedef>
	<class path="lua.lib.luv.Stream" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Stream.hx" extern="1">
		<extends path="lua.lib.luv.Handle"/>
		<shutdown public="1" set="method"><f a="?cb">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
</f></shutdown>
		<listen public="1" set="method"><f a="backlog:cb">
	<x path="Int"/>
	<f a=":">
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></listen>
		<accept public="1" set="method"><f a="client_stream">
	<c path="lua.lib.luv.Stream"/>
	<x path="Int"/>
</f></accept>
		<read_start public="1" set="method"><f a="cb">
	<f a=":">
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></read_start>
		<read_stop public="1" set="method"><f a=""><x path="Int"/></f></read_stop>
		<write public="1" set="method"><f a="data:?cb">
	<t path="lua.lib.luv.StreamData"/>
	<f a=":">
		<c path="String"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></write>
		<write2 public="1" set="method"><f a="data:send_handle:cb">
	<t path="lua.lib.luv.StreamData"/>
	<c path="lua.lib.luv.net.Tcp"/>
	<f a=":">
		<c path="String"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></write2>
		<try_write public="1" set="method"><f a="data">
	<t path="lua.lib.luv.StreamData"/>
	<x path="Int"/>
</f></try_write>
		<is_readable public="1" set="method"><f a=""><x path="Bool"/></f></is_readable>
		<is_writable public="1" set="method"><f a=""><x path="Bool"/></f></is_writable>
		<set_blocking public="1" set="method"><f a="blocking">
	<x path="Bool"/>
	<x path="Int"/>
</f></set_blocking>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Pipe" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Pipe.hx" extern="1">
		<extends path="lua.lib.luv.Stream"/>
		<new_pipe public="1" set="method" static="1"><f a="ipc">
	<x path="Bool"/>
	<c path="lua.lib.luv.Pipe"/>
</f></new_pipe>
		<open public="1" set="method"><f a="file">
	<x path="haxe.extern.EitherType">
		<c path="lua.FileHandle"/>
		<c path="lua.lib.luv.Handle"/>
	</x>
	<c path="lua.lib.luv.Pipe"/>
</f></open>
		<bind public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="lua.lib.luv.Pipe"/>
</f></bind>
		<connect public="1" set="method"><f a="name:cb">
	<c path="String"/>
	<f a=":">
		<c path="String"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></connect>
		<getsockname public="1" set="method"><f a=""><c path="String"/></f></getsockname>
		<pending_instances public="1" set="method"><f a="count">
	<x path="Int"/>
	<x path="Int"/>
</f></pending_instances>
		<pending_count public="1" set="method"><f a=""><x path="Int"/></f></pending_count>
		<pending_type public="1" set="method"><f a=""><x path="Int"/></f></pending_type>
		<new public="1" set="method">
			<f a="ipc">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"new_pipe"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Process" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Process.hx" extern="1">
		<extends path="lua.lib.luv.Handle"/>
		<disable_stdio_inheritance public="1" set="method" static="1"><f a=""><x path="Void"/></f></disable_stdio_inheritance>
		<spawn public="1" set="method" static="1"><f a="path:options:cb">
	<c path="String"/>
	<d/>
	<f a=":">
		<x path="Int"/>
		<c path="lua.lib.luv.Signal"/>
		<x path="Void"/>
	</f>
	<c path="lua.lib.luv.LuvSpawn"/>
</f></spawn>
		<kill public="1" set="method"><f a="sig">
	<c path="String"/>
	<x path="Int"/>
</f></kill>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.ProcessOptions" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Process.hx" module="lua.lib.luv.Process"><a>
	<stdio><c path="lua.Table">
	<x path="Int"/>
	<c path="lua.lib.luv.Pipe"/>
</c></stdio>
	<args><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></args>
</a></typedef>
	<class path="lua.lib.luv.LuvSpawn" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Process.hx" module="lua.lib.luv.Process" extern="1">
		<handle public="1"><c path="lua.lib.luv.Process"/></handle>
		<pid public="1"><x path="Int"/></pid>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luv.Request" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Request.hx" extern="1">
		<cancel public="1" set="method"><f a=""><x path="Bool"/></f></cancel>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Signal" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Signal.hx" extern="1">
		<extends path="lua.lib.luv.Handle"/>
		<new_signal public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.Signal"/></f></new_signal>
		<start public="1" set="method"><f a="sigtype:?cb">
	<x path="haxe.extern.EitherType">
		<x path="Int"/>
		<c path="String"/>
	</x>
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
</f></start>
		<stop public="1" set="method"><f a=""><x path="Int"/></f></stop>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"new_signal"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.StreamData" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Stream.hx" module="lua.lib.luv.Stream"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</x></typedef>
	<class path="lua.lib.luv.Thread" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Thread.hx" extern="1">
		<new_thread public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.Timer"/></f></new_thread>
		<self public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.Thread"/></f></self>
		<sleep public="1" set="method" static="1"><f a="msec">
	<x path="Int"/>
	<x path="Void"/>
</f></sleep>
		<equal public="1" set="method"><f a="t">
	<c path="lua.lib.luv.Thread"/>
	<x path="Bool"/>
</f></equal>
		<join public="1" set="method"><f a="t">
	<c path="lua.lib.luv.Thread"/>
	<x path="Bool"/>
</f></join>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"new_thread"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Timer" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/Timer.hx" extern="1">
		<extends path="lua.lib.luv.Handle"/>
		<new_timer public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.Timer"/></f></new_timer>
		<start public="1" set="method"><f a="timeout:repeat:cb">
	<x path="Int"/>
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
</f></start>
		<stop public="1" set="method"><f a=""><x path="Int"/></f></stop>
		<again public="1" set="method"><f a=""><x path="Int"/></f></again>
		<set_repeat public="1" set="method"><f a="repeat">
	<x path="Int"/>
	<x path="Void"/>
</f></set_repeat>
		<get_repeat public="1" set="method"><f a=""><x path="Int"/></f></get_repeat>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"new_timer"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.fs.FileDescriptor" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/fs/FileDescriptor.hx"><x path="Int"/></typedef>
	<class path="lua.lib.luv.fs.FileSystem" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/fs/FileSystem.hx" extern="1">
		<constants final="1" public="1" set="null" static="1"><c path="lua.Table">
	<c path="String"/>
	<x path="Int"/>
</c></constants>
		<close public="1" set="method" static="1">
			<f a="file">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_close"</e></m></meta>
			<overloads><fs_close public="1" set="method">
	<f a="file:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_close"</e></m></meta>
</fs_close></overloads>
		</close>
		<open public="1" set="method" static="1">
			<f a="path:flags:mode">
				<c path="String"/>
				<x path="lua.lib.luv.fs.Open"/>
				<x path="Int"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.FileDescriptor"/></c>
			</f>
			<meta><m n=":native"><e>"fs_open"</e></m></meta>
			<overloads>
				<fs_open public="1" set="method">
					<f a="path:flags:mode">
						<c path="String"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="lua.Result"><t path="lua.lib.luv.fs.FileDescriptor"/></c>
					</f>
					<meta><m n=":native"><e>"fs_open"</e></m></meta>
				</fs_open>
				<fs_open public="1" set="method">
					<f a="path:flags:mode:?cb">
						<c path="String"/>
						<x path="Int"/>
						<x path="Int"/>
						<f a=":">
							<c path="String"/>
							<t path="lua.lib.luv.fs.FileDescriptor"/>
							<x path="Void"/>
						</f>
						<c path="lua.lib.luv.Request"/>
					</f>
					<meta><m n=":native"><e>"fs_open"</e></m></meta>
				</fs_open>
				<fs_open public="1" set="method">
					<f a="path:flags:mode:?cb">
						<c path="String"/>
						<x path="lua.lib.luv.fs.Open"/>
						<x path="Int"/>
						<f a=":">
							<c path="String"/>
							<t path="lua.lib.luv.fs.FileDescriptor"/>
							<x path="Void"/>
						</f>
						<c path="lua.lib.luv.Request"/>
					</f>
					<meta><m n=":native"><e>"fs_open"</e></m></meta>
				</fs_open>
			</overloads>
		</open>
		<read public="1" set="method" static="1">
			<f a="file:len:offset">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.Result"><c path="String"/></c>
			</f>
			<meta><m n=":native"><e>"fs_read"</e></m></meta>
			<overloads><fs_read public="1" set="method">
	<f a="file:len:offset:?cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_read"</e></m></meta>
</fs_read></overloads>
		</read>
		<unlink public="1" set="method" static="1">
			<f a="file:content">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_unlink"</e></m></meta>
			<overloads><fs_unlink public="1" set="method">
	<f a="file:?cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_unlink"</e></m></meta>
</fs_unlink></overloads>
		</unlink>
		<write public="1" set="method" static="1">
			<f a="file:content:offset">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Int"/></c>
			</f>
			<meta><m n=":native"><e>"fs_write"</e></m></meta>
			<overloads><fs_write public="1" set="method">
	<f a="file:content:offset:?cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<x path="Int"/>
	</f>
	<meta><m n=":native"><e>"fs_write"</e></m></meta>
</fs_write></overloads>
		</write>
		<mkdir public="1" set="method" static="1">
			<f a="path:mode">
				<c path="String"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_mkdir"</e></m></meta>
			<overloads><fs_mkdir public="1" set="method">
	<f a="path:mode:cb">
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_mkdir"</e></m></meta>
</fs_mkdir></overloads>
		</mkdir>
		<mkdtemp public="1" set="method" static="1">
			<f a="template">
				<c path="String"/>
				<c path="lua.Result"><c path="String"/></c>
			</f>
			<meta><m n=":native"><e>"fs_mkdtemp"</e></m></meta>
			<overloads><fs_mkdtemp public="1" set="method">
	<f a="template:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_mkdtemp"</e></m></meta>
</fs_mkdtemp></overloads>
		</mkdtemp>
		<mkstemp public="1" set="method" static="1">
			<f a="template">
				<c path="String"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.FileDescriptor"/></c>
			</f>
			<meta><m n=":native"><e>"fs_mkstemp"</e></m></meta>
			<overloads><fs_mkstemp public="1" set="method">
	<f a="template:cb">
		<c path="String"/>
		<f a="::">
			<c path="String"/>
			<t path="lua.lib.luv.fs.FileDescriptor"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_mkstemp"</e></m></meta>
</fs_mkstemp></overloads>
		</mkstemp>
		<rmdir public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.Result"><x path="Int"/></c>
			</f>
			<meta><m n=":native"><e>"fs_rmdir"</e></m></meta>
			<overloads><fs_rmdir public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_rmdir"</e></m></meta>
</fs_rmdir></overloads>
		</rmdir>
		<scandir public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.lib.luv.fs.ScanDirMarker"/>
			</f>
			<meta><m n=":native"><e>"fs_scandir"</e></m></meta>
			<overloads><fs_scandir public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_scandir"</e></m></meta>
</fs_scandir></overloads>
		</scandir>
		<scandir_next public="1" set="method" static="1">
			<f a="scandir">
				<c path="lua.lib.luv.fs.ScanDirMarker"/>
				<c path="lua.lib.luv.fs.ScandirNext"/>
			</f>
			<meta><m n=":native"><e>"fs_scandir_next"</e></m></meta>
		</scandir_next>
		<stat public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.Stat"/></c>
			</f>
			<meta><m n=":native"><e>"fs_stat"</e></m></meta>
			<overloads><fs_stat public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<t path="lua.lib.luv.fs.Stat"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_stat"</e></m></meta>
</fs_stat></overloads>
		</stat>
		<fstat public="1" set="method" static="1">
			<f a="descriptor">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.Stat"/></c>
			</f>
			<meta><m n=":native"><e>"fs_fstat"</e></m></meta>
			<overloads><fs_fstat public="1" set="method">
	<f a="descriptor:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<t path="lua.lib.luv.fs.Stat"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fstat"</e></m></meta>
</fs_fstat></overloads>
		</fstat>
		<lstat public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.Stat"/></c>
			</f>
			<meta><m n=":native"><e>"fs_lstat"</e></m></meta>
			<overloads><fs_lstat public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<t path="lua.lib.luv.fs.Stat"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_lstat"</e></m></meta>
</fs_lstat></overloads>
		</lstat>
		<rename public="1" set="method" static="1">
			<f a="path:newpath">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_rename"</e></m></meta>
			<overloads><fs_rename public="1" set="method">
	<f a="path:newpath:cb">
		<c path="String"/>
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_rename"</e></m></meta>
</fs_rename></overloads>
		</rename>
		<fsync public="1" set="method" static="1">
			<f a="descriptor">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_fsync"</e></m></meta>
			<overloads><fs_fsync public="1" set="method">
	<f a="descriptor:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fsync"</e></m></meta>
</fs_fsync></overloads>
		</fsync>
		<fdatasync public="1" set="method" static="1">
			<f a="descriptor">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_fdatasync"</e></m></meta>
			<overloads><fs_fdatasync public="1" set="method">
	<f a="descriptor:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fdatasync"</e></m></meta>
</fs_fdatasync></overloads>
		</fdatasync>
		<ftruncate public="1" set="method" static="1">
			<f a="descriptor:offset">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_ftruncate"</e></m></meta>
			<overloads><fs_ftruncate public="1" set="method">
	<f a="descriptor:offset:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_ftruncate"</e></m></meta>
</fs_ftruncate></overloads>
		</ftruncate>
		<sendfile public="1" set="method" static="1">
			<f a="fin:fout">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><x path="Int"/></c>
			</f>
			<meta><m n=":native"><e>"fs_sendfile"</e></m></meta>
			<overloads><fs_sendfile public="1" set="method">
	<f a="fin:fout:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_sendfile"</e></m></meta>
</fs_sendfile></overloads>
		</sendfile>
		<access public="1" set="method" static="1">
			<f a="path:mode">
				<c path="String"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_access"</e></m></meta>
			<overloads><fs_access public="1" set="method">
	<f a="path:mode:cb">
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_access"</e></m></meta>
</fs_access></overloads>
		</access>
		<chmod public="1" set="method" static="1">
			<f a="path:mode">
				<c path="String"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_chmod"</e></m></meta>
			<overloads><fs_chmod public="1" set="method">
	<f a="path:mode:cb">
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_chmod"</e></m></meta>
</fs_chmod></overloads>
		</chmod>
		<fchmod public="1" set="method" static="1">
			<f a="descriptor:mode">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_fchmod"</e></m></meta>
			<overloads><fs_fchmod public="1" set="method">
	<f a="descriptor:mode:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fchmod"</e></m></meta>
</fs_fchmod></overloads>
		</fchmod>
		<futime public="1" set="method" static="1">
			<f a="descriptor:actime:modtime">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_futime"</e></m></meta>
			<overloads><fs_futime public="1" set="method">
	<f a="descriptor:actime:modtime:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_futime"</e></m></meta>
</fs_futime></overloads>
		</futime>
		<utime public="1" set="method" static="1">
			<f a="path:actime:modtime">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_utime"</e></m></meta>
			<overloads><fs_utime public="1" set="method">
	<f a="path:actime:modtime:cb">
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_utime"</e></m></meta>
</fs_utime></overloads>
		</utime>
		<link public="1" set="method" static="1">
			<f a="oldpath:newpath">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_link"</e></m></meta>
			<overloads><fs_link public="1" set="method">
	<f a="oldpath:newpath:cb">
		<c path="String"/>
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_link"</e></m></meta>
</fs_link></overloads>
		</link>
		<symlink public="1" set="method" static="1">
			<f a="oldpath:newpath:flags">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_symlink"</e></m></meta>
			<overloads><fs_symlink public="1" set="method">
	<f a="oldpath:newpath:flags:cb">
		<c path="String"/>
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_symlink"</e></m></meta>
</fs_symlink></overloads>
		</symlink>
		<readlink public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"fs_readlink"</e></m></meta>
			<overloads><fs_readlink public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_readlink"</e></m></meta>
</fs_readlink></overloads>
		</readlink>
		<realpath public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"fs_realpath"</e></m></meta>
			<overloads><fs_realpath public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_realpath"</e></m></meta>
</fs_realpath></overloads>
		</realpath>
		<chown public="1" set="method" static="1">
			<f a="path:uid:gid">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_chown"</e></m></meta>
			<overloads><fs_chown public="1" set="method">
	<f a="path:uid:gid:cb">
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_chown"</e></m></meta>
</fs_chown></overloads>
		</chown>
		<fchown public="1" set="method" static="1">
			<f a="descriptor:uid:gid">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_fchown"</e></m></meta>
			<overloads><fs_fchown public="1" set="method">
	<f a="descriptor:uid:gid:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fchown"</e></m></meta>
</fs_fchown></overloads>
		</fchown>
		<lchown public="1" set="method" static="1">
			<f a="descriptor:uid:gid">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_lchown"</e></m></meta>
			<haxe_doc>Not available on windows</haxe_doc>
			<overloads><fs_lchown public="1" set="method">
	<f a="descriptor:uid:gid:cb">
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_lchown"</e></m></meta>
	<haxe_doc>Not available on windows</haxe_doc>
</fs_lchown></overloads>
		</lchown>
		<copyfile public="1" set="method" static="1">
			<f a="path:newPath:?flags">
				<c path="String"/>
				<c path="String"/>
				<x path="Null"><t path="lua.lib.luv.fs.CopyFlags"/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_copyfile"</e></m></meta>
			<overloads><fs_copyfile public="1" set="method">
	<f a="path:newPath:flags:cb">
		<c path="String"/>
		<c path="String"/>
		<x path="Null"><t path="lua.lib.luv.fs.CopyFlags"/></x>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_copyfile"</e></m></meta>
</fs_copyfile></overloads>
		</copyfile>
		<statfs public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<t path="lua.lib.luv.fs.StatFs"/>
			</f>
			<meta><m n=":native"><e>"fs_statfs"</e></m></meta>
			<overloads><fs_statfs public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<t path="lua.lib.luv.fs.StatFs"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_statfs"</e></m></meta>
</fs_statfs></overloads>
		</statfs>
		<opendir public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.lib.luv.Handle"/>
			</f>
			<meta><m n=":native"><e>"fs_opendir"</e></m></meta>
			<overloads><fs_opendir public="1" set="method">
	<f a="path:cb:?entries">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<c path="lua.lib.luv.Handle"/>
			<x path="Void"/>
		</f>
		<x path="Int"/>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_opendir"</e></m></meta>
</fs_opendir></overloads>
		</opendir>
		<readdir public="1" set="method" static="1">
			<f a="path">
				<c path="lua.lib.luv.Handle"/>
				<c path="lua.Table">
					<x path="Int"/>
					<t path="lua.lib.luv.fs.NameType"/>
				</c>
			</f>
			<meta><m n=":native"><e>"fs_readdir"</e></m></meta>
			<overloads><fs_readdir public="1" set="method">
	<f a="dir:cb">
		<c path="lua.lib.luv.Handle"/>
		<f a=":">
			<c path="String"/>
			<c path="lua.Table">
				<x path="Int"/>
				<t path="lua.lib.luv.fs.NameType"/>
			</c>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_readdir"</e></m></meta>
</fs_readdir></overloads>
		</readdir>
		<closedir public="1" set="method" static="1">
			<f a="dir">
				<c path="lua.lib.luv.Handle"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_closedir"</e></m></meta>
			<overloads><fs_closedir public="1" set="method">
	<f a="dir:cb">
		<c path="lua.lib.luv.Handle"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_closedir"</e></m></meta>
</fs_closedir></overloads>
		</closedir>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.fs.ScanDirMarker" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem" extern="1"/>
	<class path="lua.lib.luv.fs.ScandirNext" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem" extern="1">
		<name public="1"><c path="String"/></name>
		<type public="1"><c path="String"/></type>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<typedef path="lua.lib.luv.fs.NameType" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem"><a>
	<type><c path="String"/></type>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="lua.lib.luv.fs.Stat" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem"><a>
	<uid><x path="Int"/></uid>
	<type><c path="String"/></type>
	<size><x path="Int"/></size>
	<rdev><x path="Int"/></rdev>
	<nlink><x path="Int"/></nlink>
	<mtime><t path="lua.lib.luv.fs.TimeStamp"/></mtime>
	<mode><x path="Int"/></mode>
	<ino><x path="Int"/></ino>
	<gid><x path="Int"/></gid>
	<gen><x path="Int"/></gen>
	<flags><x path="Int"/></flags>
	<dev><x path="Int"/></dev>
	<ctime><t path="lua.lib.luv.fs.TimeStamp"/></ctime>
	<blocks><x path="Int"/></blocks>
	<blksize><x path="Int"/></blksize>
	<birthtime><t path="lua.lib.luv.fs.TimeStamp"/></birthtime>
	<atime><t path="lua.lib.luv.fs.TimeStamp"/></atime>
</a></typedef>
	<typedef path="lua.lib.luv.fs.TimeStamp" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem"><a>
	<sec><x path="Int"/></sec>
	<nsec><x path="Int"/></nsec>
</a></typedef>
	<typedef path="lua.lib.luv.fs.StatFs" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem"><a>
	<type><x path="Int"/></type>
	<files><x path="Int"/></files>
	<ffree><x path="Int"/></ffree>
	<bsize><x path="Int"/></bsize>
	<blocks><x path="Int"/></blocks>
	<bfree><x path="Int"/></bfree>
	<bavail><x path="Int"/></bavail>
</a></typedef>
	<typedef path="lua.lib.luv.fs.CopyFlags" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem"><a>
	<ficlone_force>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</ficlone_force>
	<ficlone>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</ficlone>
	<excl>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</excl>
</a></typedef>
	<abstract path="lua.lib.luv.fs.AccessMode" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem">
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua.lib.luv.fs._FileSystem.AccessMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/fs/FileSystem.hx" private="1" module="lua.lib.luv.fs.FileSystem" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="lua.lib.luv.fs.Open" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/fs/Open.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua.lib.luv.fs._Open.Open_Impl_" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/fs/Open.hx" private="1" module="lua.lib.luv.fs.Open" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.lib.luv.net.Tcp" params="" file="C:\HaxeToolkit\haxe\std/lua/lib/luv/net/Tcp.hx" extern="1">
		<extends path="lua.lib.luv.Stream"/>
		<new_tcp public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.net.Tcp"/></f></new_tcp>
		<open public="1" set="method"><f a="sock">
	<x path="Int"/>
	<x path="Int"/>
</f></open>
		<nodelay public="1" set="method"><f a="enable">
	<x path="Bool"/>
	<x path="Int"/>
</f></nodelay>
		<keepalive public="1" set="method"><f a="enable:?delay">
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
</f></keepalive>
		<simultaneous_accepts public="1" set="method"><f a="enable">
	<x path="Bool"/>
	<x path="Int"/>
</f></simultaneous_accepts>
		<bind public="1" set="method"><f a="address:port">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bind>
		<getsockname public="1" set="method"><f a=""><x path="Int"/></f></getsockname>
		<getpeername public="1" set="method"><f a=""><c path="String"/></f></getpeername>
		<connect public="1" set="method"><f a="host:port:cb">
	<c path="String"/>
	<x path="Int"/>
	<f a=":">
		<c path="String"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></connect>
		<write_queue_size public="1" set="method"><f a=""><x path="Int"/></f></write_queue_size>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"new_tcp"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<abstract path="sunaba.Error" params="" file="G:\sunaba\sunaba/Error.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="sunaba._Error.Error_Impl_" params="" file="G:\sunaba\sunaba/Error.hx" private="1" module="sunaba.Error" extern="1" final="1">
	<ok public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ok>
	<failed public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</failed>
	<unavailable public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</unavailable>
	<unconfigured public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</unconfigured>
	<unauthorized public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</unauthorized>
	<parameterRangeError public="1" get="inline" set="null" expr="cast 5" line="9" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</parameterRangeError>
	<outOfMemory public="1" get="inline" set="null" expr="cast 6" line="10" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</outOfMemory>
	<fileNotFound public="1" get="inline" set="null" expr="cast 7" line="11" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fileNotFound>
	<fileBadDrive public="1" get="inline" set="null" expr="cast 8" line="12" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fileBadDrive>
	<fileBadPath public="1" get="inline" set="null" expr="cast 9" line="13" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fileBadPath>
	<fileNoPermission public="1" get="inline" set="null" expr="cast 10" line="14" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fileNoPermission>
	<fileAlreadyInUse public="1" get="inline" set="null" expr="cast 11" line="15" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fileAlreadyInUse>
	<fileCantOpen public="1" get="inline" set="null" expr="cast 12" line="16" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fileCantOpen>
	<fileCantWrite public="1" get="inline" set="null" expr="cast 13" line="17" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fileCantWrite>
	<fileCantRead public="1" get="inline" set="null" expr="cast 14" line="18" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fileCantRead>
	<fileUnrecognized public="1" get="inline" set="null" expr="cast 15" line="19" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fileUnrecognized>
	<fileCorrupt public="1" get="inline" set="null" expr="cast 16" line="20" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fileCorrupt>
	<fileMissingDependencies public="1" get="inline" set="null" expr="cast 17" line="21" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 17</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fileMissingDependencies>
	<fileEof public="1" get="inline" set="null" expr="cast 18" line="22" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 18</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fileEof>
	<cantOpen public="1" get="inline" set="null" expr="cast 19" line="23" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 19</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</cantOpen>
	<cantCreate public="1" get="inline" set="null" expr="cast 20" line="24" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 20</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</cantCreate>
	<queryFailed public="1" get="inline" set="null" expr="cast 21" line="25" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 21</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</queryFailed>
	<alreadyInUse public="1" get="inline" set="null" expr="cast 22" line="26" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 22</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</alreadyInUse>
	<locked public="1" get="inline" set="null" expr="cast 23" line="27" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 23</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</locked>
	<timeout public="1" get="inline" set="null" expr="cast 24" line="28" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 24</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</timeout>
	<cantConnect public="1" get="inline" set="null" expr="cast 25" line="29" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 25</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</cantConnect>
	<cantResolve public="1" get="inline" set="null" expr="cast 26" line="30" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 26</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</cantResolve>
	<connectionError public="1" get="inline" set="null" expr="cast 27" line="31" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 27</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</connectionError>
	<cantAcquireResource public="1" get="inline" set="null" expr="cast 28" line="32" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 28</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</cantAcquireResource>
	<cantFork public="1" get="inline" set="null" expr="cast 29" line="33" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 29</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</cantFork>
	<invalidData public="1" get="inline" set="null" expr="cast 30" line="34" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 30</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</invalidData>
	<invalidParameter public="1" get="inline" set="null" expr="cast 31" line="35" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 31</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</invalidParameter>
	<alreadyExists public="1" get="inline" set="null" expr="cast 32" line="36" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 32</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</alreadyExists>
	<doesNotExist public="1" get="inline" set="null" expr="cast 33" line="37" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 33</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</doesNotExist>
	<databaseCantRead public="1" get="inline" set="null" expr="cast 34" line="38" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 34</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</databaseCantRead>
	<databaseCantWrite public="1" get="inline" set="null" expr="cast 35" line="39" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 35</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</databaseCantWrite>
	<compilationFailed public="1" get="inline" set="null" expr="cast 36" line="40" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 36</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</compilationFailed>
	<methodNotFound public="1" get="inline" set="null" expr="cast 37" line="41" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 37</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</methodNotFound>
	<linkFailed public="1" get="inline" set="null" expr="cast 38" line="42" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 38</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</linkFailed>
	<scriptFailed public="1" get="inline" set="null" expr="cast 39" line="43" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 39</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</scriptFailed>
	<cyclicLink public="1" get="inline" set="null" expr="cast 40" line="44" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 40</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</cyclicLink>
	<invalidDeclaration public="1" get="inline" set="null" expr="cast 41" line="45" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 41</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</invalidDeclaration>
	<duplicateSymbol public="1" get="inline" set="null" expr="cast 42" line="46" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 42</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</duplicateSymbol>
	<parseError public="1" get="inline" set="null" expr="cast 43" line="47" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 43</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</parseError>
	<busy public="1" get="inline" set="null" expr="cast 44" line="48" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 44</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</busy>
	<skip public="1" get="inline" set="null" expr="cast 45" line="49" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 45</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</skip>
	<help public="1" get="inline" set="null" expr="cast 46" line="50" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 46</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</help>
	<bug public="1" get="inline" set="null" expr="cast 47" line="51" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 47</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</bug>
	<printerOnFire public="1" get="inline" set="null" expr="cast 48" line="52" static="1">
		<x path="sunaba.Error"/>
		<meta>
			<m n=":value"><e>cast 48</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</printerOnFire>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="sunaba._Error.Error_Impl_" params="" file="G:\sunaba\sunaba/Error.hx" private="1" module="sunaba.Error" extern="1" final="1">
		<ok public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ok>
		<failed public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</failed>
		<unavailable public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</unavailable>
		<unconfigured public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</unconfigured>
		<unauthorized public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</unauthorized>
		<parameterRangeError public="1" get="inline" set="null" expr="cast 5" line="9" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</parameterRangeError>
		<outOfMemory public="1" get="inline" set="null" expr="cast 6" line="10" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</outOfMemory>
		<fileNotFound public="1" get="inline" set="null" expr="cast 7" line="11" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fileNotFound>
		<fileBadDrive public="1" get="inline" set="null" expr="cast 8" line="12" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fileBadDrive>
		<fileBadPath public="1" get="inline" set="null" expr="cast 9" line="13" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fileBadPath>
		<fileNoPermission public="1" get="inline" set="null" expr="cast 10" line="14" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fileNoPermission>
		<fileAlreadyInUse public="1" get="inline" set="null" expr="cast 11" line="15" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fileAlreadyInUse>
		<fileCantOpen public="1" get="inline" set="null" expr="cast 12" line="16" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fileCantOpen>
		<fileCantWrite public="1" get="inline" set="null" expr="cast 13" line="17" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fileCantWrite>
		<fileCantRead public="1" get="inline" set="null" expr="cast 14" line="18" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fileCantRead>
		<fileUnrecognized public="1" get="inline" set="null" expr="cast 15" line="19" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fileUnrecognized>
		<fileCorrupt public="1" get="inline" set="null" expr="cast 16" line="20" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fileCorrupt>
		<fileMissingDependencies public="1" get="inline" set="null" expr="cast 17" line="21" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 17</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fileMissingDependencies>
		<fileEof public="1" get="inline" set="null" expr="cast 18" line="22" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 18</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fileEof>
		<cantOpen public="1" get="inline" set="null" expr="cast 19" line="23" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 19</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</cantOpen>
		<cantCreate public="1" get="inline" set="null" expr="cast 20" line="24" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 20</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</cantCreate>
		<queryFailed public="1" get="inline" set="null" expr="cast 21" line="25" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 21</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</queryFailed>
		<alreadyInUse public="1" get="inline" set="null" expr="cast 22" line="26" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 22</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</alreadyInUse>
		<locked public="1" get="inline" set="null" expr="cast 23" line="27" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 23</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</locked>
		<timeout public="1" get="inline" set="null" expr="cast 24" line="28" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 24</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</timeout>
		<cantConnect public="1" get="inline" set="null" expr="cast 25" line="29" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 25</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</cantConnect>
		<cantResolve public="1" get="inline" set="null" expr="cast 26" line="30" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 26</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</cantResolve>
		<connectionError public="1" get="inline" set="null" expr="cast 27" line="31" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 27</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</connectionError>
		<cantAcquireResource public="1" get="inline" set="null" expr="cast 28" line="32" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 28</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</cantAcquireResource>
		<cantFork public="1" get="inline" set="null" expr="cast 29" line="33" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 29</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</cantFork>
		<invalidData public="1" get="inline" set="null" expr="cast 30" line="34" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 30</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</invalidData>
		<invalidParameter public="1" get="inline" set="null" expr="cast 31" line="35" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 31</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</invalidParameter>
		<alreadyExists public="1" get="inline" set="null" expr="cast 32" line="36" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 32</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</alreadyExists>
		<doesNotExist public="1" get="inline" set="null" expr="cast 33" line="37" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 33</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</doesNotExist>
		<databaseCantRead public="1" get="inline" set="null" expr="cast 34" line="38" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 34</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</databaseCantRead>
		<databaseCantWrite public="1" get="inline" set="null" expr="cast 35" line="39" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 35</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</databaseCantWrite>
		<compilationFailed public="1" get="inline" set="null" expr="cast 36" line="40" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 36</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</compilationFailed>
		<methodNotFound public="1" get="inline" set="null" expr="cast 37" line="41" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 37</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</methodNotFound>
		<linkFailed public="1" get="inline" set="null" expr="cast 38" line="42" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 38</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</linkFailed>
		<scriptFailed public="1" get="inline" set="null" expr="cast 39" line="43" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 39</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</scriptFailed>
		<cyclicLink public="1" get="inline" set="null" expr="cast 40" line="44" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 40</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</cyclicLink>
		<invalidDeclaration public="1" get="inline" set="null" expr="cast 41" line="45" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 41</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</invalidDeclaration>
		<duplicateSymbol public="1" get="inline" set="null" expr="cast 42" line="46" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 42</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</duplicateSymbol>
		<parseError public="1" get="inline" set="null" expr="cast 43" line="47" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 43</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</parseError>
		<busy public="1" get="inline" set="null" expr="cast 44" line="48" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 44</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</busy>
		<skip public="1" get="inline" set="null" expr="cast 45" line="49" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 45</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</skip>
		<help public="1" get="inline" set="null" expr="cast 46" line="50" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 46</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</help>
		<bug public="1" get="inline" set="null" expr="cast 47" line="51" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 47</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</bug>
		<printerOnFire public="1" get="inline" set="null" expr="cast 48" line="52" static="1">
			<x path="sunaba.Error"/>
			<meta>
				<m n=":value"><e>cast 48</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</printerOnFire>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="sunaba.LayoutPreset" params="" file="G:\sunaba\sunaba/LayoutPreset.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="sunaba._LayoutPreset.LayoutPreset_Impl_" params="" file="G:\sunaba\sunaba/LayoutPreset.hx" private="1" module="sunaba.LayoutPreset" extern="1" final="1">
	<topLeft public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</topLeft>
	<topRight public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</topRight>
	<bottomLeft public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</bottomLeft>
	<bottomRight public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</bottomRight>
	<centerLeft public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</centerLeft>
	<centerTop public="1" get="inline" set="null" expr="cast 5" line="9" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</centerTop>
	<centerRight public="1" get="inline" set="null" expr="cast 6" line="10" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</centerRight>
	<centerBottom public="1" get="inline" set="null" expr="cast 7" line="11" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</centerBottom>
	<center public="1" get="inline" set="null" expr="cast 8" line="12" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</center>
	<leftWide public="1" get="inline" set="null" expr="cast 9" line="13" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</leftWide>
	<topWide public="1" get="inline" set="null" expr="cast 10" line="14" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</topWide>
	<rightWide public="1" get="inline" set="null" expr="cast 11" line="15" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</rightWide>
	<bottomWide public="1" get="inline" set="null" expr="cast 12" line="16" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</bottomWide>
	<vcenterWide public="1" get="inline" set="null" expr="cast 13" line="17" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</vcenterWide>
	<hcenterWide public="1" get="inline" set="null" expr="cast 14" line="18" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</hcenterWide>
	<fullRect public="1" get="inline" set="null" expr="cast 15" line="19" static="1">
		<x path="sunaba.LayoutPreset"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fullRect>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="sunaba._LayoutPreset.LayoutPreset_Impl_" params="" file="G:\sunaba\sunaba/LayoutPreset.hx" private="1" module="sunaba.LayoutPreset" extern="1" final="1">
		<topLeft public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</topLeft>
		<topRight public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</topRight>
		<bottomLeft public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</bottomLeft>
		<bottomRight public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</bottomRight>
		<centerLeft public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</centerLeft>
		<centerTop public="1" get="inline" set="null" expr="cast 5" line="9" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</centerTop>
		<centerRight public="1" get="inline" set="null" expr="cast 6" line="10" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</centerRight>
		<centerBottom public="1" get="inline" set="null" expr="cast 7" line="11" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</centerBottom>
		<center public="1" get="inline" set="null" expr="cast 8" line="12" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</center>
		<leftWide public="1" get="inline" set="null" expr="cast 9" line="13" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</leftWide>
		<topWide public="1" get="inline" set="null" expr="cast 10" line="14" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</topWide>
		<rightWide public="1" get="inline" set="null" expr="cast 11" line="15" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</rightWide>
		<bottomWide public="1" get="inline" set="null" expr="cast 12" line="16" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</bottomWide>
		<vcenterWide public="1" get="inline" set="null" expr="cast 13" line="17" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</vcenterWide>
		<hcenterWide public="1" get="inline" set="null" expr="cast 14" line="18" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</hcenterWide>
		<fullRect public="1" get="inline" set="null" expr="cast 15" line="19" static="1">
			<x path="sunaba.LayoutPreset"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fullRect>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="sunaba.LayoutPresetMode" params="" file="G:\sunaba\sunaba/LayoutPresetMode.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="sunaba._LayoutPresetMode.LayoutPresetMode_Impl_" params="" file="G:\sunaba\sunaba/LayoutPresetMode.hx" private="1" module="sunaba.LayoutPresetMode" extern="1" final="1">
	<minsize public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
		<x path="sunaba.LayoutPresetMode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</minsize>
	<keepWidth public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="sunaba.LayoutPresetMode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</keepWidth>
	<keepHeight public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
		<x path="sunaba.LayoutPresetMode"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</keepHeight>
	<keepSize public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="sunaba.LayoutPresetMode"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</keepSize>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="sunaba._LayoutPresetMode.LayoutPresetMode_Impl_" params="" file="G:\sunaba\sunaba/LayoutPresetMode.hx" private="1" module="sunaba.LayoutPresetMode" extern="1" final="1">
		<minsize public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
			<x path="sunaba.LayoutPresetMode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</minsize>
		<keepWidth public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="sunaba.LayoutPresetMode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</keepWidth>
		<keepHeight public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
			<x path="sunaba.LayoutPresetMode"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</keepHeight>
		<keepSize public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="sunaba.LayoutPresetMode"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</keepSize>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="sunaba.SizeFlags" params="" file="G:\sunaba\sunaba/SizeFlags.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="sunaba._SizeFlags.SizeFlags_Impl_" params="" file="G:\sunaba\sunaba/SizeFlags.hx" private="1" module="sunaba.SizeFlags" extern="1" final="1">
	<shrinkBegin public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
		<x path="sunaba.SizeFlags"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</shrinkBegin>
	<fill public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="sunaba.SizeFlags"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</fill>
	<expand public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
		<x path="sunaba.SizeFlags"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</expand>
	<expandFill public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="sunaba.SizeFlags"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</expandFill>
	<shrinkCenter public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
		<x path="sunaba.SizeFlags"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</shrinkCenter>
	<shrinkEnd public="1" get="inline" set="null" expr="cast 8" line="9" static="1">
		<x path="sunaba.SizeFlags"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</shrinkEnd>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="sunaba._SizeFlags.SizeFlags_Impl_" params="" file="G:\sunaba\sunaba/SizeFlags.hx" private="1" module="sunaba.SizeFlags" extern="1" final="1">
		<shrinkBegin public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
			<x path="sunaba.SizeFlags"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</shrinkBegin>
		<fill public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="sunaba.SizeFlags"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</fill>
		<expand public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
			<x path="sunaba.SizeFlags"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</expand>
		<expandFill public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="sunaba.SizeFlags"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</expandFill>
		<shrinkCenter public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
			<x path="sunaba.SizeFlags"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</shrinkCenter>
		<shrinkEnd public="1" get="inline" set="null" expr="cast 8" line="9" static="1">
			<x path="sunaba.SizeFlags"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</shrinkEnd>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="sunaba.core.ArrayList" params="" file="G:\sunaba\sunaba/core/ArrayList.hx" extern="1">
		<append public="1" set="method"><f a="value">
	<x path="sunaba.core.Variant"/>
	<x path="Void"/>
</f></append>
		<appendArray public="1" set="method"><f a="array">
	<c path="sunaba.core.ArrayList"/>
	<x path="Void"/>
</f></appendArray>
		<assign public="1" set="method"><f a="array">
	<c path="sunaba.core.ArrayList"/>
	<x path="Void"/>
</f></assign>
		<back public="1" set="method"><f a=""><x path="sunaba.core.Variant"/></f></back>
		<bsearch public="1" set="method">
			<f a="value:?before" v=":true">
				<x path="sunaba.core.Variant"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ before : true }</e></m></meta>
		</bsearch>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<count public="1" set="method"><f a=""><x path="Int"/></f></count>
		<duplicate public="1" set="method">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="sunaba.core.ArrayList"/>
			</f>
			<meta><m n=":value"><e>{ deep : false }</e></m></meta>
		</duplicate>
		<erase public="1" set="method"><f a="value">
	<x path="sunaba.core.Variant"/>
	<x path="Void"/>
</f></erase>
		<fill public="1" set="method"><f a="value">
	<x path="sunaba.core.Variant"/>
	<x path="Void"/>
</f></fill>
		<front public="1" set="method"><f a=""><x path="sunaba.core.Variant"/></f></front>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="sunaba.core.Variant"/>
</f></get>
		<has public="1" set="method"><f a="value">
	<x path="sunaba.core.Variant"/>
	<x path="Bool"/>
</f></has>
		<hash public="1" set="method"><f a=""><x path="Int"/></f></hash>
		<insert public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="sunaba.core.Variant"/>
	<x path="Void"/>
</f></insert>
		<isEmpty public="1" set="method"><f a=""><x path="Bool"/></f></isEmpty>
		<isReadOnly public="1" set="method"><f a=""><x path="Bool"/></f></isReadOnly>
		<makeReadOnly public="1" set="method"><f a=""><x path="Void"/></f></makeReadOnly>
		<max public="1" set="method"><f a=""><x path="sunaba.core.Variant"/></f></max>
		<min public="1" set="method"><f a=""><x path="sunaba.core.Variant"/></f></min>
		<pickRandom public="1" set="method"><f a=""><x path="sunaba.core.Variant"/></f></pickRandom>
		<popAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="sunaba.core.Variant"/>
</f></popAt>
		<popBack public="1" set="method"><f a=""><x path="sunaba.core.Variant"/></f></popBack>
		<popFront public="1" set="method"><f a=""><x path="sunaba.core.Variant"/></f></popFront>
		<pushBack public="1" set="method"><f a="value">
	<x path="sunaba.core.Variant"/>
	<x path="Void"/>
</f></pushBack>
		<pushFront public="1" set="method"><f a="value">
	<x path="sunaba.core.Variant"/>
	<x path="Void"/>
</f></pushFront>
		<removeAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></removeAt>
		<resize public="1" set="method"><f a="size">
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<reverse public="1" set="method"><f a=""><x path="Void"/></f></reverse>
		<rfind public="1" set="method">
			<f a="what:?from" v=":-1">
				<x path="sunaba.core.Variant"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ from : -1 }</e></m></meta>
		</rfind>
		<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="sunaba.core.Variant"/>
	<x path="Void"/>
</f></set>
		<shuffle public="1" set="method"><f a=""><x path="Void"/></f></shuffle>
		<size public="1" set="method"><f a=""><x path="Int"/></f></size>
		<slice public="1" set="method">
			<f a="begin:end:?step:?deep" v="::1:false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="sunaba.core.ArrayList"/>
			</f>
			<meta><m n=":value"><e>{ deep : false, step : 1 }</e></m></meta>
		</slice>
		<sort public="1" set="method"><f a=""><x path="Void"/></f></sort>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"ArrayList"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.ArrayListIterator" params="" file="G:\sunaba\sunaba/core/ArrayList.hx" module="sunaba.core.ArrayList">
		<index public="1"><x path="Int"/></index>
		<array public="1"><c path="sunaba.core.ArrayList"/></array>
		<hasNext public="1" set="method" line="51"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" set="method" line="55"><f a=""><x path="sunaba.core.Variant"/></f></next>
		<new public="1" set="method" line="46"><f a="array">
	<c path="sunaba.core.ArrayList"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="sunaba.core.ArrayListAbstract" params="" file="G:\sunaba\sunaba/core/ArrayList.hx" module="sunaba.core.ArrayList">
		<from>
			<icast><c path="sunaba.core.ArrayList"/></icast>
			<icast field="fromArray"><c path="Array"><x path="sunaba.core.Variant"/></c></icast>
		</from>
		<this><c path="sunaba.core.ArrayList"/></this>
		<to>
			<icast><c path="sunaba.core.ArrayList"/></icast>
			<icast field="toArray"><c path="Array"><x path="sunaba.core.Variant"/></c></icast>
		</to>
		<impl><class path="sunaba.core._ArrayList.ArrayListAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/ArrayList.hx" private="1" module="sunaba.core.ArrayList" final="1">
	<get public="1" get="inline" set="null" line="68" static="1">
		<f a="this:index">
			<c path="sunaba.core.ArrayList"/>
			<x path="Int"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
	</get>
	<set public="1" get="inline" set="null" line="73" static="1">
		<f a="this:index:value">
			<c path="sunaba.core.ArrayList"/>
			<x path="Int"/>
			<x path="sunaba.core.Variant"/>
			<x path="Void"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
	</set>
	<getArray public="1" get="inline" set="null" line="78" static="1">
		<f a="this:index">
			<c path="sunaba.core.ArrayList"/>
			<x path="Int"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
	</getArray>
	<setArray public="1" get="inline" set="null" line="83" static="1">
		<f a="this:index:value">
			<c path="sunaba.core.ArrayList"/>
			<x path="Int"/>
			<x path="sunaba.core.Variant"/>
			<x path="Void"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
	</setArray>
	<forEach public="1" get="inline" set="null" line="87" static="1"><f a="this:callback">
	<c path="sunaba.core.ArrayList"/>
	<f a="">
		<x path="sunaba.core.Variant"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></forEach>
	<toArray public="1" get="inline" set="null" line="94" static="1">
		<f a="this">
			<c path="sunaba.core.ArrayList"/>
			<c path="Array"><x path="sunaba.core.Variant"/></c>
		</f>
		<meta><m n=":to"/></meta>
	</toArray>
	<fromArray public="1" set="method" line="103" static="1">
		<f a="array">
			<c path="Array"><x path="sunaba.core.Variant"/></c>
			<x path="sunaba.core.ArrayListAbstract"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromArray>
	<iterator public="1" set="method" line="111" static="1"><f a="this">
	<c path="sunaba.core.ArrayList"/>
	<c path="sunaba.core.ArrayListIterator"/>
</f></iterator>
</class></impl>
	</abstract>
	<class path="sunaba.core._ArrayList.ArrayListAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/ArrayList.hx" private="1" module="sunaba.core.ArrayList" final="1">
		<get public="1" get="inline" set="null" line="68" static="1">
			<f a="this:index">
				<c path="sunaba.core.ArrayList"/>
				<x path="Int"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
		</get>
		<set public="1" get="inline" set="null" line="73" static="1">
			<f a="this:index:value">
				<c path="sunaba.core.ArrayList"/>
				<x path="Int"/>
				<x path="sunaba.core.Variant"/>
				<x path="Void"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
		</set>
		<getArray public="1" get="inline" set="null" line="78" static="1">
			<f a="this:index">
				<c path="sunaba.core.ArrayList"/>
				<x path="Int"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
		</getArray>
		<setArray public="1" get="inline" set="null" line="83" static="1">
			<f a="this:index:value">
				<c path="sunaba.core.ArrayList"/>
				<x path="Int"/>
				<x path="sunaba.core.Variant"/>
				<x path="Void"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
		</setArray>
		<forEach public="1" get="inline" set="null" line="87" static="1"><f a="this:callback">
	<c path="sunaba.core.ArrayList"/>
	<f a="">
		<x path="sunaba.core.Variant"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></forEach>
		<toArray public="1" get="inline" set="null" line="94" static="1">
			<f a="this">
				<c path="sunaba.core.ArrayList"/>
				<c path="Array"><x path="sunaba.core.Variant"/></c>
			</f>
			<meta><m n=":to"/></meta>
		</toArray>
		<fromArray public="1" set="method" line="103" static="1">
			<f a="array">
				<c path="Array"><x path="sunaba.core.Variant"/></c>
				<x path="sunaba.core.ArrayListAbstract"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromArray>
		<iterator public="1" set="method" line="111" static="1"><f a="this">
	<c path="sunaba.core.ArrayList"/>
	<c path="sunaba.core.ArrayListIterator"/>
</f></iterator>
	</class>
	<class path="sunaba.core.BaseObject" params="" file="G:\sunaba\sunaba/core/BaseObject.hx" extern="1">
		<onFree public="1" set="method"><f a=""><x path="Void"/></f></onFree>
		<free public="1" set="method"><f a=""><x path="Void"/></f></free>
		<meta><m n=":native"><e>"BaseObject"</e></m></meta>
	</class>
	<class path="sunaba.core.Basis" params="" file="G:\sunaba\sunaba/core/Basis.hx" extern="1">
		<zero public="1" set="method" static="1">
			<f a=""><c path="sunaba.core.Basis"/></f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</zero>
		<rows public="1"><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.core.Vector3"/>
</c></rows>
		<determinant public="1" set="method"><f a=""><x path="Float"/></f></determinant>
		<fromEuler public="1" set="method">
			<f a="euler:?order" v=":2">
				<c path="sunaba.core.Vector3"/>
				<x path="Int"/>
				<c path="sunaba.core.Basis"/>
			</f>
			<meta><m n=":value"><e>{ order : 2 }</e></m></meta>
		</fromEuler>
		<fromScale public="1" set="method"><f a="scale">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Basis"/>
</f></fromScale>
		<getEuler public="1" set="method">
			<f a="?order" v="2">
				<x path="Int"/>
				<c path="sunaba.core.Vector3"/>
			</f>
			<meta><m n=":value"><e>{ order : 2 }</e></m></meta>
		</getEuler>
		<getRoationQuaternion public="1" set="method"><f a=""><c path="sunaba.core.Quaternion"/></f></getRoationQuaternion>
		<getScale public="1" set="method"><f a=""><c path="sunaba.core.Vector3"/></f></getScale>
		<inverse public="1" set="method"><f a=""><c path="sunaba.core.Basis"/></f></inverse>
		<isEqualApprox public="1" set="method"><f a="basis">
	<c path="sunaba.core.Basis"/>
	<x path="Bool"/>
</f></isEqualApprox>
		<lookingAt public="1" set="method"><f a="target:up">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Basis"/>
</f></lookingAt>
		<orthonormalized public="1" set="method"><f a=""><c path="sunaba.core.Basis"/></f></orthonormalized>
		<scaled public="1" set="method"><f a="scale">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Basis"/>
</f></scaled>
		<slerp public="1" set="method"><f a="to:weight">
	<c path="sunaba.core.Basis"/>
	<x path="Float"/>
	<c path="sunaba.core.Basis"/>
</f></slerp>
		<tdotx public="1" set="method"><f a="v">
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
</f></tdotx>
		<tdoty public="1" set="method"><f a="v">
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
</f></tdoty>
		<tdotz public="1" set="method"><f a="v">
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
</f></tdotz>
		<transposed public="1" set="method"><f a=""><c path="sunaba.core.Basis"/></f></transposed>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"tostring"</e></m></meta>
		</toString>
		<new public="1" set="method"><f a="x:y:z">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"Basis"</e></m></meta>
	</class>
	<class path="sunaba.core.Element" params="" file="G:\sunaba\sunaba/core/Element.hx" extern="1">
		<extends path="sunaba.core.BaseObject"/>
		<castElement public="1" set="method" static="1">
			<f a="obj">
				<d/>
				<c path="sunaba.core.Element"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castElement>
		<isElementType public="1" set="method" static="1"><f a=""><x path="Bool"/></f></isElementType>
		<scriptInstance public="1"><d/></scriptInstance>
		<name public="1"><c path="String"/></name>
		<childEnteredTree public="1"><c path="sunaba.core.Event"/></childEnteredTree>
		<childExitingTree public="1"><c path="sunaba.core.Event"/></childExitingTree>
		<childOrderChanged public="1"><c path="sunaba.core.Event"/></childOrderChanged>
		<renamed public="1"><c path="sunaba.core.Event"/></renamed>
		<replacingBy public="1"><c path="sunaba.core.Event"/></replacingBy>
		<treeEntered public="1"><c path="sunaba.core.Event"/></treeEntered>
		<treeExited public="1"><c path="sunaba.core.Event"/></treeExited>
		<treeExiting public="1"><c path="sunaba.core.Event"/></treeExiting>
		<find public="1" set="method"><f a="path">
	<c path="String"/>
	<c path="sunaba.core.Element"/>
</f></find>
		<getParent public="1" set="method"><f a=""><c path="sunaba.core.Element"/></f></getParent>
		<addChild public="1" set="method"><f a="child">
	<c path="sunaba.core.Element"/>
	<x path="Void"/>
</f></addChild>
		<addSibling public="1" set="method"><f a="sibling">
	<c path="sunaba.core.Element"/>
	<x path="Void"/>
</f></addSibling>
		<removeChild public="1" set="method"><f a="child">
	<c path="sunaba.core.Element"/>
	<x path="Void"/>
</f></removeChild>
		<getChildren public="1" set="method"><f a=""><x path="sunaba.core.Vector"><c path="sunaba.core.Element"/></x></f></getChildren>
		<isNull public="1" set="method"><f a=""><x path="Bool"/></f></isNull>
		<getViewport public="1" set="method"><f a=""><c path="sunaba.core.Viewport"/></f></getViewport>
		<delete public="1" set="method"><f a=""><x path="Void"/></f></delete>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Element"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.CanvasItem" params="" file="G:\sunaba\sunaba/core/CanvasItem.hx" extern="1">
		<extends path="sunaba.core.Element"/>
		<toCanvasItem public="1" set="method" static="1">
			<f a="obj">
				<d/>
				<c path="sunaba.core.CanvasItem"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</toCanvasItem>
		<clipChildren public="1"><x path="Int"/></clipChildren>
		<lightMask public="1"><x path="Int"/></lightMask>
		<material public="1"><c path="sunaba.core.Material"/></material>
		<modulate public="1"><c path="sunaba.core.Color"/></modulate>
		<selfModulate public="1"><c path="sunaba.core.Color"/></selfModulate>
		<showBehindParent public="1"><x path="Bool"/></showBehindParent>
		<textureFilter public="1"><x path="Int"/></textureFilter>
		<textureRepeat public="1"><x path="Bool"/></textureRepeat>
		<topLevel public="1"><x path="Bool"/></topLevel>
		<useParentMaterial public="1"><x path="Bool"/></useParentMaterial>
		<visibilityLayer public="1"><x path="Int"/></visibilityLayer>
		<visible public="1"><x path="Bool"/></visible>
		<ySortEnabled public="1"><x path="Bool"/></ySortEnabled>
		<zAsRelative public="1"><x path="Bool"/></zAsRelative>
		<zIndex public="1"><x path="Int"/></zIndex>
		<drawAnimationSlice public="1" set="method">
			<f a="animationLength:sliceBegin:sliceEnd:?offset" v=":::0.0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0.0 }</e></m></meta>
		</drawAnimationSlice>
		<drawArc public="1" set="method">
			<f a="center:radius:startAngle:endAngle:pointCount:color:?width:?antialis" v="::::::1.0:false">
				<c path="sunaba.core.Vector2"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="sunaba.core.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ antialis : false, width : 1.0 }</e></m></meta>
		</drawArc>
		<drawChar public="1" set="method">
			<f a="font:pos:chr:?fontSize:?modulate" v=":::16:null">
				<c path="sunaba.core.Font"/>
				<c path="sunaba.core.Vector2"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="sunaba.core.Color"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ modulate : null, fontSize : 16 }</e></m></meta>
		</drawChar>
		<drawCharOutline public="1" set="method">
			<f a="font:pos:chr:?fontSize:?size:?modulate" v=":::16:-1:null">
				<c path="sunaba.core.Font"/>
				<c path="sunaba.core.Vector2"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="sunaba.core.Color"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ modulate : null, size : -1, fontSize : 16 }</e></m></meta>
		</drawCharOutline>
		<drawCircle public="1" set="method">
			<f a="center:radius:color:?width:?antialis" v=":::1.0:false">
				<c path="sunaba.core.Vector2"/>
				<x path="Float"/>
				<c path="sunaba.core.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ antialis : false, width : 1.0 }</e></m></meta>
		</drawCircle>
		<drawColoredPolygon public="1" set="method">
			<f a="points:color:?uvs:?texture" v="::null:null">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector2"/>
				</c>
				<c path="sunaba.core.Color"/>
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector2"/>
				</c>
				<c path="sunaba.core.Texture2D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ texture : null, uvs : null }</e></m></meta>
		</drawColoredPolygon>
		<drawDashedLine public="1" set="method">
			<f a="from:to:color:?width:?dash:?aligned:?antialis" v=":::-1.0:2.0:true:false">
				<c path="sunaba.core.Vector2"/>
				<c path="sunaba.core.Vector2"/>
				<c path="sunaba.core.Color"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ antialis : false, aligned : true, dash : 2.0, width : -1.0 }</e></m></meta>
		</drawDashedLine>
		<drawEndAnimation public="1" set="method"><f a=""><x path="Void"/></f></drawEndAnimation>
		<drawLcdTextureRectRegion public="1" set="method">
			<f a="texture:rect:srcRect:?modulate" v=":::null">
				<c path="sunaba.core.Texture2D"/>
				<c path="sunaba.core.Rect2"/>
				<c path="sunaba.core.Rect2"/>
				<c path="sunaba.core.Color"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ modulate : null }</e></m></meta>
		</drawLcdTextureRectRegion>
		<drawLine public="1" set="method">
			<f a="from:to:color:?width:?antialis" v=":::-1.0:false">
				<c path="sunaba.core.Vector2"/>
				<c path="sunaba.core.Vector2"/>
				<c path="sunaba.core.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ antialis : false, width : -1.0 }</e></m></meta>
		</drawLine>
		<drawMsdfTextureRegion public="1" set="method">
			<f a="texture:rect:srcRect:?modulate:?outline:?pxelRange:?scale" v=":::null:0.0:4.0:1.0">
				<c path="sunaba.core.Texture2D"/>
				<c path="sunaba.core.Rect2"/>
				<c path="sunaba.core.Rect2"/>
				<c path="sunaba.core.Color"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1.0, pxelRange : 4.0, outline : 0.0, modulate : null }</e></m></meta>
		</drawMsdfTextureRegion>
		<drawMultiline public="1" set="method">
			<f a="points:colors:?width:?antialis" v="::-1.0:false">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector2"/>
				</c>
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Color"/>
				</c>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ antialis : false, width : -1.0 }</e></m></meta>
		</drawMultiline>
		<drawMultilineColors public="1" set="method">
			<f a="points:colors:?width:?antialis" v="::-1.0:false">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector2"/>
				</c>
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Color"/>
				</c>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ antialis : false, width : -1.0 }</e></m></meta>
		</drawMultilineColors>
		<drawMultilineString public="1" set="method">
			<f a="font:pos:text:?alignment:?width:?fontSize:?maxLines:?modulate:?brkFlags:?justificationFlags:?direction:?orientation" v=":::0:-1:16:-1:null:null:null:0:0">
				<c path="sunaba.core.Font"/>
				<c path="sunaba.core.Vector2"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="sunaba.core.Color"/>
				<c path="lua.Table">
					<x path="Int"/>
					<x path="Int"/>
				</c>
				<c path="lua.Table">
					<x path="Int"/>
					<x path="Int"/>
				</c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ orientation : 0, direction : 0, justificationFlags : null, brkFlags : null, modulate : null, maxLines : -1, fontSize : 16, width : -1, alignment : 0 }</e></m></meta>
		</drawMultilineString>
		<drawMultilineStringOutline public="1" set="method">
			<f a="font:pos:text:?alignment:?width:?fontSize:?maxLines:?size:?modulate:?brkFlags:?justificationFlags:?direction:?orientation" v=":::0:-1:16:-1:1:null:null:null:0:0">
				<c path="sunaba.core.Font"/>
				<c path="sunaba.core.Vector2"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="sunaba.core.Color"/>
				<c path="lua.Table">
					<x path="Int"/>
					<x path="Int"/>
				</c>
				<c path="lua.Table">
					<x path="Int"/>
					<x path="Int"/>
				</c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ orientation : 0, direction : 0, justificationFlags : null, brkFlags : null, modulate : null, size : 1, maxLines : -1, fontSize : 16, width : -1, alignment : 0 }</e></m></meta>
		</drawMultilineStringOutline>
		<drawPolygon public="1" set="method">
			<f a="points:colors:?uvs:?texture" v="::null:null">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector2"/>
				</c>
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Color"/>
				</c>
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector2"/>
				</c>
				<c path="sunaba.core.Texture2D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ texture : null, uvs : null }</e></m></meta>
		</drawPolygon>
		<darwPolylineColors public="1" set="method">
			<f a="points:colors:?width:?antialis" v="::-1.0:false">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector2"/>
				</c>
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Color"/>
				</c>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ antialis : false, width : -1.0 }</e></m></meta>
		</darwPolylineColors>
		<drawPrimitive public="1" set="method">
			<f a="points:colors:?uvs:?texture" v="::null:null">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector2"/>
				</c>
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Color"/>
				</c>
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector2"/>
				</c>
				<c path="sunaba.core.Texture2D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ texture : null, uvs : null }</e></m></meta>
		</drawPrimitive>
		<drawRect public="1" set="method">
			<f a="rect:color:?filled:?width:?antialis" v="::true:1.0:false">
				<c path="sunaba.core.Rect2"/>
				<c path="sunaba.core.Color"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ antialis : false, width : 1.0, filled : true }</e></m></meta>
		</drawRect>
		<drawSetTransform public="1" set="method">
			<f a="pos:?rotation:?scale" v=":0.0:null">
				<c path="sunaba.core.Vector2"/>
				<x path="Float"/>
				<c path="sunaba.core.Vector2"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scale : null, rotation : 0.0 }</e></m></meta>
		</drawSetTransform>
		<drawSetTransformMatrix public="1" set="method"><f a="xform">
	<c path="sunaba.core.Transform2D"/>
	<x path="Void"/>
</f></drawSetTransformMatrix>
		<drawString public="1" set="method">
			<f a="font:pos:text:?alignment:?width:?fontSize:?modulate:?justificationFlags:?direction:?orientation" v=":::0:-1:16:null:null:0:0">
				<c path="sunaba.core.Font"/>
				<c path="sunaba.core.Vector2"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="sunaba.core.Color"/>
				<c path="lua.Table">
					<x path="Int"/>
					<x path="Int"/>
				</c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ orientation : 0, direction : 0, justificationFlags : null, modulate : null, fontSize : 16, width : -1, alignment : 0 }</e></m></meta>
		</drawString>
		<drawStringOutline public="1" set="method">
			<f a="font:pos:text:?alignment:?width:?fontSize:?size:?modulate:?justificationFlags:?direction:?orientation" v=":::0:-1:16:1:null:null:0:0">
				<c path="sunaba.core.Font"/>
				<c path="sunaba.core.Vector2"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="sunaba.core.Color"/>
				<c path="lua.Table">
					<x path="Int"/>
					<x path="Int"/>
				</c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ orientation : 0, direction : 0, justificationFlags : null, modulate : null, size : 1, fontSize : 16, width : -1, alignment : 0 }</e></m></meta>
		</drawStringOutline>
		<drawStyleBox public="1" set="method"><f a="styleBox:rect">
	<c path="sunaba.ui.StyleBox"/>
	<c path="sunaba.core.Rect2"/>
	<x path="Void"/>
</f></drawStyleBox>
		<drawTexture public="1" set="method">
			<f a="texture:pos:?modulate" v="::null">
				<c path="sunaba.core.Texture2D"/>
				<c path="sunaba.core.Vector2"/>
				<c path="sunaba.core.Color"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ modulate : null }</e></m></meta>
		</drawTexture>
		<drawTextureRectRegion public="1" set="method">
			<f a="texture:rect:srcRect:?modulate:?transpose:?clipUv" v=":::null:false:true">
				<c path="sunaba.core.Texture2D"/>
				<c path="sunaba.core.Rect2"/>
				<c path="sunaba.core.Rect2"/>
				<c path="sunaba.core.Color"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ clipUv : true, transpose : false, modulate : null }</e></m></meta>
		</drawTextureRectRegion>
		<forceUpdateTransform public="1" set="method"><f a=""><x path="Void"/></f></forceUpdateTransform>
		<getCanvasTransform public="1" set="method"><f a=""><c path="sunaba.core.Transform2D"/></f></getCanvasTransform>
		<getGlobalMousePosition public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></getGlobalMousePosition>
		<getGlobalTransform public="1" set="method"><f a=""><c path="sunaba.core.Transform2D"/></f></getGlobalTransform>
		<getGlobalTransformWithCanvas public="1" set="method"><f a=""><c path="sunaba.core.Transform2D"/></f></getGlobalTransformWithCanvas>
		<getLocalMousePosition public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></getLocalMousePosition>
		<getScreenTransform public="1" set="method"><f a=""><c path="sunaba.core.Transform2D"/></f></getScreenTransform>
		<getTransform public="1" set="method"><f a=""><c path="sunaba.core.Transform2D"/></f></getTransform>
		<getViewportRect public="1" set="method"><f a=""><c path="sunaba.core.Rect2"/></f></getViewportRect>
		<getViewportTransform public="1" set="method"><f a=""><c path="sunaba.core.Transform2D"/></f></getViewportTransform>
		<getVisibilityLayerBit public="1" set="method"><f a="bit">
	<x path="Int"/>
	<x path="Bool"/>
</f></getVisibilityLayerBit>
		<hide public="1" set="method"><f a=""><x path="Void"/></f></hide>
		<isLocalTransformNotificationEnabled public="1" set="method"><f a=""><x path="Bool"/></f></isLocalTransformNotificationEnabled>
		<isVisibleInTree public="1" set="method"><f a=""><x path="Bool"/></f></isVisibleInTree>
		<makeCanvasPositionLocal public="1" set="method"><f a="position">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
</f></makeCanvasPositionLocal>
		<makeInputLocal public="1" set="method"><f a="event">
	<c path="sunaba.input.InputEvent"/>
	<c path="sunaba.input.InputEvent"/>
</f></makeInputLocal>
		<moveToFront public="1" set="method"><f a=""><x path="Void"/></f></moveToFront>
		<queueRedraw public="1" set="method"><f a=""><x path="Void"/></f></queueRedraw>
		<setNotifyLocalTransform public="1" set="method"><f a="enable">
	<x path="Bool"/>
	<x path="Void"/>
</f></setNotifyLocalTransform>
		<setNotifyTransform public="1" set="method"><f a="enable">
	<x path="Bool"/>
	<x path="Void"/>
</f></setNotifyTransform>
		<show public="1" set="method"><f a=""><x path="Void"/></f></show>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Element"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.core.CanvasItemAbstract" params="" file="G:\sunaba\sunaba/core/CanvasItem.hx" module="sunaba.core.CanvasItem">
		<from>
			<icast><c path="sunaba.core.CanvasItem"/></icast>
			<icast field="fromElement"><c path="sunaba.core.Element"/></icast>
		</from>
		<this><c path="sunaba.core.CanvasItem"/></this>
		<to><icast><c path="sunaba.core.CanvasItem"/></icast></to>
		<impl><class path="sunaba.core._CanvasItem.CanvasItemAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/CanvasItem.hx" private="1" module="sunaba.core.CanvasItem" final="1"><fromElement public="1" set="method" line="76" static="1">
	<f a="element">
		<c path="sunaba.core.Element"/>
		<x path="sunaba.core.CanvasItemAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromElement></class></impl>
	</abstract>
	<class path="sunaba.core._CanvasItem.CanvasItemAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/CanvasItem.hx" private="1" module="sunaba.core.CanvasItem" final="1"><fromElement public="1" set="method" line="76" static="1">
	<f a="element">
		<c path="sunaba.core.Element"/>
		<x path="sunaba.core.CanvasItemAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromElement></class>
	<class path="sunaba.core.Color" params="" file="G:\sunaba\sunaba/core/Color.hx" extern="1">
		<rgba public="1" set="method" static="1">
			<f a="r:g:b:a">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="sunaba.core.Color"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</rgba>
		<rgb public="1" set="method" static="1">
			<f a="r:g:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="sunaba.core.Color"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</rgb>
		<fromColorAndAlpha public="1" set="method" static="1">
			<f a="color:a">
				<c path="sunaba.core.Color"/>
				<x path="Float"/>
				<c path="sunaba.core.Color"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromColorAndAlpha>
		<code public="1" set="method" static="1">
			<f a="code:?a" v=":1.0">
				<c path="String"/>
				<x path="Float"/>
				<c path="sunaba.core.Color"/>
			</f>
			<meta>
				<m n=":value"><e>{ a : 1.0 }</e></m>
				<m n=":native"><e>"new"</e></m>
			</meta>
		</code>
		<hsv public="1" set="method" static="1">
			<f a="h:s:v:?alpha" v=":::1.0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="sunaba.core.Color"/>
			</f>
			<meta>
				<m n=":value"><e>{ alpha : 1.0 }</e></m>
				<m n=":native"><e>"fromHSV"</e></m>
			</meta>
		</hsv>
		<rgbe9995 public="1" set="method" static="1">
			<f a="r:g:b:e:?alpha" v="::::1.0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="sunaba.core.Color"/>
			</f>
			<meta>
				<m n=":value"><e>{ alpha : 1.0 }</e></m>
				<m n=":native"><e>"fromRGBE9995"</e></m>
			</meta>
		</rgbe9995>
		<string public="1" set="method" static="1">
			<f a="str:defalt">
				<c path="String"/>
				<c path="sunaba.core.Color"/>
				<c path="sunaba.core.Color"/>
			</f>
			<meta><m n=":native"><e>"fromString"</e></m></meta>
		</string>
		<hex public="1" set="method" static="1"><f a="hex">
	<x path="Int"/>
	<c path="sunaba.core.Color"/>
</f></hex>
		<hex64 public="1" set="method" static="1"><f a="hex">
	<x path="Int"/>
	<c path="sunaba.core.Color"/>
</f></hex64>
		<html public="1" set="method" static="1"><f a="html">
	<c path="String"/>
	<c path="sunaba.core.Color"/>
</f></html>
		<htmlIsValid public="1" set="method" static="1"><f a="html">
	<c path="String"/>
	<x path="Bool"/>
</f></htmlIsValid>
		<r public="1"><x path="Float"/></r>
		<g public="1"><x path="Float"/></g>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<blend public="1" set="method"><f a="ove">
	<c path="sunaba.core.Color"/>
	<c path="sunaba.core.Color"/>
</f></blend>
		<clamp public="1" set="method">
			<f a="?min:?max" v="null:null">
				<c path="sunaba.core.Color"/>
				<c path="sunaba.core.Color"/>
				<c path="sunaba.core.Color"/>
			</f>
			<meta><m n=":value"><e>{ max : null, min : null }</e></m></meta>
		</clamp>
		<darkened public="1" set="method"><f a="amount">
	<x path="Float"/>
	<c path="sunaba.core.Color"/>
</f></darkened>
		<getLuminance public="1" set="method"><f a=""><x path="Float"/></f></getLuminance>
		<inverted public="1" set="method"><f a=""><c path="sunaba.core.Color"/></f></inverted>
		<isEqualApprox public="1" set="method"><f a="to">
	<c path="sunaba.core.Color"/>
	<x path="Bool"/>
</f></isEqualApprox>
		<lerp public="1" set="method"><f a="to:weight">
	<c path="sunaba.core.Color"/>
	<x path="Float"/>
	<c path="sunaba.core.Color"/>
</f></lerp>
		<lightened public="1" set="method"><f a="amount">
	<x path="Float"/>
	<c path="sunaba.core.Color"/>
</f></lightened>
		<linearToSrgb public="1" set="method"><f a=""><c path="sunaba.core.Color"/></f></linearToSrgb>
		<srgbToLinear public="1" set="method"><f a=""><c path="sunaba.core.Color"/></f></srgbToLinear>
		<toAbgr32 public="1" set="method"><f a=""><x path="Int"/></f></toAbgr32>
		<toAbgr64 public="1" set="method"><f a=""><x path="Int"/></f></toAbgr64>
		<toArgb32 public="1" set="method"><f a=""><x path="Int"/></f></toArgb32>
		<toArgb64 public="1" set="method"><f a=""><x path="Int"/></f></toArgb64>
		<toHtml public="1" set="method"><f a=""><c path="String"/></f></toHtml>
		<toRgba32 public="1" set="method"><f a=""><x path="Int"/></f></toRgba32>
		<toRgba64 public="1" set="method"><f a=""><x path="Int"/></f></toRgba64>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Color"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.Dictionary" params="" file="G:\sunaba\sunaba/core/Dictionary.hx" extern="1">
		<assign public="1" set="method"><f a="dict">
	<c path="sunaba.core.Dictionary"/>
	<x path="Void"/>
</f></assign>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<duplicate public="1" set="method">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="sunaba.core.Dictionary"/>
			</f>
			<meta><m n=":value"><e>{ deep : false }</e></m></meta>
		</duplicate>
		<erase public="1" set="method"><f a="key">
	<x path="sunaba.core.Variant"/>
	<x path="Void"/>
</f></erase>
		<findKey public="1" set="method"><f a="key">
	<x path="sunaba.core.Variant"/>
	<x path="sunaba.core.Variant"/>
</f></findKey>
		<get public="1" set="method"><f a="key:?d">
	<x path="sunaba.core.Variant"/>
	<x path="sunaba.core.Variant"/>
	<x path="sunaba.core.Variant"/>
</f></get>
		<getOrAdd public="1" set="method"><f a="key:?d">
	<x path="sunaba.core.Variant"/>
	<x path="sunaba.core.Variant"/>
	<x path="sunaba.core.Variant"/>
</f></getOrAdd>
		<has public="1" set="method"><f a="key">
	<x path="sunaba.core.Variant"/>
	<x path="Bool"/>
</f></has>
		<hasAll public="1" set="method"><f a="keys">
	<c path="sunaba.core.ArrayList"/>
	<x path="Bool"/>
</f></hasAll>
		<hash public="1" set="method"><f a=""><x path="Int"/></f></hash>
		<isEmpty public="1" set="method"><f a=""><x path="Bool"/></f></isEmpty>
		<isReadOnly public="1" set="method"><f a=""><x path="Bool"/></f></isReadOnly>
		<keys public="1" set="method"><f a=""><c path="sunaba.core.ArrayList"/></f></keys>
		<makeReadOnly public="1" set="method"><f a=""><x path="Void"/></f></makeReadOnly>
		<merge public="1" set="method">
			<f a="dict:?overwrite" v=":false">
				<c path="sunaba.core.Dictionary"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ overwrite : false }</e></m></meta>
		</merge>
		<recursiveEquals public="1" set="method"><f a="dict:recursionCount">
	<c path="sunaba.core.Dictionary"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></recursiveEquals>
		<set public="1" set="method"><f a="key:value">
	<x path="sunaba.core.Variant"/>
	<x path="sunaba.core.Variant"/>
	<x path="Void"/>
</f></set>
		<size public="1" set="method"><f a=""><x path="Int"/></f></size>
		<sort public="1" set="method"><f a=""><x path="Void"/></f></sort>
		<values public="1" set="method"><f a=""><c path="sunaba.core.ArrayList"/></f></values>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":native"><e>"Dictionary"</e></m></meta>
	</class>
	<class path="sunaba.core.DictionaryIterator" params="" file="G:\sunaba\sunaba/core/Dictionary.hx" module="sunaba.core.Dictionary">
		<index public="1"><x path="Int"/></index>
		<dict public="1"><c path="sunaba.core.Dictionary"/></dict>
		<hasNext public="1" set="method" line="36"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" set="method" line="40"><f a=""><x path="sunaba.core.Variant"/></f></next>
		<new public="1" set="method" line="31"><f a="dict">
	<c path="sunaba.core.Dictionary"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="sunaba.core.DictionaryAbstract" params="" file="G:\sunaba\sunaba/core/Dictionary.hx" module="sunaba.core.Dictionary">
		<from><icast><c path="sunaba.core.Dictionary"/></icast></from>
		<this><c path="sunaba.core.Dictionary"/></this>
		<to><icast><c path="sunaba.core.Dictionary"/></icast></to>
		<impl><class path="sunaba.core._Dictionary.DictionaryAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Dictionary.hx" private="1" module="sunaba.core.Dictionary" final="1">
	<get public="1" get="inline" set="null" line="53" static="1">
		<f a="this:key">
			<c path="sunaba.core.Dictionary"/>
			<x path="sunaba.core.Variant"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
	</get>
	<set public="1" get="inline" set="null" line="58" static="1">
		<f a="this:key:value">
			<c path="sunaba.core.Dictionary"/>
			<x path="sunaba.core.Variant"/>
			<x path="sunaba.core.Variant"/>
			<x path="Void"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
	</set>
	<getArray public="1" get="inline" set="null" line="63" static="1">
		<f a="this:key">
			<c path="sunaba.core.Dictionary"/>
			<x path="sunaba.core.Variant"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
	</getArray>
	<setArray public="1" get="inline" set="null" line="68" static="1">
		<f a="this:key:value">
			<c path="sunaba.core.Dictionary"/>
			<x path="sunaba.core.Variant"/>
			<x path="sunaba.core.Variant"/>
			<x path="Void"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
	</setArray>
	<forEach public="1" get="inline" set="null" line="72" static="1"><f a="this:func">
	<c path="sunaba.core.Dictionary"/>
	<f a=":">
		<x path="sunaba.core.Variant"/>
		<x path="sunaba.core.Variant"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></forEach>
	<iterator public="1" set="method" line="80" static="1"><f a="this">
	<c path="sunaba.core.Dictionary"/>
	<c path="sunaba.core.DictionaryIterator"/>
</f></iterator>
</class></impl>
	</abstract>
	<class path="sunaba.core._Dictionary.DictionaryAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Dictionary.hx" private="1" module="sunaba.core.Dictionary" final="1">
		<get public="1" get="inline" set="null" line="53" static="1">
			<f a="this:key">
				<c path="sunaba.core.Dictionary"/>
				<x path="sunaba.core.Variant"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
		</get>
		<set public="1" get="inline" set="null" line="58" static="1">
			<f a="this:key:value">
				<c path="sunaba.core.Dictionary"/>
				<x path="sunaba.core.Variant"/>
				<x path="sunaba.core.Variant"/>
				<x path="Void"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
		</set>
		<getArray public="1" get="inline" set="null" line="63" static="1">
			<f a="this:key">
				<c path="sunaba.core.Dictionary"/>
				<x path="sunaba.core.Variant"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
		</getArray>
		<setArray public="1" get="inline" set="null" line="68" static="1">
			<f a="this:key:value">
				<c path="sunaba.core.Dictionary"/>
				<x path="sunaba.core.Variant"/>
				<x path="sunaba.core.Variant"/>
				<x path="Void"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
		</setArray>
		<forEach public="1" get="inline" set="null" line="72" static="1"><f a="this:func">
	<c path="sunaba.core.Dictionary"/>
	<f a=":">
		<x path="sunaba.core.Variant"/>
		<x path="sunaba.core.Variant"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></forEach>
		<iterator public="1" set="method" line="80" static="1"><f a="this">
	<c path="sunaba.core.Dictionary"/>
	<c path="sunaba.core.DictionaryIterator"/>
</f></iterator>
	</class>
	<abstract path="sunaba.core.ElementAbstract" params="" file="G:\sunaba\sunaba/core/Element.hx" module="sunaba.core.Element">
		<from>
			<icast><c path="sunaba.core.Element"/></icast>
			<icast field="fromElement"><c path="sunaba.core.Element"/></icast>
		</from>
		<this><c path="sunaba.core.Element"/></this>
		<to><icast><c path="sunaba.core.Element"/></icast></to>
		<impl><class path="sunaba.core._Element.ElementAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Element.hx" private="1" module="sunaba.core.Element" final="1"><fromElement public="1" set="method" line="32" static="1">
	<f a="element">
		<c path="sunaba.core.Element"/>
		<x path="sunaba.core.ElementAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromElement></class></impl>
	</abstract>
	<class path="sunaba.core._Element.ElementAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Element.hx" private="1" module="sunaba.core.Element" final="1"><fromElement public="1" set="method" line="32" static="1">
	<f a="element">
		<c path="sunaba.core.Element"/>
		<x path="sunaba.core.ElementAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromElement></class>
	<class path="sunaba.core.Resource" params="" file="G:\sunaba\sunaba/core/Resource.hx" extern="1">
		<extends path="sunaba.core.BaseObject"/>
		<castFrom public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.core.Resource"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<duplicate public="1" set="method"><f a=""><c path="sunaba.core.Resource"/></f></duplicate>
		<emitChanged public="1" set="method"><f a=""><x path="Void"/></f></emitChanged>
		<isNull public="1" set="method"><f a=""><x path="Bool"/></f></isNull>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Resource"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.Environment" params="" file="G:\sunaba\sunaba/core/Environment.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<castFrom public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.core.Environment"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<adjustmentBrightness public="1"><x path="Float"/></adjustmentBrightness>
		<adjustmentColorCorrection public="1"><x path="Float"/></adjustmentColorCorrection>
		<adjustmentContrast public="1"><x path="Float"/></adjustmentContrast>
		<adjustmentEnabled public="1"><x path="Bool"/></adjustmentEnabled>
		<adjustmentSaturation public="1"><x path="Float"/></adjustmentSaturation>
		<ambientLightColor public="1"><c path="sunaba.core.Color"/></ambientLightColor>
		<ambientLightEnergy public="1"><x path="Float"/></ambientLightEnergy>
		<ambientLightSkyContribution public="1"><x path="Float"/></ambientLightSkyContribution>
		<ambientLightSource public="1"><x path="Int"/></ambientLightSource>
		<backgroundCameraFeedId public="1"><x path="Int"/></backgroundCameraFeedId>
		<backgroundCanvasMaxLayer public="1"><x path="Int"/></backgroundCanvasMaxLayer>
		<backgroundColor public="1"><c path="sunaba.core.Color"/></backgroundColor>
		<backgroundEnergyMultiplier public="1"><x path="Float"/></backgroundEnergyMultiplier>
		<backgroundIntensity public="1"><x path="Float"/></backgroundIntensity>
		<backgroundMode public="1"><x path="Int"/></backgroundMode>
		<fogArialPerspective public="1"><x path="Float"/></fogArialPerspective>
		<fogDensity public="1"><x path="Float"/></fogDensity>
		<fogDepthBegin public="1"><x path="Float"/></fogDepthBegin>
		<fogDepthCurve public="1"><x path="Float"/></fogDepthCurve>
		<fogDepthEnd public="1"><x path="Float"/></fogDepthEnd>
		<fogEnabled public="1"><x path="Bool"/></fogEnabled>
		<fogHeight public="1"><x path="Float"/></fogHeight>
		<fogHeightDensity public="1"><x path="Float"/></fogHeightDensity>
		<fogLightColor public="1"><c path="sunaba.core.Color"/></fogLightColor>
		<fogLightEnergy public="1"><x path="Float"/></fogLightEnergy>
		<fogMode public="1"><x path="Int"/></fogMode>
		<fogSkyAffect public="1"><x path="Bool"/></fogSkyAffect>
		<fogSunScatter public="1"><x path="Float"/></fogSunScatter>
		<glowBlendMode public="1"><x path="Int"/></glowBlendMode>
		<glowBloom public="1"><x path="Float"/></glowBloom>
		<glowEnabled public="1"><x path="Bool"/></glowEnabled>
		<glowHdrLuminance public="1"><x path="Float"/></glowHdrLuminance>
		<glowHdrScale public="1"><x path="Float"/></glowHdrScale>
		<glowHdrThreshold public="1"><x path="Float"/></glowHdrThreshold>
		<glowIntensity public="1"><x path="Float"/></glowIntensity>
		<glowLevel1 public="1"><x path="Float"/></glowLevel1>
		<glowLevel2 public="1"><x path="Float"/></glowLevel2>
		<glowLevel3 public="1"><x path="Float"/></glowLevel3>
		<glowLevel4 public="1"><x path="Float"/></glowLevel4>
		<glowLevel5 public="1"><x path="Float"/></glowLevel5>
		<glowLevel6 public="1"><x path="Float"/></glowLevel6>
		<glowLevel7 public="1"><x path="Float"/></glowLevel7>
		<glowMap public="1"><c path="sunaba.core.Texture"/></glowMap>
		<glowMapStrength public="1"><x path="Bool"/></glowMapStrength>
		<glowMix public="1"><x path="Float"/></glowMix>
		<glowNormalized public="1"><x path="Bool"/></glowNormalized>
		<glowStrength public="1"><x path="Float"/></glowStrength>
		<reflectedLightSource public="1"><x path="Int"/></reflectedLightSource>
		<dynamicGiBounceFeedback public="1"><x path="Float"/></dynamicGiBounceFeedback>
		<dynamicGiCascade0Distance public="1"><x path="Float"/></dynamicGiCascade0Distance>
		<dynamicGiCascades public="1"><x path="Int"/></dynamicGiCascades>
		<dynamicGiEnabled public="1"><x path="Bool"/></dynamicGiEnabled>
		<dynamicGiEnergy public="1"><x path="Float"/></dynamicGiEnergy>
		<dyamicGiMaxDistance public="1"><x path="Float"/></dyamicGiMaxDistance>
		<dyamicGiMinCellSize public="1"><x path="Float"/></dyamicGiMinCellSize>
		<dynamicGiNormalBias public="1"><x path="Float"/></dynamicGiNormalBias>
		<dynamicGiProbeBias public="1"><x path="Float"/></dynamicGiProbeBias>
		<dynamicGiUseOcclusion public="1"><x path="Bool"/></dynamicGiUseOcclusion>
		<dynamicGiYScale public="1"><x path="Float"/></dynamicGiYScale>
		<sky public="1"><c path="sunaba.spatial.Sky"/></sky>
		<skyCustomFov public="1"><x path="Float"/></skyCustomFov>
		<skyRotation public="1"><c path="sunaba.core.Vector3"/></skyRotation>
		<ssaoAoChannelAffect public="1"><x path="Float"/></ssaoAoChannelAffect>
		<ssaoDetail public="1"><x path="Float"/></ssaoDetail>
		<ssaoEnabled public="1"><x path="Bool"/></ssaoEnabled>
		<ssaoHorizon public="1"><x path="Float"/></ssaoHorizon>
		<ssaoIntensity public="1"><x path="Float"/></ssaoIntensity>
		<ssaoLightAffect public="1"><x path="Float"/></ssaoLightAffect>
		<ssaoPower public="1"><x path="Float"/></ssaoPower>
		<ssaoRadius public="1"><x path="Float"/></ssaoRadius>
		<ssaoSharpness public="1"><x path="Float"/></ssaoSharpness>
		<ssilEnabled public="1"><x path="Bool"/></ssilEnabled>
		<ssilIntensity public="1"><x path="Float"/></ssilIntensity>
		<ssilNormalRejection public="1"><x path="Float"/></ssilNormalRejection>
		<ssilRadius public="1"><x path="Float"/></ssilRadius>
		<ssilSharpness public="1"><x path="Float"/></ssilSharpness>
		<ssrDepthTolerance public="1"><x path="Float"/></ssrDepthTolerance>
		<ssrEnabled public="1"><x path="Bool"/></ssrEnabled>
		<ssrFadeIn public="1"><x path="Float"/></ssrFadeIn>
		<ssrFadeOut public="1"><x path="Float"/></ssrFadeOut>
		<ssrMaxSteps public="1"><x path="Int"/></ssrMaxSteps>
		<tonemapExposure public="1"><x path="Float"/></tonemapExposure>
		<tonemapMode public="1"><x path="Int"/></tonemapMode>
		<tonemapWhite public="1"><x path="Float"/></tonemapWhite>
		<volumetricFogAlbedo public="1"><c path="sunaba.core.Color"/></volumetricFogAlbedo>
		<volumetricFogAmbientInject public="1"><x path="Float"/></volumetricFogAmbientInject>
		<volumetricFogAnisotropy public="1"><x path="Float"/></volumetricFogAnisotropy>
		<volumetricFogDensity public="1"><x path="Float"/></volumetricFogDensity>
		<volumetricFogDetailSpread public="1"><x path="Float"/></volumetricFogDetailSpread>
		<volumetricFogEmission public="1"><c path="sunaba.core.Color"/></volumetricFogEmission>
		<volumetricFogEnabled public="1"><x path="Bool"/></volumetricFogEnabled>
		<volumetricFogGiInject public="1"><x path="Float"/></volumetricFogGiInject>
		<volumetricFogLength public="1"><x path="Float"/></volumetricFogLength>
		<volumetricFogSkyAffect public="1"><x path="Float"/></volumetricFogSkyAffect>
		<volumetricFogTemporalReprojectionAmount public="1"><x path="Float"/></volumetricFogTemporalReprojectionAmount>
		<volumetricFogTemporalReprojectionEnabled public="1"><x path="Bool"/></volumetricFogTemporalReprojectionEnabled>
		<getGlowLevel public="1" set="method"><f a="idx">
	<x path="Int"/>
	<x path="Float"/>
</f></getGlowLevel>
		<setGlowLevel public="1" set="method"><f a="idx:level">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setGlowLevel>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Environment"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.core.EnvironmentAbstract" params="" file="G:\sunaba\sunaba/core/Environment.hx" module="sunaba.core.Environment">
		<from>
			<icast><c path="sunaba.core.Environment"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.core.Environment"/></this>
		<to><icast><c path="sunaba.core.Environment"/></icast></to>
		<impl><class path="sunaba.core._Environment.EnvironmentAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Environment.hx" private="1" module="sunaba.core.Environment" final="1"><fromResource public="1" set="method" line="111" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.EnvironmentAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.core._Environment.EnvironmentAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Environment.hx" private="1" module="sunaba.core.Environment" final="1"><fromResource public="1" set="method" line="111" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.EnvironmentAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.core.Event" params="" file="G:\sunaba\sunaba/core/Event.hx" extern="1">
		<extends path="sunaba.core.BaseObject"/>
		<connect public="1" set="method"><f a="func">
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></connect>
		<disconnect public="1" set="method"><f a="func">
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></disconnect>
		<emit public="1" set="method"><f a="args">
	<x path="haxe.Rest"><x path="sunaba.core.Variant"/></x>
	<x path="Void"/>
</f></emit>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":native"><e>"Event"</e></m></meta>
	</class>
	<abstract path="sunaba.core.EventAbstract" params="" file="G:\sunaba\sunaba/core/Event.hx" module="sunaba.core.Event">
		<from><icast><c path="sunaba.core.Event"/></icast></from>
		<this><c path="sunaba.core.Event"/></this>
		<to><icast><c path="sunaba.core.Event"/></icast></to>
		<impl><class path="sunaba.core._Event.EventAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Event.hx" private="1" module="sunaba.core.Event" final="1">
	<callNoArgs public="1" set="method" line="16" static="1">
		<f a="this">
			<c path="sunaba.core.Event"/>
			<x path="Void"/>
		</f>
		<meta><m n=":op"><e>a()</e></m></meta>
		<overloads><call public="1" set="method" line="21">
	<f a="this:args">
		<c path="sunaba.core.Event"/>
		<x path="haxe.Rest"><x path="sunaba.core.Variant"/></x>
		<x path="Void"/>
	</f>
	<meta><m n=":op"><e>a()</e></m></meta>
</call></overloads>
	</callNoArgs>
	<call public="1" set="method" line="21" static="1">
		<f a="this:args">
			<c path="sunaba.core.Event"/>
			<x path="haxe.Rest"><x path="sunaba.core.Variant"/></x>
			<x path="Void"/>
		</f>
		<meta><m n=":op"><e>a()</e></m></meta>
	</call>
</class></impl>
	</abstract>
	<class path="sunaba.core._Event.EventAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Event.hx" private="1" module="sunaba.core.Event" final="1">
		<callNoArgs public="1" set="method" line="16" static="1">
			<f a="this">
				<c path="sunaba.core.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":op"><e>a()</e></m></meta>
			<overloads><call public="1" set="method" line="21">
	<f a="this:args">
		<c path="sunaba.core.Event"/>
		<x path="haxe.Rest"><x path="sunaba.core.Variant"/></x>
		<x path="Void"/>
	</f>
	<meta><m n=":op"><e>a()</e></m></meta>
</call></overloads>
		</callNoArgs>
		<call public="1" set="method" line="21" static="1">
			<f a="this:args">
				<c path="sunaba.core.Event"/>
				<x path="haxe.Rest"><x path="sunaba.core.Variant"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":op"><e>a()</e></m></meta>
		</call>
	</class>
	<class path="sunaba.core.Font" params="" file="G:\sunaba\sunaba/core/Font.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<castFrom public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.core.Font"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<fallbacks public="1"><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.core.Font"/>
</c></fallbacks>
		<getAscent public="1" set="method"><f a="fontSize">
	<x path="Int"/>
	<x path="Float"/>
</f></getAscent>
		<getCharSize public="1" set="method"><f a="chr:fontsize">
	<x path="Int"/>
	<x path="Int"/>
	<c path="sunaba.core.Vector2"/>
</f></getCharSize>
		<getDescent public="1" set="method"><f a="fontSize">
	<x path="Int"/>
	<x path="Float"/>
</f></getDescent>
		<getFaceCount public="1" set="method"><f a=""><x path="Int"/></f></getFaceCount>
		<getFontName public="1" set="method"><f a=""><c path="String"/></f></getFontName>
		<getFontStyle public="1" set="method"><f a=""><x path="Int"/></f></getFontStyle>
		<getFontWeight public="1" set="method"><f a=""><x path="Int"/></f></getFontWeight>
		<getHeight public="1" set="method"><f a="fontSize">
	<x path="Int"/>
	<x path="Float"/>
</f></getHeight>
		<getMultilineStringSize public="1" set="method">
			<f a="text:?alignment:?width:?fontSize:?maxLines:?brkFlags:?justificationFlags:?direction:?orientation" v=":0.0:-1.0:16:-1:3:3:0:0">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="sunaba.core.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ orientation : 0, direction : 0, justificationFlags : 3, brkFlags : 3, maxLines : -1, fontSize : 16, width : -1.0, alignment : 0.0 }</e></m></meta>
		</getMultilineStringSize>
		<getOpentypeFeatures public="1" set="method"><f a=""><c path="sunaba.core.Dictionary"/></f></getOpentypeFeatures>
		<getOtNameStrings public="1" set="method"><f a=""><c path="sunaba.core.Dictionary"/></f></getOtNameStrings>
		<getSpacing public="1" set="method"><f a="spacing">
	<x path="Int"/>
	<x path="Int"/>
</f></getSpacing>
		<getStringSize public="1" set="method">
			<f a="text:?alignment:?width:?fontSize:?justificationFlags:?direction:?orientation" v=":0:0:16:3:0:0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="sunaba.core.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ orientation : 0, direction : 0, justificationFlags : 3, fontSize : 16, width : 0, alignment : 0 }</e></m></meta>
		</getStringSize>
		<getSupportedChars public="1" set="method"><f a=""><c path="String"/></f></getSupportedChars>
		<getSupportedFeatureList public="1" set="method"><f a=""><c path="sunaba.core.Dictionary"/></f></getSupportedFeatureList>
		<getSupportedVariationList public="1" set="method"><f a=""><c path="sunaba.core.Dictionary"/></f></getSupportedVariationList>
		<getUnderlinePosition public="1" set="method"><f a="fontSize">
	<x path="Int"/>
	<x path="Float"/>
</f></getUnderlinePosition>
		<getUnderlineThickness public="1" set="method"><f a="fontSize">
	<x path="Int"/>
	<x path="Float"/>
</f></getUnderlineThickness>
		<hasChar public="1" set="method"><f a="chr">
	<x path="Int"/>
	<x path="Bool"/>
</f></hasChar>
		<isLanguageSupported public="1" set="method"><f a="lang">
	<c path="String"/>
	<x path="Bool"/>
</f></isLanguageSupported>
		<isScriptSupported public="1" set="method"><f a="script">
	<c path="String"/>
	<x path="Bool"/>
</f></isScriptSupported>
		<setCacheCapacity public="1" set="method"><f a="singleline:multiline">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCacheCapacity>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Font"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.core.FontAbstract" params="" file="G:\sunaba\sunaba/core/Font.hx" module="sunaba.core.Font">
		<from>
			<icast><c path="sunaba.core.Font"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.core.Font"/></this>
		<to><icast><c path="sunaba.core.Font"/></icast></to>
		<impl><class path="sunaba.core._Font.FontAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Font.hx" private="1" module="sunaba.core.Font" final="1"><fromResource public="1" set="method" line="34" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.FontAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.core._Font.FontAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Font.hx" private="1" module="sunaba.core.Font" final="1"><fromResource public="1" set="method" line="34" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.FontAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.core.FontFile" params="" file="G:\sunaba\sunaba/core/FontFile.hx" extern="1">
		<extends path="sunaba.core.Font"/>
		<castFrom public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.core.FontFile"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<allowSystemFallback public="1"><x path="Bool"/></allowSystemFallback>
		<antialiasing public="1"><x path="Bool"/></antialiasing>
		<data public="1"><c path="sunaba.core.io.BinaryData"/></data>
		<disableEmbeddedBitmaps public="1"><x path="Bool"/></disableEmbeddedBitmaps>
		<fixedSize public="1"><x path="Bool"/></fixedSize>
		<fixedSizeScaleMode public="1"><x path="Int"/></fixedSizeScaleMode>
		<fontName public="1"><c path="String"/></fontName>
		<fontStretch public="1"><x path="Int"/></fontStretch>
		<fontStyle public="1"><x path="Int"/></fontStyle>
		<fontWeight public="1"><x path="Int"/></fontWeight>
		<forceAutohinter public="1"><x path="Bool"/></forceAutohinter>
		<generateMipmaps public="1"><x path="Bool"/></generateMipmaps>
		<hinting public="1"><x path="Int"/></hinting>
		<msdfPixelRange public="1"><x path="Int"/></msdfPixelRange>
		<msdfSize public="1"><x path="Int"/></msdfSize>
		<multichannelSignedDistanceField public="1"><x path="Bool"/></multichannelSignedDistanceField>
		<opentypeFeatureOverrides public="1"><c path="sunaba.core.Dictionary"/></opentypeFeatureOverrides>
		<oversampling public="1"><x path="Float"/></oversampling>
		<styleName public="1"><c path="String"/></styleName>
		<subpixelPositioning public="1"><x path="Int"/></subpixelPositioning>
		<clearCache public="1" set="method"><f a=""><x path="Void"/></f></clearCache>
		<clearGlyphs public="1" set="method"><f a="cacheIndex:size">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Void"/>
</f></clearGlyphs>
		<clearKerningMap public="1" set="method"><f a="cacheIndex:size">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clearKerningMap>
		<clearSizeCache public="1" set="method"><f a="cacheIndex">
	<x path="Int"/>
	<x path="Void"/>
</f></clearSizeCache>
		<clearTextures public="1" set="method"><f a="cacheIndex:size">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Void"/>
</f></clearTextures>
		<getCacheAscent public="1" set="method"><f a="cacheIndex:size">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getCacheAscent>
		<getCacheCount public="1" set="method"><f a=""><x path="Int"/></f></getCacheCount>
		<getCacheDescent public="1" set="method"><f a="cacheIndex:size">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getCacheDescent>
		<getCacheScale public="1" set="method"><f a="cacheIndex:size">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getCacheScale>
		<getCacheUnderlinePosition public="1" set="method"><f a="cacheIndex:size">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getCacheUnderlinePosition>
		<getCacheUnderlineThickness public="1" set="method"><f a="cacheIndex:size">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getCacheUnderlineThickness>
		<getCharFromGlyphIndex public="1" set="method"><f a="size:glyphIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getCharFromGlyphIndex>
		<getEmbolden public="1" set="method"><f a="cacheIndex">
	<x path="Int"/>
	<x path="Float"/>
</f></getEmbolden>
		<getExtraBaselineOffset public="1" set="method"><f a="cacheIndex">
	<x path="Int"/>
	<x path="Float"/>
</f></getExtraBaselineOffset>
		<getExtraSpacing public="1" set="method"><f a="cacheIndex:spacing">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getExtraSpacing>
		<getFaceIndex public="1" set="method"><f a="cacheIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getFaceIndex>
		<getGlyphAdvance public="1" set="method"><f a="cacheIndex:size:glyphIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="sunaba.core.Vector2"/>
</f></getGlyphAdvance>
		<getGlyphIndex public="1" set="method"><f a="size:chr:variationSelecttor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getGlyphIndex>
		<getGlyphList public="1" set="method"><f a="cacheIndex:size">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<c path="lua.Table">
		<x path="Int"/>
		<x path="Int"/>
	</c>
</f></getGlyphList>
		<getGlyphOffset public="1" set="method"><f a="cacheIndex:size:glyphIndex">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<c path="sunaba.core.Vector2"/>
</f></getGlyphOffset>
		<getGlyphSize public="1" set="method"><f a="cacheIndex:size:glyphIndex">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<c path="sunaba.core.Vector2"/>
</f></getGlyphSize>
		<getGlyphTextureIndex public="1" set="method"><f a="cacheIndex:size:glyphIndex">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getGlyphTextureIndex>
		<getGlyphUvRect public="1" set="method"><f a="cacheIndex:size:glyphIndex">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<c path="sunaba.core.Rect2"/>
</f></getGlyphUvRect>
		<getKerning public="1" set="method"><f a="cacheIndex:size:glyphPair">
	<x path="Int"/>
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<c path="sunaba.core.Vector2"/>
</f></getKerning>
		<getKerningList public="1" set="method"><f a="cacheIndex:size">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="sunaba.core.Vector2i"/>
	</c>
</f></getKerningList>
		<getLanguageSupportOverride public="1" set="method"><f a="lang">
	<c path="String"/>
	<x path="Bool"/>
</f></getLanguageSupportOverride>
		<getScriptSupportOverride public="1" set="method"><f a="script">
	<c path="String"/>
	<x path="Bool"/>
</f></getScriptSupportOverride>
		<getScriptSupportOverrides public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></f></getScriptSupportOverrides>
		<getSizeCacheList public="1" set="method"><f a="cacheIndex">
	<x path="Int"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="sunaba.core.Vector2i"/>
	</c>
</f></getSizeCacheList>
		<getTextureCount public="1" set="method"><f a="cacheIndex:size">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
</f></getTextureCount>
		<getTextureImage public="1" set="method"><f a="cacheIndex:size:textureIndex">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<c path="sunaba.core.Image"/>
</f></getTextureImage>
		<getVariationCoordinates public="1" set="method"><f a="cacheIndex">
	<x path="Int"/>
	<t path="Map">
		<x path="Any"/>
		<x path="Any"/>
	</t>
</f></getVariationCoordinates>
		<loadBitmapFont public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Int"/>
</f></loadBitmapFont>
		<loadDynamicFont public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Int"/>
</f></loadDynamicFont>
		<removeCache public="1" set="method"><f a="cacheIndex">
	<x path="Int"/>
	<x path="Void"/>
</f></removeCache>
		<removeGlyphs public="1" set="method"><f a="cacheIndex:size:glyphIndex">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<x path="Void"/>
</f></removeGlyphs>
		<removeKerning public="1" set="method"><f a="cacheIndex:size:glyphPair">
	<x path="Int"/>
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Void"/>
</f></removeKerning>
		<removeLanguageSupportOverride public="1" set="method"><f a="lang">
	<c path="String"/>
	<x path="Void"/>
</f></removeLanguageSupportOverride>
		<removeScriptSupportOverride public="1" set="method"><f a="script">
	<c path="String"/>
	<x path="Void"/>
</f></removeScriptSupportOverride>
		<removeSizeCache public="1" set="method"><f a="cacheIndex:size">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Void"/>
</f></removeSizeCache>
		<removeTexture public="1" set="method"><f a="cacheIndex:size:textureIndex">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<x path="Void"/>
</f></removeTexture>
		<renderGlyph public="1" set="method"><f a="cacheIndex:size:glyphIndex">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderGlyph>
		<renderRange public="1" set="method"><f a="cacheIndex:size:start:end">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderRange>
		<setCacheAscent public="1" set="method"><f a="cacheIndex:size:ascent">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setCacheAscent>
		<setCacheDescent public="1" set="method"><f a="cacheIndex:size:descent">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setCacheDescent>
		<setCacheScale public="1" set="method"><f a="cacheIndex:size:scale">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setCacheScale>
		<setCacheUnderlinePosition public="1" set="method"><f a="cacheIndex:size:underlinePosition">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setCacheUnderlinePosition>
		<setCacheUnderlineThickness public="1" set="method"><f a="cacheIndex:size:underlineThickness">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setCacheUnderlineThickness>
		<setEmbolden public="1" set="method"><f a="cacheIndex:embolden">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setEmbolden>
		<setExtraBaselineOffset public="1" set="method"><f a="cacheIndex:offset">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setExtraBaselineOffset>
		<setExtraSpacing public="1" set="method"><f a="cacheIndex:spacing:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setExtraSpacing>
		<setFaceIndex public="1" set="method"><f a="cacheIndex:faceIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setFaceIndex>
		<setGlyphAdvance public="1" set="method"><f a="cacheIndex:size:glyphIndex:advance">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="sunaba.core.Vector2"/>
	<x path="Void"/>
</f></setGlyphAdvance>
		<setGlyphOffset public="1" set="method"><f a="cacheIndex:size:glyphIndex:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="sunaba.core.Vector2"/>
	<x path="Void"/>
</f></setGlyphOffset>
		<setGlyphSize public="1" set="method"><f a="cacheIndex:size:glyph:glSize">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<c path="sunaba.core.Vector2"/>
	<x path="Void"/>
</f></setGlyphSize>
		<setGlyphTextureIndex public="1" set="method"><f a="cacheIndex:size:glyphIndex:textureIndex">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setGlyphTextureIndex>
		<setGlyphUvRect public="1" set="method"><f a="cacheIndex:size:glyphIndex:uvRect">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<c path="sunaba.core.Rect2"/>
	<x path="Void"/>
</f></setGlyphUvRect>
		<setKerning public="1" set="method"><f a="cacheIndex:size:glyphPair:kerning">
	<x path="Int"/>
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<c path="sunaba.core.Vector2"/>
	<x path="Void"/>
</f></setKerning>
		<setLanguageSupportOverride public="1" set="method"><f a="lang:supported">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setLanguageSupportOverride>
		<setScriptSupportOverride public="1" set="method"><f a="script:supported">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setScriptSupportOverride>
		<setTextureImage public="1" set="method"><f a="cacheIndex:size:textureIndex:image">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<c path="sunaba.core.Image"/>
	<x path="Void"/>
</f></setTextureImage>
		<setTextureOffsets public="1" set="method"><f a="cacheIndex:size:textureIndex:offsets">
	<x path="Int"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Int"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="sunaba.core.Vector2i"/>
	</c>
	<x path="Void"/>
</f></setTextureOffsets>
		<setVariationCoordinates public="1" set="method"><f a="cacheIndex:coordinates">
	<x path="Int"/>
	<c path="sunaba.core.Dictionary"/>
	<x path="Void"/>
</f></setVariationCoordinates>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"FontFile"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.core.FontFileAbstract" params="" file="G:\sunaba\sunaba/core/FontFile.hx" module="sunaba.core.FontFile">
		<from>
			<icast><c path="sunaba.core.FontFile"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.core.FontFile"/></this>
		<to><icast><c path="sunaba.core.FontFile"/></icast></to>
		<impl><class path="sunaba.core._FontFile.FontFileAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/FontFile.hx" private="1" module="sunaba.core.FontFile" final="1"><fromResource public="1" set="method" line="96" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.FontFileAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.core._FontFile.FontFileAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/FontFile.hx" private="1" module="sunaba.core.FontFile" final="1"><fromResource public="1" set="method" line="96" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.FontFileAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.core.GlobalObjectStack" params="" file="G:\sunaba\sunaba/core/GlobalObjectStack.hx">
		<getSingleton public="1" set="method" line="6" static="1">
			<f a=""><c path="sunaba.core.GlobalObjectStack"/></f>
			<meta><m n=":has_untyped"/></meta>
		</getSingleton>
		<initSingleton public="1" set="method" line="19" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</initSingleton>
		<stack public="1"><c path="Array"><c path="sunaba.core.StackHandle"/></c></stack>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sunaba.core.Image" params="" file="G:\sunaba\sunaba/core/Image.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<create public="1" set="method" static="1">
			<f a="width:height:format:?mipmaps" v=":::false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="sunaba.core.Image"/>
			</f>
			<meta><m n=":value"><e>{ mipmaps : false }</e></m></meta>
		</create>
		<createEmpty public="1" set="method" static="1">
			<f a="width:height:format:?mipmaps" v=":::false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="sunaba.core.Image"/>
			</f>
			<meta><m n=":value"><e>{ mipmaps : false }</e></m></meta>
		</createEmpty>
		<createFromData public="1" set="method" static="1">
			<f a="width:height:format:data:?mipmaps" v="::::false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="sunaba.core.io.BinaryData"/>
				<x path="Bool"/>
				<c path="sunaba.core.Image"/>
			</f>
			<meta><m n=":value"><e>{ mipmaps : false }</e></m></meta>
		</createFromData>
		<loadFromFile public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="sunaba.core.Image"/>
</f></loadFromFile>
		<castFrom public="1" set="method" static="1">
			<f a="res">
				<c path="sunaba.core.Resource"/>
				<c path="sunaba.core.Image"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<adjustBcs public="1" set="method"><f a="brightness:contrast:saturation">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></adjustBcs>
		<blendRect public="1" set="method"><f a="src:rect:dst">
	<c path="sunaba.core.Image"/>
	<c path="sunaba.core.Rect2i"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Void"/>
</f></blendRect>
		<blendRectMask public="1" set="method"><f a="src:mask:rect:dst">
	<c path="sunaba.core.Image"/>
	<c path="sunaba.core.Image"/>
	<c path="sunaba.core.Rect2i"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Void"/>
</f></blendRectMask>
		<blitRect public="1" set="method"><f a="src:rect:dst">
	<c path="sunaba.core.Image"/>
	<c path="sunaba.core.Rect2i"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Void"/>
</f></blitRect>
		<blitRectMask public="1" set="method"><f a="src:mask:rect:dst">
	<c path="sunaba.core.Image"/>
	<c path="sunaba.core.Image"/>
	<c path="sunaba.core.Rect2i"/>
	<c path="sunaba.core.Vector2i"/>
	<x path="Void"/>
</f></blitRectMask>
		<bumpMapToNormalMap public="1" set="method">
			<f a="?bumpScale" v="1.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bumpScale : 1.0 }</e></m></meta>
		</bumpMapToNormalMap>
		<clearMipmaps public="1" set="method"><f a=""><x path="Void"/></f></clearMipmaps>
		<compress public="1" set="method">
			<f a="mode:?source:?astcFormat" v=":0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ astcFormat : 0, source : 0 }</e></m></meta>
		</compress>
		<computeImageMetrics public="1" set="method"><f a="comparedImage:useLuma">
	<c path="sunaba.core.Image"/>
	<x path="Bool"/>
	<c path="sunaba.core.Dictionary"/>
</f></computeImageMetrics>
		<convert public="1" set="method"><f a="format">
	<x path="Int"/>
	<x path="Void"/>
</f></convert>
		<copyFrom public="1" set="method"><f a="src">
	<c path="sunaba.core.Image"/>
	<x path="Void"/>
</f></copyFrom>
		<crop public="1" set="method"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></crop>
		<decompress public="1" set="method"><f a=""><x path="Int"/></f></decompress>
		<detectAlpha public="1" set="method"><f a=""><x path="Void"/></f></detectAlpha>
		<detectUsedChannels public="1" set="method">
			<f a="?source" v="0">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ source : 0 }</e></m></meta>
		</detectUsedChannels>
		<fixAlphaEdges public="1" set="method"><f a=""><x path="Void"/></f></fixAlphaEdges>
		<flipX public="1" set="method"><f a=""><x path="Void"/></f></flipX>
		<flipY public="1" set="method"><f a=""><x path="Void"/></f></flipY>
		<generateMipmaps public="1" set="method">
			<f a="?renormalize" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ renormalize : false }</e></m></meta>
		</generateMipmaps>
		<getData public="1" set="method"><f a=""><c path="sunaba.core.io.BinaryData"/></f></getData>
		<getDataSize public="1" set="method"><f a=""><x path="Int"/></f></getDataSize>
		<getFormat public="1" set="method"><f a=""><x path="Int"/></f></getFormat>
		<getHeight public="1" set="method"><f a=""><x path="Int"/></f></getHeight>
		<getMipmapCount public="1" set="method"><f a=""><x path="Int"/></f></getMipmapCount>
		<getMipmapOffset public="1" set="method"><f a="level">
	<x path="Int"/>
	<x path="Int"/>
</f></getMipmapOffset>
		<getPixel public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<c path="sunaba.core.Color"/>
</f></getPixel>
		<getPixelv public="1" set="method"><f a="p">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Color"/>
</f></getPixelv>
		<getRegion public="1" set="method"><f a="rect">
	<c path="sunaba.core.Rect2i"/>
	<c path="sunaba.core.Image"/>
</f></getRegion>
		<getSize public="1" set="method"><f a=""><c path="sunaba.core.Vector2i"/></f></getSize>
		<getUsedRect public="1" set="method"><f a=""><c path="sunaba.core.Rect2i"/></f></getUsedRect>
		<getWidth public="1" set="method"><f a=""><x path="Int"/></f></getWidth>
		<hasMipmaps public="1" set="method"><f a=""><x path="Bool"/></f></hasMipmaps>
		<isCompressed public="1" set="method"><f a=""><x path="Bool"/></f></isCompressed>
		<isEmpty public="1" set="method"><f a=""><x path="Bool"/></f></isEmpty>
		<isInvisible public="1" set="method"><f a=""><x path="Bool"/></f></isInvisible>
		<load public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Int"/>
</f></load>
		<loadBmpFromBuffer public="1" set="method"><f a="buffer">
	<c path="sunaba.core.io.BinaryData"/>
	<x path="Int"/>
</f></loadBmpFromBuffer>
		<loadJpegFromBuffer public="1" set="method"><f a="buffer">
	<c path="sunaba.core.io.BinaryData"/>
	<x path="Int"/>
</f></loadJpegFromBuffer>
		<loadKtxFromBuffer public="1" set="method"><f a="buffer">
	<c path="sunaba.core.io.BinaryData"/>
	<x path="Int"/>
</f></loadKtxFromBuffer>
		<loadPngFromBuffer public="1" set="method"><f a="buffer">
	<c path="sunaba.core.io.BinaryData"/>
	<x path="Int"/>
</f></loadPngFromBuffer>
		<loadSvgtFromBuffer public="1" set="method"><f a="buffer">
	<c path="sunaba.core.io.BinaryData"/>
	<x path="Int"/>
</f></loadSvgtFromBuffer>
		<loadSvgFromString public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Int"/>
</f></loadSvgFromString>
		<loadTgaFromBuffer public="1" set="method"><f a="buffer">
	<c path="sunaba.core.io.BinaryData"/>
	<x path="Int"/>
</f></loadTgaFromBuffer>
		<loadWebpFromBuffer public="1" set="method"><f a="buffer">
	<c path="sunaba.core.io.BinaryData"/>
	<x path="Int"/>
</f></loadWebpFromBuffer>
		<normalMapToXY public="1" set="method"><f a=""><x path="Void"/></f></normalMapToXY>
		<premultiplyAlpha public="1" set="method"><f a=""><x path="Void"/></f></premultiplyAlpha>
		<resize public="1" set="method">
			<f a="width:height:?interpolation" v="::1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ interpolation : 1 }</e></m></meta>
		</resize>
		<resizeToPo2 public="1" set="method">
			<f a="?square:?interpolation" v="false:1">
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ interpolation : 1, square : false }</e></m></meta>
		</resizeToPo2>
		<rgbeToSrgb public="1" set="method"><f a=""><c path="sunaba.core.Image"/></f></rgbeToSrgb>
		<rotate90 public="1" set="method"><f a="direction">
	<x path="Int"/>
	<x path="Void"/>
</f></rotate90>
		<rotate180 public="1" set="method"><f a=""><x path="Void"/></f></rotate180>
		<saveRxr public="1" set="method">
			<f a="path:?grayscale" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ grayscale : false }</e></m></meta>
		</saveRxr>
		<saveRxrToBuffer public="1" set="method">
			<f a="?grayscale" v="false">
				<x path="Bool"/>
				<c path="sunaba.core.io.BinaryData"/>
			</f>
			<meta><m n=":value"><e>{ grayscale : false }</e></m></meta>
		</saveRxrToBuffer>
		<saveJpeg public="1" set="method">
			<f a="path:?quality" v=":100">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ quality : 100 }</e></m></meta>
		</saveJpeg>
		<saveJpegToBuffer public="1" set="method">
			<f a="?quality" v="100">
				<x path="Int"/>
				<c path="sunaba.core.io.BinaryData"/>
			</f>
			<meta><m n=":value"><e>{ quality : 100 }</e></m></meta>
		</saveJpegToBuffer>
		<savePng public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Int"/>
</f></savePng>
		<savePngToBuffer public="1" set="method"><f a=""><c path="sunaba.core.io.BinaryData"/></f></savePngToBuffer>
		<saveWebp public="1" set="method">
			<f a="path:?lossy:?quality" v=":false:0.75">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ quality : 0.75, lossy : false }</e></m></meta>
		</saveWebp>
		<saveWebpToBuffer public="1" set="method">
			<f a="?lossy:?quality" v="false:0.75">
				<x path="Bool"/>
				<x path="Float"/>
				<c path="sunaba.core.io.BinaryData"/>
			</f>
			<meta><m n=":value"><e>{ quality : 0.75, lossy : false }</e></m></meta>
		</saveWebpToBuffer>
		<setData public="1" set="method"><f a="width:height:useMipmaps:format:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="sunaba.core.io.BinaryData"/>
	<x path="Void"/>
</f></setData>
		<setPixel public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<c path="sunaba.core.Color"/>
	<x path="Void"/>
</f></setPixel>
		<setPixelv public="1" set="method"><f a="p:color">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Color"/>
	<x path="Void"/>
</f></setPixelv>
		<shrinkX2 public="1" set="method"><f a=""><x path="Void"/></f></shrinkX2>
		<srgbToLinear public="1" set="method"><f a=""><x path="Void"/></f></srgbToLinear>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Image"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.core.ImageAbstarct" params="" file="G:\sunaba\sunaba/core/Image.hx" module="sunaba.core.Image">
		<from>
			<icast><c path="sunaba.core.Image"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.core.Image"/></this>
		<to><icast><c path="sunaba.core.Image"/></icast></to>
		<impl><class path="sunaba.core._Image.ImageAbstarct_Impl_" params="" file="G:\sunaba\sunaba/core/Image.hx" private="1" module="sunaba.core.Image" final="1"><fromResource public="1" set="method" line="83" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.ImageAbstarct"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.core._Image.ImageAbstarct_Impl_" params="" file="G:\sunaba\sunaba/core/Image.hx" private="1" module="sunaba.core.Image" final="1"><fromResource public="1" set="method" line="83" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.ImageAbstarct"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.core.Texture" params="" file="G:\sunaba\sunaba/core/Texture.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<castFrom public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.core.Texture"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Texture"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.Texture2D" params="" file="G:\sunaba\sunaba/core/Texture2D.hx" extern="1">
		<extends path="sunaba.core.Texture"/>
		<castFrom public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.core.Texture2D"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<createPlaceholder public="1" set="method"><f a=""><c path="sunaba.core.Resource"/></f></createPlaceholder>
		<getHeight public="1" set="method"><f a=""><x path="Int"/></f></getHeight>
		<getImage public="1" set="method"><f a=""><c path="sunaba.core.Image"/></f></getImage>
		<getSize public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></getSize>
		<getWidth public="1" set="method"><f a=""><x path="Int"/></f></getWidth>
		<hasAlpha public="1" set="method"><f a=""><x path="Bool"/></f></hasAlpha>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Texture2D"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.ImageTexture" params="" file="G:\sunaba\sunaba/core/ImageTexture.hx" extern="1">
		<extends path="sunaba.core.Texture2D"/>
		<createFromImage public="1" set="method" static="1"><f a="image">
	<c path="sunaba.core.Image"/>
	<c path="sunaba.core.ImageTexture"/>
</f></createFromImage>
		<castFrom public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.core.ImageTexture"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<image public="1"><c path="sunaba.core.Image"/></image>
		<getFormat public="1" set="method"><f a=""><x path="Int"/></f></getFormat>
		<setSizeOverride public="1" set="method"><f a="size">
	<c path="sunaba.core.Vector2"/>
	<x path="Void"/>
</f></setSizeOverride>
		<update public="1" set="method"><f a="image">
	<c path="sunaba.core.Image"/>
	<x path="Void"/>
</f></update>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"ImageTexture"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.core.ImageTextureAbstract" params="" file="G:\sunaba\sunaba/core/ImageTexture.hx" module="sunaba.core.ImageTexture">
		<from>
			<icast><c path="sunaba.core.ImageTexture"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.core.ImageTexture"/></this>
		<to><icast><c path="sunaba.core.ImageTexture"/></icast></to>
		<impl><class path="sunaba.core._ImageTexture.ImageTextureAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/ImageTexture.hx" private="1" module="sunaba.core.ImageTexture" final="1"><fromResource public="1" set="method" line="16" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.ImageTextureAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.core._ImageTexture.ImageTextureAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/ImageTexture.hx" private="1" module="sunaba.core.ImageTexture" final="1"><fromResource public="1" set="method" line="16" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.ImageTextureAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.core.LabelSettings" params="" file="G:\sunaba\sunaba/core/LabelSettings.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<castFrom public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.core.LabelSettings"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<font public="1"><c path="sunaba.core.Font"/></font>
		<fontColor public="1"><c path="sunaba.core.Color"/></fontColor>
		<fontSize public="1"><x path="Float"/></fontSize>
		<lineSpacing public="1"><x path="Float"/></lineSpacing>
		<outlineColor public="1"><c path="sunaba.core.Color"/></outlineColor>
		<outlineSize public="1"><x path="Float"/></outlineSize>
		<shadowColor public="1"><c path="sunaba.core.Color"/></shadowColor>
		<shadowOffset public="1"><x path="Float"/></shadowOffset>
		<shadowSize public="1"><x path="Float"/></shadowSize>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"LabelSettings"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.core.LabelSettingsAbstract" params="" file="G:\sunaba\sunaba/core/LabelSettings.hx" module="sunaba.core.LabelSettings">
		<from>
			<icast><c path="sunaba.core.LabelSettings"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.core.LabelSettings"/></this>
		<to><icast><c path="sunaba.core.LabelSettings"/></icast></to>
		<impl><class path="sunaba.core._LabelSettings.LabelSettingsAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/LabelSettings.hx" private="1" module="sunaba.core.LabelSettings" final="1"><fromResource public="1" set="method" line="20" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.LabelSettingsAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.core._LabelSettings.LabelSettingsAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/LabelSettings.hx" private="1" module="sunaba.core.LabelSettings" final="1"><fromResource public="1" set="method" line="20" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.LabelSettingsAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.core.Material" params="" file="G:\sunaba\sunaba/core/Material.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<castFrom public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.core.Material"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<nextPass public="1"><c path="sunaba.core.Material"/></nextPass>
		<renderPriority public="1"><x path="Int"/></renderPriority>
		<createPlaceholder public="1" set="method"><f a=""><c path="sunaba.core.Resource"/></f></createPlaceholder>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Material"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.core.MaterialAbstract" params="" file="G:\sunaba\sunaba/core/Material.hx" module="sunaba.core.Material">
		<from>
			<icast><c path="sunaba.core.Material"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.core.Material"/></this>
		<to><icast><c path="sunaba.core.Material"/></icast></to>
		<impl><class path="sunaba.core._Material.MaterialAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Material.hx" private="1" module="sunaba.core.Material" final="1"><fromResource public="1" set="method" line="14" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.MaterialAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.core._Material.MaterialAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Material.hx" private="1" module="sunaba.core.Material" final="1"><fromResource public="1" set="method" line="14" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.MaterialAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.core.Quaternion" params="" file="G:\sunaba\sunaba/core/Quaternion.hx" extern="1">
		<zero public="1" set="method" static="1">
			<f a=""><c path="sunaba.core.Quaternion"/></f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</zero>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<w public="1"><x path="Float"/></w>
		<angleTo public="1" set="method"><f a="quat">
	<c path="sunaba.core.Quaternion"/>
	<x path="Float"/>
</f></angleTo>
		<dot public="1" set="method"><f a="q">
	<c path="sunaba.core.Quaternion"/>
	<x path="Float"/>
</f></dot>
		<exp public="1" set="method"><f a=""><c path="sunaba.core.Quaternion"/></f></exp>
		<inverse public="1" set="method"><f a=""><c path="sunaba.core.Quaternion"/></f></inverse>
		<isEqualApprox public="1" set="method"><f a="quat">
	<c path="sunaba.core.Quaternion"/>
	<x path="Bool"/>
</f></isEqualApprox>
		<isNormalized public="1" set="method"><f a=""><x path="Bool"/></f></isNormalized>
		<length public="1" set="method"><f a=""><x path="Float"/></f></length>
		<lengthSquared public="1" set="method"><f a=""><x path="Float"/></f></lengthSquared>
		<log public="1" set="method"><f a=""><c path="sunaba.core.Quaternion"/></f></log>
		<normalized public="1" set="method"><f a=""><c path="sunaba.core.Quaternion"/></f></normalized>
		<slerp public="1" set="method"><f a="to:weight">
	<c path="sunaba.core.Quaternion"/>
	<x path="Float"/>
	<c path="sunaba.core.Quaternion"/>
</f></slerp>
		<sphericalCubicInterpolate public="1" set="method"><f a="b:preA:postB:weight">
	<c path="sunaba.core.Quaternion"/>
	<c path="sunaba.core.Quaternion"/>
	<c path="sunaba.core.Quaternion"/>
	<x path="Float"/>
	<c path="sunaba.core.Quaternion"/>
</f></sphericalCubicInterpolate>
		<sphericalCubicInterpolateInTime public="1" set="method"><f a="b:preA:postB:weight:bT:preAT:postBT">
	<c path="sunaba.core.Quaternion"/>
	<c path="sunaba.core.Quaternion"/>
	<c path="sunaba.core.Quaternion"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="sunaba.core.Quaternion"/>
</f></sphericalCubicInterpolateInTime>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"tostring"</e></m></meta>
		</toString>
		<new public="1" set="method"><f a="x:y:z:w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"Quaternion"</e></m></meta>
	</class>
	<class path="sunaba.core.Rect2" params="" file="G:\sunaba\sunaba/core/Rect2.hx" extern="1">
		<fromVector2s public="1" set="method" static="1">
			<f a="position:size">
				<c path="sunaba.core.Vector2"/>
				<c path="sunaba.core.Vector2"/>
				<c path="sunaba.core.Rect2"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromVector2s>
		<fromFloats public="1" set="method" static="1">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="sunaba.core.Rect2"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromFloats>
		<fromRect2is public="1" set="method" static="1">
			<f a="rect">
				<c path="sunaba.core.Rect2i"/>
				<c path="sunaba.core.Rect2"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromRect2is>
		<end public="1"><c path="sunaba.core.Vector2"/></end>
		<position public="1"><c path="sunaba.core.Vector2"/></position>
		<size public="1"><c path="sunaba.core.Vector2"/></size>
		<abs public="1" set="method"><f a=""><c path="sunaba.core.Rect2"/></f></abs>
		<encloses public="1" set="method"><f a="rect">
	<c path="sunaba.core.Rect2"/>
	<x path="Bool"/>
</f></encloses>
		<expand public="1" set="method"><f a="vector">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Rect2"/>
</f></expand>
		<getArea public="1" set="method"><f a=""><x path="Float"/></f></getArea>
		<getCenter public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></getCenter>
		<grow public="1" set="method"><f a="amount">
	<x path="Float"/>
	<c path="sunaba.core.Rect2"/>
</f></grow>
		<growIndividual public="1" set="method"><f a="left:top:right:bottom">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="sunaba.core.Rect2"/>
</f></growIndividual>
		<growSide public="1" set="method"><f a="side:amount">
	<x path="Int"/>
	<x path="Float"/>
	<c path="sunaba.core.Rect2"/>
</f></growSide>
		<hasArea public="1" set="method"><f a=""><x path="Bool"/></f></hasArea>
		<hasPoint public="1" set="method"><f a="point">
	<c path="sunaba.core.Vector2"/>
	<x path="Bool"/>
</f></hasPoint>
		<intersetion public="1" set="method"><f a="rect">
	<c path="sunaba.core.Rect2"/>
	<c path="sunaba.core.Rect2"/>
</f></intersetion>
		<intersects public="1" set="method">
			<f a="rect:?includeBorders" v=":false">
				<c path="sunaba.core.Rect2"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ includeBorders : false }</e></m></meta>
		</intersects>
		<isEqualApprox public="1" set="method"><f a="rect">
	<c path="sunaba.core.Rect2"/>
	<x path="Bool"/>
</f></isEqualApprox>
		<merge public="1" set="method"><f a="rect">
	<c path="sunaba.core.Rect2"/>
	<c path="sunaba.core.Rect2"/>
</f></merge>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"tostring"</e></m></meta>
		</toString>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":native"><e>"Rect2"</e></m></meta>
	</class>
	<class path="sunaba.core.Rect2i" params="" file="G:\sunaba\sunaba/core/Rect2i.hx" extern="1">
		<fromVector2is public="1" set="method" static="1">
			<f a="position:size">
				<c path="sunaba.core.Vector2i"/>
				<c path="sunaba.core.Vector2i"/>
				<c path="sunaba.core.Rect2i"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromVector2is>
		<fromInts public="1" set="method" static="1">
			<f a="x:y:width:height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="sunaba.core.Rect2i"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromInts>
		<fromRect2s public="1" set="method" static="1">
			<f a="rect">
				<c path="sunaba.core.Rect2"/>
				<c path="sunaba.core.Rect2i"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromRect2s>
		<end public="1"><c path="sunaba.core.Vector2i"/></end>
		<position public="1"><c path="sunaba.core.Vector2i"/></position>
		<size public="1"><c path="sunaba.core.Vector2i"/></size>
		<abs public="1" set="method"><f a=""><c path="sunaba.core.Rect2i"/></f></abs>
		<encloses public="1" set="method"><f a="rect">
	<c path="sunaba.core.Rect2i"/>
	<x path="Bool"/>
</f></encloses>
		<expand public="1" set="method"><f a="vector">
	<c path="sunaba.core.Vector2i"/>
	<c path="sunaba.core.Rect2i"/>
</f></expand>
		<getArea public="1" set="method"><f a=""><x path="Int"/></f></getArea>
		<getCenter public="1" set="method"><f a=""><c path="sunaba.core.Vector2i"/></f></getCenter>
		<grow public="1" set="method"><f a="amount">
	<x path="Int"/>
	<c path="sunaba.core.Rect2i"/>
</f></grow>
		<growIndividual public="1" set="method"><f a="left:top:right:bottom">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="sunaba.core.Rect2i"/>
</f></growIndividual>
		<growSide public="1" set="method"><f a="side:amount">
	<x path="Int"/>
	<x path="Int"/>
	<c path="sunaba.core.Rect2i"/>
</f></growSide>
		<hasArea public="1" set="method"><f a=""><x path="Bool"/></f></hasArea>
		<hasPoint public="1" set="method"><f a="point">
	<c path="sunaba.core.Vector2i"/>
	<x path="Bool"/>
</f></hasPoint>
		<intersetion public="1" set="method"><f a="rect">
	<c path="sunaba.core.Rect2i"/>
	<c path="sunaba.core.Rect2i"/>
</f></intersetion>
		<intersects public="1" set="method">
			<f a="rect:?includeBorders" v=":false">
				<c path="sunaba.core.Rect2i"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ includeBorders : false }</e></m></meta>
		</intersects>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"tostring"</e></m></meta>
		</toString>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":native"><e>"Rect2i"</e></m></meta>
	</class>
	<class path="sunaba.core.RegEx" params="" file="G:\sunaba\sunaba/core/RegEx.hx" extern="1">
		<extends path="sunaba.core.BaseObject"/>
		<compile public="1" set="method"><f a="pattern:?showError">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></compile>
		<createFromString public="1" set="method"><f a="pattern:?showError">
	<c path="String"/>
	<x path="Bool"/>
	<c path="sunaba.core.RegEx"/>
</f></createFromString>
		<getGroupCount public="1" set="method"><f a=""><x path="Int"/></f></getGroupCount>
		<getNames public="1" set="method"><f a=""><x path="sunaba.core.StringArray"/></f></getNames>
		<getPattern public="1" set="method"><f a=""><c path="String"/></f></getPattern>
		<isValid public="1" set="method"><f a=""><x path="Bool"/></f></isValid>
		<search public="1" set="method"><f a="subject:?offset:?end">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="sunaba.core.RegExMatch"/>
</f></search>
		<searchAll public="1" set="method"><f a="subject:?offset:?end">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="sunaba.core.RegExMatch"/>
	</c>
</f></searchAll>
		<sub public="1" set="method"><f a="subject:replacemtn:?all:?offset:?end">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></sub>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"RegEx"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.RegExMatch" params="" file="G:\sunaba\sunaba/core/RegExMatch.hx" extern="1">
		<extends path="sunaba.core.BaseObject"/>
		<names public="1"><c path="sunaba.core.Dictionary"/></names>
		<strings public="1"><x path="sunaba.core.StringArray"/></strings>
		<subject public="1"><c path="String"/></subject>
		<getEnd public="1" set="method"><f a="?name">
	<x path="sunaba.core.Variant"/>
	<x path="Int"/>
</f></getEnd>
		<getGroupCount public="1" set="method"><f a=""><x path="Int"/></f></getGroupCount>
		<getStart public="1" set="method"><f a="?name">
	<x path="sunaba.core.Variant"/>
	<x path="Int"/>
</f></getStart>
		<getString public="1" set="method"><f a="?name">
	<x path="sunaba.core.Variant"/>
	<c path="String"/>
</f></getString>
		<isValid public="1" set="method"><f a=""><x path="Bool"/></f></isValid>
		<isNull public="1" set="method"><f a=""><x path="Bool"/></f></isNull>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":native"><e>"RegExMatch"</e></m></meta>
	</class>
	<abstract path="sunaba.core.ResourceAbstarct" params="" file="G:\sunaba\sunaba/core/Resource.hx" module="sunaba.core.Resource">
		<from>
			<icast><c path="sunaba.core.Resource"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.core.Resource"/></this>
		<to><icast><c path="sunaba.core.Resource"/></icast></to>
		<impl><class path="sunaba.core._Resource.ResourceAbstarct_Impl_" params="" file="G:\sunaba\sunaba/core/Resource.hx" private="1" module="sunaba.core.Resource" final="1"><fromResource public="1" set="method" line="15" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.ResourceAbstarct"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.core._Resource.ResourceAbstarct_Impl_" params="" file="G:\sunaba\sunaba/core/Resource.hx" private="1" module="sunaba.core.Resource" final="1"><fromResource public="1" set="method" line="15" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.ResourceAbstarct"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.core.StackHandle" params="" file="G:\sunaba\sunaba/core/StackHandle.hx">
		<object public="1"><d/></object>
		<new public="1" set="method" line="6"><f a="object">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="sunaba.core.StringArray" params="" file="G:\sunaba\sunaba/core/StringArray.hx">
		<from>
			<icast><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></icast>
			<icast field="fromArray"><c path="Array"><c path="String"/></c></icast>
		</from>
		<this><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></this>
		<to>
			<icast><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></icast>
			<icast field="toArray"><c path="Array"><c path="String"/></c></icast>
		</to>
		<impl><class path="sunaba.core._StringArray.StringArray_Impl_" params="" file="G:\sunaba\sunaba/core/StringArray.hx" private="1" module="sunaba.core.StringArray" final="1">
	<toArray public="1" get="inline" set="null" line="7" static="1">
		<f a="this">
			<c path="lua.Table">
				<x path="Int"/>
				<c path="String"/>
			</c>
			<c path="Array"><c path="String"/></c>
		</f>
		<meta><m n=":to"/></meta>
	</toArray>
	<fromArray public="1" set="method" line="13" static="1">
		<f a="array">
			<c path="Array"><c path="String"/></c>
			<x path="sunaba.core.StringArray"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromArray>
</class></impl>
	</abstract>
	<class path="sunaba.core._StringArray.StringArray_Impl_" params="" file="G:\sunaba\sunaba/core/StringArray.hx" private="1" module="sunaba.core.StringArray" final="1">
		<toArray public="1" get="inline" set="null" line="7" static="1">
			<f a="this">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="String"/>
				</c>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":to"/></meta>
		</toArray>
		<fromArray public="1" set="method" line="13" static="1">
			<f a="array">
				<c path="Array"><c path="String"/></c>
				<x path="sunaba.core.StringArray"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromArray>
	</class>
	<abstract path="sunaba.core.TextureAbstract" params="" file="G:\sunaba\sunaba/core/Texture.hx" module="sunaba.core.Texture">
		<from>
			<icast><c path="sunaba.core.Texture"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.core.Texture"/></this>
		<to><icast><c path="sunaba.core.Texture"/></icast></to>
		<impl><class path="sunaba.core._Texture.TextureAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Texture.hx" private="1" module="sunaba.core.Texture" final="1"><fromResource public="1" set="method" line="11" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.TextureAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.core._Texture.TextureAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Texture.hx" private="1" module="sunaba.core.Texture" final="1"><fromResource public="1" set="method" line="11" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.TextureAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<abstract path="sunaba.core.Texture2DAbstract" params="" file="G:\sunaba\sunaba/core/Texture2D.hx" module="sunaba.core.Texture2D">
		<from>
			<icast><c path="sunaba.core.Texture2D"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.core.Texture2D"/></this>
		<to><icast><c path="sunaba.core.Texture2D"/></icast></to>
		<impl><class path="sunaba.core._Texture2D.Texture2DAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Texture2D.hx" private="1" module="sunaba.core.Texture2D" final="1"><fromResource public="1" set="method" line="17" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.Texture2DAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.core._Texture2D.Texture2DAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Texture2D.hx" private="1" module="sunaba.core.Texture2D" final="1"><fromResource public="1" set="method" line="17" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.core.Texture2DAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.core.Transform2D" params="" file="G:\sunaba\sunaba/core/Transform2D.hx" extern="1">
		<zero public="1" set="method" static="1">
			<f a=""><c path="sunaba.core.Transform2D"/></f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</zero>
		<newWithScaleAndSkew public="1" set="method" static="1">
			<f a="rotation:scale:skew:position">
				<x path="Float"/>
				<c path="sunaba.core.Vector2"/>
				<x path="Float"/>
				<c path="sunaba.core.Vector2"/>
				<c path="sunaba.core.Transform2D"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</newWithScaleAndSkew>
		<fromXYOrigin public="1" set="method" static="1">
			<f a="x:y:origin">
				<c path="sunaba.core.Vector2"/>
				<c path="sunaba.core.Vector2"/>
				<c path="sunaba.core.Vector2"/>
				<c path="sunaba.core.Transform2D"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromXYOrigin>
		<origin public="1"><c path="sunaba.core.Vector2"/></origin>
		<x public="1"><c path="sunaba.core.Vector2"/></x>
		<y public="1"><c path="sunaba.core.Vector2"/></y>
		<affineInverse public="1" set="method"><f a=""><c path="sunaba.core.Transform2D"/></f></affineInverse>
		<basisXform public="1" set="method"><f a="v">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
</f></basisXform>
		<basisXformInv public="1" set="method"><f a="v">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
</f></basisXformInv>
		<determinant public="1" set="method"><f a=""><x path="Float"/></f></determinant>
		<getOrigin public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></getOrigin>
		<getRotation public="1" set="method"><f a=""><x path="Float"/></f></getRotation>
		<getScale public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></getScale>
		<getSkew public="1" set="method"><f a=""><x path="Float"/></f></getSkew>
		<interpolateWith public="1" set="method"><f a="xform:weight">
	<c path="sunaba.core.Transform2D"/>
	<x path="Float"/>
	<c path="sunaba.core.Transform2D"/>
</f></interpolateWith>
		<inverse public="1" set="method"><f a=""><c path="sunaba.core.Transform2D"/></f></inverse>
		<isConformal public="1" set="method"><f a=""><x path="Bool"/></f></isConformal>
		<isEqualApprox public="1" set="method"><f a="xform">
	<c path="sunaba.core.Transform2D"/>
	<x path="Bool"/>
</f></isEqualApprox>
		<isFinite public="1" set="method"><f a=""><x path="Bool"/></f></isFinite>
		<lookingAt public="1" set="method"><f a="?target">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Transform2D"/>
</f></lookingAt>
		<orthonormalized public="1" set="method"><f a=""><c path="sunaba.core.Transform2D"/></f></orthonormalized>
		<rotated public="1" set="method"><f a="angle">
	<x path="Float"/>
	<c path="sunaba.core.Transform2D"/>
</f></rotated>
		<rotatedLocal public="1" set="method"><f a="angle">
	<x path="Float"/>
	<c path="sunaba.core.Transform2D"/>
</f></rotatedLocal>
		<scaled public="1" set="method"><f a="scale">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Transform2D"/>
</f></scaled>
		<scaledLocal public="1" set="method"><f a="scale">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Transform2D"/>
</f></scaledLocal>
		<translated public="1" set="method"><f a="translation">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Transform2D"/>
</f></translated>
		<translatedLocal public="1" set="method"><f a="translation">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Transform2D"/>
</f></translatedLocal>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"tostring"</e></m></meta>
		</toString>
		<new public="1" set="method"><f a="rotation:position">
	<x path="Float"/>
	<c path="sunaba.core.Vector2"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"Transform2D"</e></m></meta>
	</class>
	<class path="sunaba.core.Transform3D" params="" file="G:\sunaba\sunaba/core/Transform3D.hx" extern="1">
		<zero public="1" set="method" static="1">
			<f a=""><c path="sunaba.core.Transform3D"/></f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</zero>
		<basis public="1"><c path="sunaba.core.Basis"/></basis>
		<origin public="1"><c path="sunaba.core.Vector3"/></origin>
		<affineInverse public="1" set="method"><f a=""><c path="sunaba.core.Transform3D"/></f></affineInverse>
		<interpolateWith public="1" set="method"><f a="tform:c">
	<c path="sunaba.core.Transform3D"/>
	<x path="Float"/>
	<c path="sunaba.core.Transform3D"/>
</f></interpolateWith>
		<isEqualApprox public="1" set="method"><f a="tform">
	<c path="sunaba.core.Transform3D"/>
	<x path="Bool"/>
</f></isEqualApprox>
		<lookingAt public="1" set="method"><f a="target:up">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Transform3D"/>
</f></lookingAt>
		<orthonormalized public="1" set="method"><f a=""><c path="sunaba.core.Transform3D"/></f></orthonormalized>
		<rotated public="1" set="method"><f a="axis:angle">
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
	<c path="sunaba.core.Transform3D"/>
</f></rotated>
		<rotatedLocal public="1" set="method"><f a="axis:angle">
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
	<c path="sunaba.core.Transform3D"/>
</f></rotatedLocal>
		<scaled public="1" set="method"><f a="scale">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Transform3D"/>
</f></scaled>
		<scaledLocal public="1" set="method"><f a="scale">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Transform3D"/>
</f></scaledLocal>
		<translated public="1" set="method"><f a="translation">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Transform3D"/>
</f></translated>
		<translatedLocal public="1" set="method"><f a="translation">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Transform3D"/>
</f></translatedLocal>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"tostring"</e></m></meta>
		</toString>
		<new public="1" set="method"><f a="basis:origin">
	<c path="sunaba.core.Basis"/>
	<c path="sunaba.core.Vector3"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"Transform3D"</e></m></meta>
	</class>
	<abstract path="sunaba.core.Variant" params="" file="G:\sunaba\sunaba/core/Variant.hx">
		<from>
			<icast><c path="sunaba.core.VariantNative"/></icast>
			<icast field="fromString"><c path="String"/></icast>
			<icast field="fromInt"><x path="Int"/></icast>
			<icast field="fromInt64"><x path="haxe.Int64"/></icast>
			<icast field="fromInt32"><x path="haxe.Int32"/></icast>
			<icast field="fromFloat"><x path="Float"/></icast>
			<icast field="fromBool"><x path="Bool"/></icast>
			<icast field="fromVector2"><c path="sunaba.core.Vector2"/></icast>
			<icast field="fromVector3"><c path="sunaba.core.Vector3"/></icast>
			<icast field="fromVector4"><c path="sunaba.core.Vector4"/></icast>
			<icast field="fromVector2i"><c path="sunaba.core.Vector2i"/></icast>
			<icast field="fromVector3i"><c path="sunaba.core.Vector3i"/></icast>
			<icast field="fromVector4i"><c path="sunaba.core.Vector4i"/></icast>
			<icast field="fromColor"><c path="sunaba.core.Color"/></icast>
			<icast field="fromRect2"><c path="sunaba.core.Rect2"/></icast>
			<icast field="fromRect2i"><c path="sunaba.core.Rect2i"/></icast>
			<icast field="fromBasis"><c path="sunaba.core.Basis"/></icast>
			<icast field="fromTransform2D"><c path="sunaba.core.Transform2D"/></icast>
			<icast field="fromTransform3D"><c path="sunaba.core.Transform3D"/></icast>
			<icast field="fromQuaternion"><c path="sunaba.core.Quaternion"/></icast>
			<icast field="fromElement"><c path="sunaba.core.Element"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
			<icast field="fromByteArray"><c path="sunaba.core.io.BinaryData"/></icast>
			<icast field="fromIntArray64"><c path="lua.Table">
	<x path="Int"/>
	<x path="Int"/>
</c></icast>
			<icast field="fromFloatArray64"><c path="lua.Table">
	<x path="Int"/>
	<x path="Float"/>
</c></icast>
			<icast field="fromStringArray"><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></icast>
			<icast field="fromVector2Array"><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.core.Vector2"/>
</c></icast>
			<icast field="fromVector3Array"><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.core.Vector3"/>
</c></icast>
			<icast field="fromVector4Array"><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.core.Vector4"/>
</c></icast>
		</from>
		<this><c path="sunaba.core.VariantNative"/></this>
		<to>
			<icast><c path="sunaba.core.VariantNative"/></icast>
			<icast field="toString"><c path="String"/></icast>
			<icast field="toInt"><x path="haxe.Int64"/></icast>
			<icast field="toInt64"><x path="haxe.Int64"/></icast>
			<icast field="toInt32"><x path="haxe.Int32"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
			<icast field="toBool"><x path="Bool"/></icast>
			<icast field="toVector2"><c path="sunaba.core.Vector2"/></icast>
			<icast field="toVector3"><c path="sunaba.core.Vector3"/></icast>
			<icast field="toVector4"><c path="sunaba.core.Vector4"/></icast>
			<icast field="toVector2i"><c path="sunaba.core.Vector2i"/></icast>
			<icast field="toVector3i"><c path="sunaba.core.Vector3i"/></icast>
			<icast field="toVector4i"><c path="sunaba.core.Vector4i"/></icast>
			<icast field="toColor"><c path="sunaba.core.Color"/></icast>
			<icast field="toRect2"><c path="sunaba.core.Rect2"/></icast>
			<icast field="toRect2i"><c path="sunaba.core.Rect2i"/></icast>
			<icast field="toBasis"><c path="sunaba.core.Basis"/></icast>
			<icast field="toTransform2D"><c path="sunaba.core.Transform2D"/></icast>
			<icast field="toTransform3D"><c path="sunaba.core.Transform3D"/></icast>
			<icast field="toQuaternion"><c path="sunaba.core.Quaternion"/></icast>
			<icast field="toElement"><c path="sunaba.core.Element"/></icast>
			<icast field="toResource"><c path="sunaba.core.Resource"/></icast>
			<icast field="toByteArray"><c path="sunaba.core.io.BinaryData"/></icast>
			<icast field="toIntArray64"><c path="lua.Table">
	<x path="Int"/>
	<x path="Int"/>
</c></icast>
			<icast field="toFloatArray64"><c path="lua.Table">
	<x path="Int"/>
	<x path="Float"/>
</c></icast>
			<icast field="toStringArray"><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></icast>
			<icast field="toVector2Array"><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.core.Vector2"/>
</c></icast>
			<icast field="toVector3Array"><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.core.Vector3"/>
</c></icast>
			<icast field="toVector4Array"><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.core.Vector4"/>
</c></icast>
		</to>
		<impl><class path="sunaba.core._Variant.Variant_Impl_" params="" file="G:\sunaba\sunaba/core/Variant.hx" private="1" module="sunaba.core.Variant" final="1">
	<fromString public="1" set="method" line="10" static="1">
		<f a="value">
			<c path="String"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString public="1" get="inline" set="null" line="14" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="String"/>
		</f>
		<meta><m n=":to"/></meta>
	</toString>
	<fromInt public="1" set="method" line="18" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<toInt public="1" get="inline" set="null" line="22" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":to"/></meta>
	</toInt>
	<fromInt64 public="1" set="method" line="26" static="1">
		<f a="value">
			<x path="haxe.Int64"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt64>
	<toInt64 public="1" get="inline" set="null" line="30" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":to"/></meta>
	</toInt64>
	<fromInt32 public="1" set="method" line="34" static="1">
		<f a="value">
			<x path="haxe.Int32"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt32>
	<toInt32 public="1" get="inline" set="null" line="38" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":to"/></meta>
	</toInt32>
	<fromFloat public="1" set="method" line="42" static="1">
		<f a="value">
			<x path="Float"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromFloat>
	<toFloat public="1" get="inline" set="null" line="46" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<x path="Float"/>
		</f>
		<meta><m n=":to"/></meta>
	</toFloat>
	<fromBool public="1" set="method" line="50" static="1">
		<f a="value">
			<x path="Bool"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromBool>
	<toBool public="1" get="inline" set="null" line="54" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":to"/></meta>
	</toBool>
	<fromVector2 public="1" set="method" line="58" static="1">
		<f a="value">
			<c path="sunaba.core.Vector2"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromVector2>
	<toVector2 public="1" get="inline" set="null" line="62" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Vector2"/>
		</f>
		<meta><m n=":to"/></meta>
	</toVector2>
	<fromVector3 public="1" set="method" line="66" static="1">
		<f a="value">
			<c path="sunaba.core.Vector3"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromVector3>
	<toVector3 public="1" get="inline" set="null" line="70" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Vector3"/>
		</f>
		<meta><m n=":to"/></meta>
	</toVector3>
	<fromVector4 public="1" set="method" line="74" static="1">
		<f a="value">
			<c path="sunaba.core.Vector4"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromVector4>
	<toVector4 public="1" get="inline" set="null" line="78" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Vector4"/>
		</f>
		<meta><m n=":to"/></meta>
	</toVector4>
	<fromVector2i public="1" set="method" line="82" static="1">
		<f a="value">
			<c path="sunaba.core.Vector2i"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromVector2i>
	<toVector2i public="1" get="inline" set="null" line="86" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Vector2i"/>
		</f>
		<meta><m n=":to"/></meta>
	</toVector2i>
	<fromVector3i public="1" set="method" line="90" static="1">
		<f a="value">
			<c path="sunaba.core.Vector3i"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromVector3i>
	<toVector3i public="1" get="inline" set="null" line="94" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Vector3i"/>
		</f>
		<meta><m n=":to"/></meta>
	</toVector3i>
	<fromVector4i public="1" set="method" line="98" static="1">
		<f a="value">
			<c path="sunaba.core.Vector4i"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromVector4i>
	<toVector4i public="1" get="inline" set="null" line="102" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Vector4i"/>
		</f>
		<meta><m n=":to"/></meta>
	</toVector4i>
	<fromColor public="1" set="method" line="106" static="1">
		<f a="value">
			<c path="sunaba.core.Color"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromColor>
	<toColor public="1" get="inline" set="null" line="110" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Color"/>
		</f>
		<meta><m n=":to"/></meta>
	</toColor>
	<fromRect2 public="1" set="method" line="114" static="1">
		<f a="value">
			<c path="sunaba.core.Rect2"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromRect2>
	<toRect2 public="1" get="inline" set="null" line="118" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Rect2"/>
		</f>
		<meta><m n=":to"/></meta>
	</toRect2>
	<fromRect2i public="1" set="method" line="122" static="1">
		<f a="value">
			<c path="sunaba.core.Rect2i"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromRect2i>
	<toRect2i public="1" get="inline" set="null" line="126" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Rect2i"/>
		</f>
		<meta><m n=":to"/></meta>
	</toRect2i>
	<fromBasis public="1" set="method" line="130" static="1">
		<f a="value">
			<c path="sunaba.core.Basis"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromBasis>
	<toBasis public="1" get="inline" set="null" line="134" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Basis"/>
		</f>
		<meta><m n=":to"/></meta>
	</toBasis>
	<fromTransform2D public="1" set="method" line="138" static="1">
		<f a="value">
			<c path="sunaba.core.Transform2D"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromTransform2D>
	<toTransform2D public="1" get="inline" set="null" line="142" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Transform2D"/>
		</f>
		<meta><m n=":to"/></meta>
	</toTransform2D>
	<fromTransform3D public="1" set="method" line="146" static="1">
		<f a="value">
			<c path="sunaba.core.Transform3D"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromTransform3D>
	<toTransform3D public="1" get="inline" set="null" line="150" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Transform3D"/>
		</f>
		<meta><m n=":to"/></meta>
	</toTransform3D>
	<fromQuaternion public="1" set="method" line="162" static="1">
		<f a="value">
			<c path="sunaba.core.Quaternion"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromQuaternion>
	<toQuaternion public="1" get="inline" set="null" line="166" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Quaternion"/>
		</f>
		<meta><m n=":to"/></meta>
	</toQuaternion>
	<fromElement public="1" set="method" line="170" static="1">
		<f a="value">
			<c path="sunaba.core.Element"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromElement>
	<toElement public="1" get="inline" set="null" line="174" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Element"/>
		</f>
		<meta><m n=":to"/></meta>
	</toElement>
	<fromResource public="1" set="method" line="178" static="1">
		<f a="value">
			<c path="sunaba.core.Resource"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromResource>
	<toResource public="1" get="inline" set="null" line="182" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.Resource"/>
		</f>
		<meta><m n=":to"/></meta>
	</toResource>
	<fromByteArray public="1" set="method" line="186" static="1">
		<f a="value">
			<c path="sunaba.core.io.BinaryData"/>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromByteArray>
	<toByteArray public="1" get="inline" set="null" line="190" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="sunaba.core.io.BinaryData"/>
		</f>
		<meta><m n=":to"/></meta>
	</toByteArray>
	<fromIntArray64 public="1" set="method" line="203" static="1">
		<f a="value">
			<c path="lua.Table">
				<x path="Int"/>
				<x path="Int"/>
			</c>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromIntArray64>
	<toIntArray64 public="1" get="inline" set="null" line="207" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="lua.Table">
				<x path="Int"/>
				<x path="Int"/>
			</c>
		</f>
		<meta><m n=":to"/></meta>
	</toIntArray64>
	<fromFloatArray64 public="1" set="method" line="219" static="1">
		<f a="value">
			<c path="lua.Table">
				<x path="Int"/>
				<x path="Float"/>
			</c>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromFloatArray64>
	<toFloatArray64 public="1" get="inline" set="null" line="223" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="lua.Table">
				<x path="Int"/>
				<x path="Float"/>
			</c>
		</f>
		<meta><m n=":to"/></meta>
	</toFloatArray64>
	<fromStringArray public="1" set="method" line="227" static="1">
		<f a="value">
			<c path="lua.Table">
				<x path="Int"/>
				<c path="String"/>
			</c>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromStringArray>
	<toStringArray public="1" get="inline" set="null" line="231" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="lua.Table">
				<x path="Int"/>
				<c path="String"/>
			</c>
		</f>
		<meta><m n=":to"/></meta>
	</toStringArray>
	<fromVector2Array public="1" set="method" line="235" static="1">
		<f a="value">
			<c path="lua.Table">
				<x path="Int"/>
				<c path="sunaba.core.Vector2"/>
			</c>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromVector2Array>
	<toVector2Array public="1" get="inline" set="null" line="239" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="lua.Table">
				<x path="Int"/>
				<c path="sunaba.core.Vector2"/>
			</c>
		</f>
		<meta><m n=":to"/></meta>
	</toVector2Array>
	<fromVector3Array public="1" set="method" line="243" static="1">
		<f a="value">
			<c path="lua.Table">
				<x path="Int"/>
				<c path="sunaba.core.Vector3"/>
			</c>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromVector3Array>
	<toVector3Array public="1" get="inline" set="null" line="247" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="lua.Table">
				<x path="Int"/>
				<c path="sunaba.core.Vector3"/>
			</c>
		</f>
		<meta><m n=":to"/></meta>
	</toVector3Array>
	<fromVector4Array public="1" set="method" line="252" static="1">
		<f a="value">
			<c path="lua.Table">
				<x path="Int"/>
				<c path="sunaba.core.Vector4"/>
			</c>
			<x path="sunaba.core.Variant"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromVector4Array>
	<toVector4Array public="1" get="inline" set="null" line="256" static="1">
		<f a="this">
			<c path="sunaba.core.VariantNative"/>
			<c path="lua.Table">
				<x path="Int"/>
				<c path="sunaba.core.Vector4"/>
			</c>
		</f>
		<meta><m n=":to"/></meta>
	</toVector4Array>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="sunaba.core._Variant.Variant_Impl_" params="" file="G:\sunaba\sunaba/core/Variant.hx" private="1" module="sunaba.core.Variant" final="1">
		<fromString public="1" set="method" line="10" static="1">
			<f a="value">
				<c path="String"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString public="1" get="inline" set="null" line="14" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="String"/>
			</f>
			<meta><m n=":to"/></meta>
		</toString>
		<fromInt public="1" set="method" line="18" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<toInt public="1" get="inline" set="null" line="22" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":to"/></meta>
		</toInt>
		<fromInt64 public="1" set="method" line="26" static="1">
			<f a="value">
				<x path="haxe.Int64"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt64>
		<toInt64 public="1" get="inline" set="null" line="30" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":to"/></meta>
		</toInt64>
		<fromInt32 public="1" set="method" line="34" static="1">
			<f a="value">
				<x path="haxe.Int32"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt32>
		<toInt32 public="1" get="inline" set="null" line="38" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":to"/></meta>
		</toInt32>
		<fromFloat public="1" set="method" line="42" static="1">
			<f a="value">
				<x path="Float"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromFloat>
		<toFloat public="1" get="inline" set="null" line="46" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<x path="Float"/>
			</f>
			<meta><m n=":to"/></meta>
		</toFloat>
		<fromBool public="1" set="method" line="50" static="1">
			<f a="value">
				<x path="Bool"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromBool>
		<toBool public="1" get="inline" set="null" line="54" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":to"/></meta>
		</toBool>
		<fromVector2 public="1" set="method" line="58" static="1">
			<f a="value">
				<c path="sunaba.core.Vector2"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromVector2>
		<toVector2 public="1" get="inline" set="null" line="62" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Vector2"/>
			</f>
			<meta><m n=":to"/></meta>
		</toVector2>
		<fromVector3 public="1" set="method" line="66" static="1">
			<f a="value">
				<c path="sunaba.core.Vector3"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromVector3>
		<toVector3 public="1" get="inline" set="null" line="70" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Vector3"/>
			</f>
			<meta><m n=":to"/></meta>
		</toVector3>
		<fromVector4 public="1" set="method" line="74" static="1">
			<f a="value">
				<c path="sunaba.core.Vector4"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromVector4>
		<toVector4 public="1" get="inline" set="null" line="78" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Vector4"/>
			</f>
			<meta><m n=":to"/></meta>
		</toVector4>
		<fromVector2i public="1" set="method" line="82" static="1">
			<f a="value">
				<c path="sunaba.core.Vector2i"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromVector2i>
		<toVector2i public="1" get="inline" set="null" line="86" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Vector2i"/>
			</f>
			<meta><m n=":to"/></meta>
		</toVector2i>
		<fromVector3i public="1" set="method" line="90" static="1">
			<f a="value">
				<c path="sunaba.core.Vector3i"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromVector3i>
		<toVector3i public="1" get="inline" set="null" line="94" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Vector3i"/>
			</f>
			<meta><m n=":to"/></meta>
		</toVector3i>
		<fromVector4i public="1" set="method" line="98" static="1">
			<f a="value">
				<c path="sunaba.core.Vector4i"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromVector4i>
		<toVector4i public="1" get="inline" set="null" line="102" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Vector4i"/>
			</f>
			<meta><m n=":to"/></meta>
		</toVector4i>
		<fromColor public="1" set="method" line="106" static="1">
			<f a="value">
				<c path="sunaba.core.Color"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromColor>
		<toColor public="1" get="inline" set="null" line="110" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Color"/>
			</f>
			<meta><m n=":to"/></meta>
		</toColor>
		<fromRect2 public="1" set="method" line="114" static="1">
			<f a="value">
				<c path="sunaba.core.Rect2"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromRect2>
		<toRect2 public="1" get="inline" set="null" line="118" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Rect2"/>
			</f>
			<meta><m n=":to"/></meta>
		</toRect2>
		<fromRect2i public="1" set="method" line="122" static="1">
			<f a="value">
				<c path="sunaba.core.Rect2i"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromRect2i>
		<toRect2i public="1" get="inline" set="null" line="126" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Rect2i"/>
			</f>
			<meta><m n=":to"/></meta>
		</toRect2i>
		<fromBasis public="1" set="method" line="130" static="1">
			<f a="value">
				<c path="sunaba.core.Basis"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromBasis>
		<toBasis public="1" get="inline" set="null" line="134" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Basis"/>
			</f>
			<meta><m n=":to"/></meta>
		</toBasis>
		<fromTransform2D public="1" set="method" line="138" static="1">
			<f a="value">
				<c path="sunaba.core.Transform2D"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromTransform2D>
		<toTransform2D public="1" get="inline" set="null" line="142" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Transform2D"/>
			</f>
			<meta><m n=":to"/></meta>
		</toTransform2D>
		<fromTransform3D public="1" set="method" line="146" static="1">
			<f a="value">
				<c path="sunaba.core.Transform3D"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromTransform3D>
		<toTransform3D public="1" get="inline" set="null" line="150" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Transform3D"/>
			</f>
			<meta><m n=":to"/></meta>
		</toTransform3D>
		<fromQuaternion public="1" set="method" line="162" static="1">
			<f a="value">
				<c path="sunaba.core.Quaternion"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromQuaternion>
		<toQuaternion public="1" get="inline" set="null" line="166" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Quaternion"/>
			</f>
			<meta><m n=":to"/></meta>
		</toQuaternion>
		<fromElement public="1" set="method" line="170" static="1">
			<f a="value">
				<c path="sunaba.core.Element"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromElement>
		<toElement public="1" get="inline" set="null" line="174" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Element"/>
			</f>
			<meta><m n=":to"/></meta>
		</toElement>
		<fromResource public="1" set="method" line="178" static="1">
			<f a="value">
				<c path="sunaba.core.Resource"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromResource>
		<toResource public="1" get="inline" set="null" line="182" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.Resource"/>
			</f>
			<meta><m n=":to"/></meta>
		</toResource>
		<fromByteArray public="1" set="method" line="186" static="1">
			<f a="value">
				<c path="sunaba.core.io.BinaryData"/>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromByteArray>
		<toByteArray public="1" get="inline" set="null" line="190" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="sunaba.core.io.BinaryData"/>
			</f>
			<meta><m n=":to"/></meta>
		</toByteArray>
		<fromIntArray64 public="1" set="method" line="203" static="1">
			<f a="value">
				<c path="lua.Table">
					<x path="Int"/>
					<x path="Int"/>
				</c>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromIntArray64>
		<toIntArray64 public="1" get="inline" set="null" line="207" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="lua.Table">
					<x path="Int"/>
					<x path="Int"/>
				</c>
			</f>
			<meta><m n=":to"/></meta>
		</toIntArray64>
		<fromFloatArray64 public="1" set="method" line="219" static="1">
			<f a="value">
				<c path="lua.Table">
					<x path="Int"/>
					<x path="Float"/>
				</c>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromFloatArray64>
		<toFloatArray64 public="1" get="inline" set="null" line="223" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="lua.Table">
					<x path="Int"/>
					<x path="Float"/>
				</c>
			</f>
			<meta><m n=":to"/></meta>
		</toFloatArray64>
		<fromStringArray public="1" set="method" line="227" static="1">
			<f a="value">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="String"/>
				</c>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromStringArray>
		<toStringArray public="1" get="inline" set="null" line="231" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="lua.Table">
					<x path="Int"/>
					<c path="String"/>
				</c>
			</f>
			<meta><m n=":to"/></meta>
		</toStringArray>
		<fromVector2Array public="1" set="method" line="235" static="1">
			<f a="value">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector2"/>
				</c>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromVector2Array>
		<toVector2Array public="1" get="inline" set="null" line="239" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector2"/>
				</c>
			</f>
			<meta><m n=":to"/></meta>
		</toVector2Array>
		<fromVector3Array public="1" set="method" line="243" static="1">
			<f a="value">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector3"/>
				</c>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromVector3Array>
		<toVector3Array public="1" get="inline" set="null" line="247" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector3"/>
				</c>
			</f>
			<meta><m n=":to"/></meta>
		</toVector3Array>
		<fromVector4Array public="1" set="method" line="252" static="1">
			<f a="value">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector4"/>
				</c>
				<x path="sunaba.core.Variant"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromVector4Array>
		<toVector4Array public="1" get="inline" set="null" line="256" static="1">
			<f a="this">
				<c path="sunaba.core.VariantNative"/>
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector4"/>
				</c>
			</f>
			<meta><m n=":to"/></meta>
		</toVector4Array>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sunaba.core.VariantNative" params="" file="G:\sunaba\sunaba/core/VariantNative.hx" extern="1">
		<fromInt32 public="1" set="method" static="1">
			<f a="value">
				<x path="haxe.Int32"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromInt32>
		<fromInt64 public="1" set="method" static="1">
			<f a="value">
				<x path="haxe.Int64"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromInt64>
		<fromFloat32 public="1" set="method" static="1">
			<f a="vale">
				<x path="Float"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromFloat32>
		<fromFloat64 public="1" set="method" static="1">
			<f a="value">
				<x path="Float"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromFloat64>
		<fromString public="1" set="method" static="1">
			<f a="value">
				<c path="String"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromString>
		<fromBool public="1" set="method" static="1">
			<f a="value">
				<x path="Bool"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromBool>
		<fromVector2 public="1" set="method" static="1">
			<f a="value">
				<c path="sunaba.core.Vector2"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromVector2>
		<fromVector3 public="1" set="method" static="1">
			<f a="value">
				<c path="sunaba.core.Vector3"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromVector3>
		<fromVector4 public="1" set="method" static="1">
			<f a="value">
				<c path="sunaba.core.Vector4"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromVector4>
		<fromVector2i public="1" set="method" static="1">
			<f a="value">
				<c path="sunaba.core.Vector2i"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromVector2i>
		<fromVector3i public="1" set="method" static="1">
			<f a="value">
				<c path="sunaba.core.Vector3i"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromVector3i>
		<fromVector4i public="1" set="method" static="1">
			<f a="value">
				<c path="sunaba.core.Vector4i"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromVector4i>
		<fromColor public="1" set="method" static="1">
			<f a="value">
				<c path="sunaba.core.Color"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromColor>
		<fromRect2 public="1" set="method" static="1">
			<f a="value">
				<c path="sunaba.core.Rect2"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromRect2>
		<fromRect2i public="1" set="method" static="1">
			<f a="value">
				<c path="sunaba.core.Rect2i"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromRect2i>
		<fromBasis public="1" set="method" static="1">
			<f a="value">
				<c path="sunaba.core.Basis"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromBasis>
		<fromTransform2D public="1" set="method" static="1">
			<f a="value">
				<c path="sunaba.core.Transform2D"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromTransform2D>
		<fromTransform3D public="1" set="method" static="1">
			<f a="value">
				<c path="sunaba.core.Transform3D"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromTransform3D>
		<fromQuatrernion public="1" set="method" static="1">
			<f a="value">
				<c path="sunaba.core.Quaternion"/>
				<c path="sunaba.core.VariantNative"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromQuatrernion>
		<fromByteArray public="1" set="method" static="1"><f a="value">
	<c path="sunaba.core.io.BinaryData"/>
	<c path="sunaba.core.VariantNative"/>
</f></fromByteArray>
		<fromIntArray public="1" set="method" static="1"><f a="value">
	<c path="lua.Table">
		<x path="Int"/>
		<x path="Int"/>
	</c>
	<c path="sunaba.core.VariantNative"/>
</f></fromIntArray>
		<fromIntArray64 public="1" set="method" static="1"><f a="value">
	<c path="lua.Table">
		<x path="Int"/>
		<x path="Int"/>
	</c>
	<c path="sunaba.core.VariantNative"/>
</f></fromIntArray64>
		<fromFloatArray public="1" set="method" static="1"><f a="value">
	<c path="lua.Table">
		<x path="Int"/>
		<x path="Float"/>
	</c>
	<c path="sunaba.core.VariantNative"/>
</f></fromFloatArray>
		<fromFloatArray64 public="1" set="method" static="1"><f a="value">
	<c path="lua.Table">
		<x path="Int"/>
		<x path="Float"/>
	</c>
	<c path="sunaba.core.VariantNative"/>
</f></fromFloatArray64>
		<fromStringArray public="1" set="method" static="1"><f a="value">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
	<c path="sunaba.core.VariantNative"/>
</f></fromStringArray>
		<fromVector2Array public="1" set="method" static="1"><f a="value">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="sunaba.core.Vector2"/>
	</c>
	<c path="sunaba.core.VariantNative"/>
</f></fromVector2Array>
		<fromVector3Array public="1" set="method" static="1"><f a="value">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="sunaba.core.Vector3"/>
	</c>
	<c path="sunaba.core.VariantNative"/>
</f></fromVector3Array>
		<fromVector4Array public="1" set="method" static="1"><f a="value">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="sunaba.core.Vector4"/>
	</c>
	<c path="sunaba.core.VariantNative"/>
</f></fromVector4Array>
		<fromElement public="1" set="method" static="1"><f a="value">
	<c path="sunaba.core.Element"/>
	<c path="sunaba.core.VariantNative"/>
</f></fromElement>
		<fromResource public="1" set="method" static="1"><f a="value">
	<c path="sunaba.core.Resource"/>
	<c path="sunaba.core.VariantNative"/>
</f></fromResource>
		<getTypeName public="1" set="method" static="1"><f a="type">
	<x path="Int"/>
	<c path="String"/>
</f></getTypeName>
		<getType public="1" set="method"><f a=""><x path="Int"/></f></getType>
		<asString public="1" set="method"><f a=""><c path="String"/></f></asString>
		<asInt32 public="1" set="method"><f a=""><x path="haxe.Int32"/></f></asInt32>
		<asInt64 public="1" set="method"><f a=""><x path="haxe.Int64"/></f></asInt64>
		<asFloat32 public="1" set="method"><f a=""><x path="Float"/></f></asFloat32>
		<asFloat64 public="1" set="method"><f a=""><x path="Float"/></f></asFloat64>
		<asBool public="1" set="method"><f a=""><x path="Bool"/></f></asBool>
		<asVector2 public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></asVector2>
		<asVector3 public="1" set="method"><f a=""><c path="sunaba.core.Vector3"/></f></asVector3>
		<asVector4 public="1" set="method"><f a=""><c path="sunaba.core.Vector4"/></f></asVector4>
		<asVector2i public="1" set="method"><f a=""><c path="sunaba.core.Vector2i"/></f></asVector2i>
		<asVector3i public="1" set="method"><f a=""><c path="sunaba.core.Vector3i"/></f></asVector3i>
		<asVector4i public="1" set="method"><f a=""><c path="sunaba.core.Vector4i"/></f></asVector4i>
		<asColor public="1" set="method"><f a=""><c path="sunaba.core.Color"/></f></asColor>
		<asRect2 public="1" set="method"><f a=""><c path="sunaba.core.Rect2"/></f></asRect2>
		<asRect2i public="1" set="method"><f a=""><c path="sunaba.core.Rect2i"/></f></asRect2i>
		<asBasis public="1" set="method"><f a=""><c path="sunaba.core.Basis"/></f></asBasis>
		<asTransform2D public="1" set="method"><f a=""><c path="sunaba.core.Transform2D"/></f></asTransform2D>
		<asTransform3D public="1" set="method"><f a=""><c path="sunaba.core.Transform3D"/></f></asTransform3D>
		<asQuaternion public="1" set="method"><f a=""><c path="sunaba.core.Quaternion"/></f></asQuaternion>
		<asByteArray public="1" set="method"><f a=""><c path="sunaba.core.io.BinaryData"/></f></asByteArray>
		<asIntArray public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<x path="Int"/>
</c></f></asIntArray>
		<asIntArray64 public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<x path="Int"/>
</c></f></asIntArray64>
		<asFloatArray public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<x path="Float"/>
</c></f></asFloatArray>
		<asFloatArray64 public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<x path="Float"/>
</c></f></asFloatArray64>
		<asStringArray public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></f></asStringArray>
		<asVector2Array public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.core.Vector2"/>
</c></f></asVector2Array>
		<asVector3Array public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.core.Vector3"/>
</c></f></asVector3Array>
		<asVector4Array public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.core.Vector4"/>
</c></f></asVector4Array>
		<asElement public="1" set="method"><f a=""><c path="sunaba.core.Element"/></f></asElement>
		<asResource public="1" set="method"><f a=""><c path="sunaba.core.Resource"/></f></asResource>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"tostring"</e></m></meta>
		</toString>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Variant"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.VectorNative" params="T" file="G:\sunaba\sunaba/core/Vector.hx" module="sunaba.core.Vector" extern="1">
		<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<c path="sunaba.core.VectorNative.T"/>
	<x path="Void"/>
</f></set>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="sunaba.core.VectorNative.T"/>
</f></get>
		<find public="1" set="method"><f a="value">
	<c path="sunaba.core.VectorNative.T"/>
	<x path="Int"/>
</f></find>
		<erase public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></erase>
		<insert public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<c path="sunaba.core.VectorNative.T"/>
	<x path="Void"/>
</f></insert>
		<add public="1" set="method"><f a="value">
	<c path="sunaba.core.VectorNative.T"/>
	<x path="Void"/>
</f></add>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<next public="1" set="method"><f a=""><c path="sunaba.core.VectorNative.T"/></f></next>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":selfCall"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":generic"/>
		</meta>
	</class>
	<abstract path="sunaba.core.Vector" params="T" file="G:\sunaba\sunaba/core/Vector.hx">
		<from>
			<icast><c path="sunaba.core.VectorNative"><c path="sunaba.core.Vector.T"/></c></icast>
			<icast field="fromTable"><c path="lua.Table">
	<x path="Int"/>
	<c path="fromTable.A"/>
</c></icast>
			<icast field="fromArray"><c path="Array"><c path="fromArray.A"/></c></icast>
		</from>
		<this><c path="sunaba.core.VectorNative"><c path="sunaba.core.Vector.T"/></c></this>
		<to>
			<icast><c path="sunaba.core.VectorNative"><c path="sunaba.core.Vector.T"/></c></icast>
			<icast field="toArray"><c path="Array"><c path="sunaba.core.Vector.T"/></c></icast>
			<icast field="toTable"><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.core.Vector.T"/>
</c></icast>
		</to>
		<meta>
			<m n=":generic"/>
			<m n=":forward">
				<e>set</e>
				<e>get</e>
				<e>find</e>
				<e>erase</e>
				<e>insert</e>
				<e>add</e>
				<e>clear</e>
				<e>next</e>
			</m>
		</meta>
		<impl><class path="sunaba.core._Vector.Vector_Impl_" params="" file="G:\sunaba\sunaba/core/Vector.hx" private="1" module="sunaba.core.Vector" final="1">
	<_new public="1" set="method" line="22" static="1">
		<f a=""><x path="sunaba.core.Vector"><c path="sunaba.core.Vector.T"/></x></f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<size public="1" set="method" line="26" static="1">
		<f a="this">
			<c path="sunaba.core.VectorNative"><c path="sunaba.core.Vector.T"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":has_untyped"/></meta>
	</size>
	<get public="1" set="method" line="32" static="1">
		<f a="this:index">
			<c path="sunaba.core.VectorNative"><c path="sunaba.core.Vector.T"/></c>
			<x path="Int"/>
			<c path="sunaba.core.Vector.T"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set public="1" set="method" line="38" static="1">
		<f a="this:index:value">
			<c path="sunaba.core.VectorNative"><c path="sunaba.core.Vector.T"/></c>
			<x path="Int"/>
			<c path="sunaba.core.Vector.T"/>
			<c path="sunaba.core.Vector.T"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
	<toArray public="1" get="inline" set="null" line="45" static="1">
		<f a="this">
			<c path="sunaba.core.VectorNative"><c path="sunaba.core.Vector.T"/></c>
			<c path="Array"><c path="sunaba.core.Vector.T"/></c>
		</f>
		<meta><m n=":to"/></meta>
	</toArray>
	<toTable public="1" get="inline" set="null" line="59" static="1">
		<f a="this">
			<c path="sunaba.core.VectorNative"><c path="sunaba.core.Vector.T"/></c>
			<c path="lua.Table">
				<x path="Int"/>
				<c path="sunaba.core.Vector.T"/>
			</c>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":to"/>
		</meta>
	</toTable>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="sunaba.core._Vector.Vector_Impl_" params="" file="G:\sunaba\sunaba/core/Vector.hx" private="1" module="sunaba.core.Vector" final="1">
		<_new public="1" set="method" line="22" static="1">
			<f a=""><x path="sunaba.core.Vector"><c path="sunaba.core.Vector.T"/></x></f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<size public="1" set="method" line="26" static="1">
			<f a="this">
				<c path="sunaba.core.VectorNative"><c path="sunaba.core.Vector.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</size>
		<get public="1" set="method" line="32" static="1">
			<f a="this:index">
				<c path="sunaba.core.VectorNative"><c path="sunaba.core.Vector.T"/></c>
				<x path="Int"/>
				<c path="sunaba.core.Vector.T"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set public="1" set="method" line="38" static="1">
			<f a="this:index:value">
				<c path="sunaba.core.VectorNative"><c path="sunaba.core.Vector.T"/></c>
				<x path="Int"/>
				<c path="sunaba.core.Vector.T"/>
				<c path="sunaba.core.Vector.T"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
		<toArray public="1" get="inline" set="null" line="45" static="1">
			<f a="this">
				<c path="sunaba.core.VectorNative"><c path="sunaba.core.Vector.T"/></c>
				<c path="Array"><c path="sunaba.core.Vector.T"/></c>
			</f>
			<meta><m n=":to"/></meta>
		</toArray>
		<toTable public="1" get="inline" set="null" line="59" static="1">
			<f a="this">
				<c path="sunaba.core.VectorNative"><c path="sunaba.core.Vector.T"/></c>
				<c path="lua.Table">
					<x path="Int"/>
					<c path="sunaba.core.Vector.T"/>
				</c>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":to"/>
			</meta>
		</toTable>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sunaba.core.Vector2" params="" file="G:\sunaba\sunaba/core/Vector2.hx" extern="1">
		<zero public="1" set="method" static="1">
			<f a=""><c path="sunaba.core.Vector2"/></f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</zero>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<normalize public="1" set="method"><f a=""><x path="Void"/></f></normalize>
		<normalized public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></normalized>
		<isNormalized public="1" set="method"><f a=""><x path="Bool"/></f></isNormalized>
		<length public="1" set="method"><f a=""><x path="Float"/></f></length>
		<lengthSquared public="1" set="method"><f a=""><x path="Float"/></f></lengthSquared>
		<limitLength public="1" set="method"><f a="maxLength">
	<x path="Float"/>
	<x path="Void"/>
</f></limitLength>
		<min public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
</f></min>
		<max public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
</f></max>
		<distanceTo public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector2"/>
	<x path="Float"/>
</f></distanceTo>
		<distanceSquaredTo public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector2"/>
	<x path="Float"/>
</f></distanceSquaredTo>
		<angleTo public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector2"/>
	<x path="Float"/>
</f></angleTo>
		<angleToPoint public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector2"/>
	<x path="Float"/>
</f></angleToPoint>
		<dot public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector2"/>
	<x path="Float"/>
</f></dot>
		<posmod public="1" set="method"><f a="mod">
	<x path="Float"/>
	<c path="sunaba.core.Vector2"/>
</f></posmod>
		<posmodv public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
</f></posmodv>
		<project public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
</f></project>
		<planeProject public="1" set="method"><f a="d:vector">
	<x path="Float"/>
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
</f></planeProject>
		<lerp public="1" set="method"><f a="to:t">
	<c path="sunaba.core.Vector2"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector2"/>
</f></lerp>
		<slerp public="1" set="method"><f a="to:weight">
	<c path="sunaba.core.Vector2"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector2"/>
</f></slerp>
		<cubicInterpolate public="1" set="method"><f a="b:preA:postB:weight">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector2"/>
</f></cubicInterpolate>
		<cubicInterpolateInTime public="1" set="method"><f a="b:preA:postB:weight:bT:preAT:postBT">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector2"/>
</f></cubicInterpolateInTime>
		<moveToward public="1" set="method"><f a="to:deltaTime">
	<c path="sunaba.core.Vector2"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector2"/>
</f></moveToward>
		<slide public="1" set="method"><f a="normal">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
</f></slide>
		<bounce public="1" set="method"><f a="normal">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
</f></bounce>
		<reflect public="1" set="method"><f a="normal">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
</f></reflect>
		<isEqualApprox public="1" set="method"><f a="v">
	<c path="sunaba.core.Vector2"/>
	<x path="Bool"/>
</f></isEqualApprox>
		<isZeroApprox public="1" set="method"><f a=""><x path="Bool"/></f></isZeroApprox>
		<angle public="1" set="method"><f a=""><x path="Float"/></f></angle>
		<abs public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></abs>
		<rotated public="1" set="method"><f a="by">
	<x path="Float"/>
	<c path="sunaba.core.Vector2"/>
</f></rotated>
		<orthogonal public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></orthogonal>
		<sign public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></sign>
		<floor public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></floor>
		<ceil public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></ceil>
		<round public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></round>
		<snap public="1" set="method"><f a="by">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
</f></snap>
		<clamp public="1" set="method"><f a="min:max">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector2"/>
</f></clamp>
		<aspect public="1" set="method"><f a=""><x path="Float"/></f></aspect>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"tostring"</e></m></meta>
		</toString>
		<new public="1" set="method">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Vector2"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.Vector2i" params="" file="G:\sunaba\sunaba/core/Vector2i.hx" extern="1">
		<zero public="1" set="method" static="1">
			<f a=""><c path="sunaba.core.Vector2i"/></f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</zero>
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<abs public="1" set="method"><f a=""><c path="sunaba.core.Vector2i"/></f></abs>
		<aspect public="1" set="method"><f a=""><x path="Float"/></f></aspect>
		<clamp public="1" set="method"><f a="min:max">
	<c path="sunaba.core.Vector2i"/>
	<c path="sunaba.core.Vector2i"/>
	<c path="sunaba.core.Vector2i"/>
</f></clamp>
		<length public="1" set="method"><f a=""><x path="Float"/></f></length>
		<lengthSquared public="1" set="method"><f a=""><x path="Int"/></f></lengthSquared>
		<max public="1" set="method"><f a="vector2i">
	<c path="sunaba.core.Vector2i"/>
	<c path="sunaba.core.Vector2i"/>
</f></max>
		<maxAxisIndex public="1" set="method"><f a=""><x path="Int"/></f></maxAxisIndex>
		<min public="1" set="method"><f a="vector2i">
	<c path="sunaba.core.Vector2i"/>
	<c path="sunaba.core.Vector2i"/>
</f></min>
		<minAxisIndex public="1" set="method"><f a=""><x path="Int"/></f></minAxisIndex>
		<sign public="1" set="method"><f a=""><c path="sunaba.core.Vector2i"/></f></sign>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"tostring"</e></m></meta>
		</toString>
		<new public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Vector2i"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.Vector3" params="" file="G:\sunaba\sunaba/core/Vector3.hx" extern="1">
		<zero public="1" set="method" static="1">
			<f a=""><c path="sunaba.core.Vector3"/></f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</zero>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<abs public="1" set="method"><f a=""><c path="sunaba.core.Vector3"/></f></abs>
		<angleTo public="1" set="method"><f a="vector3">
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
</f></angleTo>
		<bezierInterpolate public="1" set="method"><f a="control1:control2:end:t">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector3"/>
</f></bezierInterpolate>
		<bounce public="1" set="method"><f a="normal">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
</f></bounce>
		<ciel public="1" set="method"><f a=""><c path="sunaba.core.Vector3"/></f></ciel>
		<clamp public="1" set="method"><f a="min:max">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
</f></clamp>
		<cross public="1" set="method"><f a="with">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
</f></cross>
		<cubicInterpolate public="1" set="method"><f a="b:preA:postB:weight">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector3"/>
</f></cubicInterpolate>
		<cubicInterpolateInTime public="1" set="method"><f a="b:preA:postB:weight:bT:preAT:postBT">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector3"/>
</f></cubicInterpolateInTime>
		<directionTo public="1" set="method"><f a="to">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
</f></directionTo>
		<distanceTo public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
</f></distanceTo>
		<distanceSquaredTo public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
</f></distanceSquaredTo>
		<dot public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
</f></dot>
		<floor public="1" set="method"><f a=""><c path="sunaba.core.Vector3"/></f></floor>
		<inverse public="1" set="method"><f a=""><c path="sunaba.core.Vector3"/></f></inverse>
		<isEqualApprox public="1" set="method"><f a="v">
	<c path="sunaba.core.Vector3"/>
	<x path="Bool"/>
</f></isEqualApprox>
		<isNormalized public="1" set="method"><f a=""><c path="sunaba.core.Vector3"/></f></isNormalized>
		<isZeroApprox public="1" set="method"><f a=""><x path="Bool"/></f></isZeroApprox>
		<length public="1" set="method"><f a=""><x path="Float"/></f></length>
		<lengthSquared public="1" set="method"><f a=""><x path="Float"/></f></lengthSquared>
		<limitLength public="1" set="method"><f a="maxLength">
	<x path="Float"/>
	<x path="Void"/>
</f></limitLength>
		<lerp public="1" set="method"><f a="to:weight">
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector3"/>
</f></lerp>
		<max public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
</f></max>
		<maxAxisIndex public="1" set="method"><f a=""><x path="Int"/></f></maxAxisIndex>
		<min public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
</f></min>
		<minAxisIndex public="1" set="method"><f a=""><x path="Int"/></f></minAxisIndex>
		<moveToward public="1" set="method"><f a="to:deltaTime">
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector3"/>
</f></moveToward>
		<normalize public="1" set="method"><f a=""><x path="Void"/></f></normalize>
		<normalized public="1" set="method"><f a=""><c path="sunaba.core.Vector3"/></f></normalized>
		<octahedronDecode public="1" set="method"><f a="oct">
	<c path="sunaba.core.Vector2"/>
	<c path="sunaba.core.Vector3"/>
</f></octahedronDecode>
		<octahedronEncode public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></octahedronEncode>
		<posmod public="1" set="method"><f a="mod">
	<x path="Float"/>
	<c path="sunaba.core.Vector3"/>
</f></posmod>
		<posmodv public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
</f></posmodv>
		<project public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
</f></project>
		<reflect public="1" set="method"><f a="normal">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
</f></reflect>
		<rotated public="1" set="method"><f a="axis:by">
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector3"/>
</f></rotated>
		<round public="1" set="method"><f a=""><c path="sunaba.core.Vector3"/></f></round>
		<sign public="1" set="method"><f a=""><c path="sunaba.core.Vector3"/></f></sign>
		<signedAngleTo public="1" set="method"><f a="to:axis">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
</f></signedAngleTo>
		<slerp public="1" set="method"><f a="to:weight">
	<c path="sunaba.core.Vector3"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector3"/>
</f></slerp>
		<slide public="1" set="method"><f a="normal">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
</f></slide>
		<snapped public="1" set="method"><f a="val">
	<c path="sunaba.core.Vector3"/>
	<c path="sunaba.core.Vector3"/>
</f></snapped>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"tostring"</e></m></meta>
		</toString>
		<new public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Vector3"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.Vector3i" params="" file="G:\sunaba\sunaba/core/Vector3i.hx" extern="1">
		<zero public="1" set="method" static="1">
			<f a=""><c path="sunaba.core.Vector3i"/></f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</zero>
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<z public="1"><x path="Int"/></z>
		<abs public="1" set="method"><f a=""><c path="sunaba.core.Vector3i"/></f></abs>
		<clamp public="1" set="method"><f a="min:max">
	<c path="sunaba.core.Vector3i"/>
	<c path="sunaba.core.Vector3i"/>
	<c path="sunaba.core.Vector3i"/>
</f></clamp>
		<length public="1" set="method"><f a=""><x path="Float"/></f></length>
		<lengthSquared public="1" set="method"><f a=""><x path="Int"/></f></lengthSquared>
		<max public="1" set="method"><f a="vector3i">
	<c path="sunaba.core.Vector3i"/>
	<c path="sunaba.core.Vector3i"/>
</f></max>
		<maxAxisIndex public="1" set="method"><f a=""><x path="Int"/></f></maxAxisIndex>
		<min public="1" set="method"><f a="vector3i">
	<c path="sunaba.core.Vector3i"/>
	<c path="sunaba.core.Vector3i"/>
</f></min>
		<minAxisIndex public="1" set="method"><f a=""><x path="Int"/></f></minAxisIndex>
		<sign public="1" set="method"><f a=""><c path="sunaba.core.Vector3i"/></f></sign>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"tostring"</e></m></meta>
		</toString>
		<new public="1" set="method"><f a="x:y:z">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Vector3i"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.Vector4" params="" file="G:\sunaba\sunaba/core/Vector4.hx" extern="1">
		<zero public="1" set="method" static="1">
			<f a=""><c path="sunaba.core.Vector4"/></f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</zero>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<w public="1"><x path="Float"/></w>
		<abs public="1" set="method"><f a=""><c path="sunaba.core.Vector4"/></f></abs>
		<ceil public="1" set="method"><f a=""><c path="sunaba.core.Vector4"/></f></ceil>
		<clamp public="1" set="method"><f a="min:max">
	<c path="sunaba.core.Vector4"/>
	<c path="sunaba.core.Vector4"/>
	<c path="sunaba.core.Vector4"/>
</f></clamp>
		<cubicInterpolate public="1" set="method"><f a="v0:v1:v2:v3:t">
	<c path="sunaba.core.Vector4"/>
	<c path="sunaba.core.Vector4"/>
	<c path="sunaba.core.Vector4"/>
	<c path="sunaba.core.Vector4"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector4"/>
</f></cubicInterpolate>
		<cubicInterpolateInTime public="1" set="method"><f a="v0:v1:v2:v3:t:v0T:v1T:v2T:v3T">
	<c path="sunaba.core.Vector4"/>
	<c path="sunaba.core.Vector4"/>
	<c path="sunaba.core.Vector4"/>
	<c path="sunaba.core.Vector4"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector4"/>
</f></cubicInterpolateInTime>
		<directionTo public="1" set="method"><f a="to">
	<c path="sunaba.core.Vector4"/>
	<c path="sunaba.core.Vector4"/>
</f></directionTo>
		<distanceTo public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector4"/>
	<x path="Float"/>
</f></distanceTo>
		<distanceSquaredTo public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector4"/>
	<x path="Float"/>
</f></distanceSquaredTo>
		<dot public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector4"/>
	<x path="Float"/>
</f></dot>
		<floor public="1" set="method"><f a=""><c path="sunaba.core.Vector4"/></f></floor>
		<inverse public="1" set="method"><f a=""><c path="sunaba.core.Vector4"/></f></inverse>
		<isEqualApprox public="1" set="method"><f a="v">
	<c path="sunaba.core.Vector4"/>
	<x path="Bool"/>
</f></isEqualApprox>
		<isNormalized public="1" set="method"><f a=""><x path="Bool"/></f></isNormalized>
		<isZeroApprox public="1" set="method"><f a=""><x path="Bool"/></f></isZeroApprox>
		<length public="1" set="method"><f a=""><x path="Float"/></f></length>
		<lengthSquared public="1" set="method"><f a=""><x path="Float"/></f></lengthSquared>
		<lerp public="1" set="method"><f a="to:weight">
	<c path="sunaba.core.Vector4"/>
	<x path="Float"/>
	<c path="sunaba.core.Vector4"/>
</f></lerp>
		<max public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector4"/>
	<c path="sunaba.core.Vector4"/>
</f></max>
		<maxAxisIndex public="1" set="method"><f a=""><x path="Int"/></f></maxAxisIndex>
		<min public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector4"/>
	<c path="sunaba.core.Vector4"/>
</f></min>
		<minAxisIndex public="1" set="method"><f a=""><x path="Int"/></f></minAxisIndex>
		<normalized public="1" set="method"><f a=""><c path="sunaba.core.Vector4"/></f></normalized>
		<posmod public="1" set="method"><f a="mod">
	<x path="Float"/>
	<c path="sunaba.core.Vector4"/>
</f></posmod>
		<posmodv public="1" set="method"><f a="other">
	<c path="sunaba.core.Vector4"/>
	<c path="sunaba.core.Vector4"/>
</f></posmodv>
		<round public="1" set="method"><f a=""><c path="sunaba.core.Vector4"/></f></round>
		<sign public="1" set="method"><f a=""><c path="sunaba.core.Vector4"/></f></sign>
		<snapped public="1" set="method"><f a="val">
	<c path="sunaba.core.Vector4"/>
	<c path="sunaba.core.Vector4"/>
</f></snapped>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"tostring"</e></m></meta>
		</toString>
		<new public="1" set="method"><f a="x:y:z:w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Vector4"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.Vector4i" params="" file="G:\sunaba\sunaba/core/Vector4i.hx" extern="1">
		<zero public="1" set="method" static="1">
			<f a=""><c path="sunaba.core.Vector4i"/></f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</zero>
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<z public="1"><x path="Int"/></z>
		<w public="1"><x path="Int"/></w>
		<abs public="1" set="method"><f a=""><c path="sunaba.core.Vector4i"/></f></abs>
		<clamp public="1" set="method"><f a="min:max">
	<c path="sunaba.core.Vector4i"/>
	<c path="sunaba.core.Vector4i"/>
	<c path="sunaba.core.Vector4i"/>
</f></clamp>
		<length public="1" set="method"><f a=""><x path="Float"/></f></length>
		<lengthSquared public="1" set="method"><f a=""><x path="Int"/></f></lengthSquared>
		<max public="1" set="method"><f a="vector4i">
	<c path="sunaba.core.Vector4i"/>
	<c path="sunaba.core.Vector4i"/>
</f></max>
		<maxAxisIndex public="1" set="method"><f a=""><x path="Int"/></f></maxAxisIndex>
		<min public="1" set="method"><f a="vector4i">
	<c path="sunaba.core.Vector4i"/>
	<c path="sunaba.core.Vector4i"/>
</f></min>
		<minAxisIndex public="1" set="method"><f a=""><x path="Int"/></f></minAxisIndex>
		<sign public="1" set="method"><f a=""><c path="sunaba.core.Vector4i"/></f></sign>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"tostring"</e></m></meta>
		</toString>
		<new public="1" set="method"><f a="x:y:z:w">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Vector4i"</e></m>
		</meta>
	</class>
	<class path="sunaba.core.Viewport" params="" file="G:\sunaba\sunaba/core/Viewport.hx" extern="1">
		<extends path="sunaba.core.Element"/>
		<toViewport public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.core.Viewport"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</toViewport>
		<anisotropicFilteringLevel public="1"><x path="Int"/></anisotropicFilteringLevel>
		<audioListenerEnable2D public="1"><x path="Bool"/></audioListenerEnable2D>
		<audioListenerEnable3D public="1"><x path="Bool"/></audioListenerEnable3D>
		<canvasCullMask public="1"><x path="Int"/></canvasCullMask>
		<canvasItemDefaultTextureFilter public="1"><x path="Int"/></canvasItemDefaultTextureFilter>
		<canvasItemDefaultTextureRepeat public="1"><x path="Int"/></canvasItemDefaultTextureRepeat>
		<canvasTransform public="1"><c path="sunaba.core.Transform2D"/></canvasTransform>
		<debugDraw public="1"><x path="Int"/></debugDraw>
		<disable3D public="1"><x path="Bool"/></disable3D>
		<fsrSharpness public="1"><x path="Float"/></fsrSharpness>
		<globalCanvasTransform public="1"><c path="sunaba.core.Transform2D"/></globalCanvasTransform>
		<guiDisableInput public="1"><x path="Bool"/></guiDisableInput>
		<guiEmbedSubwindows public="1"><x path="Bool"/></guiEmbedSubwindows>
		<guiSnapControlsToPixels public="1"><x path="Bool"/></guiSnapControlsToPixels>
		<handleInputLocally public="1"><x path="Bool"/></handleInputLocally>
		<meshLodThreshold public="1"><x path="Float"/></meshLodThreshold>
		<msaa2D public="1"><x path="Int"/></msaa2D>
		<msaa3D public="1"><x path="Int"/></msaa3D>
		<ownWorld3D public="1"><x path="Bool"/></ownWorld3D>
		<physicsInterpolationMode public="1"><x path="Int"/></physicsInterpolationMode>
		<physicsObjectPicking public="1"><x path="Bool"/></physicsObjectPicking>
		<physicsObjectPickingFirstOnly public="1"><x path="Bool"/></physicsObjectPickingFirstOnly>
		<physicsObjectPickingSort public="1"><x path="Bool"/></physicsObjectPickingSort>
		<positionalShadowAtlas16Bits public="1"><x path="Bool"/></positionalShadowAtlas16Bits>
		<positionalShadowAtlasQuad0 public="1"><x path="Bool"/></positionalShadowAtlasQuad0>
		<positionalShadowAtlasQuad1 public="1"><x path="Bool"/></positionalShadowAtlasQuad1>
		<positionalShadowAtlasQuad2 public="1"><x path="Bool"/></positionalShadowAtlasQuad2>
		<positionalShadowAtlasQuad3 public="1"><x path="Bool"/></positionalShadowAtlasQuad3>
		<positionalShadowAtlasSize public="1"><x path="Int"/></positionalShadowAtlasSize>
		<scaling3DMode public="1"><x path="Int"/></scaling3DMode>
		<scaling3DScale public="1"><x path="Float"/></scaling3DScale>
		<screenSpaceAA public="1"><x path="Int"/></screenSpaceAA>
		<sdfOversize public="1"><x path="Int"/></sdfOversize>
		<sdfScale public="1"><x path="Float"/></sdfScale>
		<snap2DTransformToPixels public="1"><x path="Bool"/></snap2DTransformToPixels>
		<textureMipmapBias public="1"><x path="Float"/></textureMipmapBias>
		<transparentBg public="1"><x path="Bool"/></transparentBg>
		<useDebanding public="1"><x path="Bool"/></useDebanding>
		<useHdr2D public="1"><x path="Bool"/></useHdr2D>
		<useOcclusionCulling public="1"><x path="Bool"/></useOcclusionCulling>
		<useTaa public="1"><x path="Bool"/></useTaa>
		<useXr public="1"><x path="Bool"/></useXr>
		<vrsMode public="1"><x path="Int"/></vrsMode>
		<vrsTexture public="1"><c path="sunaba.core.Texture2D"/></vrsTexture>
		<vrsUpdateMode public="1"><x path="Int"/></vrsUpdateMode>
		<world3D public="1"><c path="sunaba.spatial.World3D"/></world3D>
		<guiFocusChanged public="1"><c path="sunaba.core.Event"/></guiFocusChanged>
		<sizeChanged public="1"><c path="sunaba.core.Event"/></sizeChanged>
		<findWorld3D public="1" set="method"><f a=""><c path="sunaba.spatial.World3D"/></f></findWorld3D>
		<canvasCullMaskBit public="1" set="method"><f a="layer">
	<x path="Int"/>
	<x path="Bool"/>
</f></canvasCullMaskBit>
		<getFinalTransform public="1" set="method"><f a=""><c path="sunaba.core.Transform2D"/></f></getFinalTransform>
		<getMousePosition public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></getMousePosition>
		<getRenderInfo public="1" set="method"><f a="type:info">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getRenderInfo>
		<getScreenTransform public="1" set="method"><f a=""><c path="sunaba.core.Transform2D"/></f></getScreenTransform>
		<getStretchTransform public="1" set="method"><f a=""><c path="sunaba.core.Transform2D"/></f></getStretchTransform>
		<getVisibleRect public="1" set="method"><f a=""><c path="sunaba.core.Rect2"/></f></getVisibleRect>
		<guiCancelDrag public="1" set="method"><f a=""><x path="Void"/></f></guiCancelDrag>
		<guiGetDragData public="1" set="method"><f a=""><x path="sunaba.core.Variant"/></f></guiGetDragData>
		<guiGetFocusOwner public="1" set="method"><f a=""><c path="sunaba.ui.Control"/></f></guiGetFocusOwner>
		<guiGetHoveredControl public="1" set="method"><f a=""><c path="sunaba.ui.Control"/></f></guiGetHoveredControl>
		<guiIsDragSuccessful public="1" set="method"><f a=""><x path="Bool"/></f></guiIsDragSuccessful>
		<guiIsDragging public="1" set="method"><f a=""><x path="Bool"/></f></guiIsDragging>
		<guiReleaseFocus public="1" set="method"><f a=""><x path="Void"/></f></guiReleaseFocus>
		<isInputHandled public="1" set="method"><f a=""><x path="Bool"/></f></isInputHandled>
		<notifyMouseEntered public="1" set="method"><f a=""><x path="Void"/></f></notifyMouseEntered>
		<pushInput public="1" set="method"><f a="event:?inLocalCoords">
	<c path="sunaba.input.InputEvent"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></pushInput>
		<pushTextInput public="1" set="method"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></pushTextInput>
		<pushUnhandledInput public="1" set="method"><f a="event:?inLocalCoords">
	<c path="sunaba.input.InputEvent"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></pushUnhandledInput>
		<setCanvasCullMaskBit public="1" set="method"><f a="layer:enable">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setCanvasCullMaskBit>
		<setInputAsHandled public="1" set="method"><f a=""><x path="Void"/></f></setInputAsHandled>
		<setPositionalShadowAtlasQuadrantSubdiv public="1" set="method"><f a="quadrant:subdiv">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPositionalShadowAtlasQuadrantSubdiv>
		<updateMouseCursorState public="1" set="method"><f a=""><x path="Void"/></f></updateMouseCursorState>
		<warpMouse public="1" set="method"><f a="position">
	<c path="sunaba.core.Vector2"/>
	<x path="Void"/>
</f></warpMouse>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Viewport"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.core.ViewportAbstract" params="" file="G:\sunaba\sunaba/core/Viewport.hx" module="sunaba.core.Viewport">
		<from>
			<icast><c path="sunaba.core.Viewport"/></icast>
			<icast field="fromElement"><c path="sunaba.core.Element"/></icast>
		</from>
		<this><c path="sunaba.core.Viewport"/></this>
		<to><icast><c path="sunaba.core.Viewport"/></icast></to>
		<impl><class path="sunaba.core._Viewport.ViewportAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Viewport.hx" private="1" module="sunaba.core.Viewport" final="1"><fromElement public="1" set="method" line="88" static="1">
	<f a="element">
		<c path="sunaba.core.Element"/>
		<x path="sunaba.core.ViewportAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromElement></class></impl>
	</abstract>
	<class path="sunaba.core._Viewport.ViewportAbstract_Impl_" params="" file="G:\sunaba\sunaba/core/Viewport.hx" private="1" module="sunaba.core.Viewport" final="1"><fromElement public="1" set="method" line="88" static="1">
	<f a="element">
		<c path="sunaba.core.Element"/>
		<x path="sunaba.core.ViewportAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromElement></class>
	<class path="sunaba.core.io.BinaryData" params="" file="G:\sunaba\sunaba/core/io/BinaryData.hx" extern="1">
		<fromTable public="1" set="method" static="1">
			<f a="table">
				<c path="lua.Table">
					<x path="Int"/>
					<x path="Float"/>
				</c>
				<c path="sunaba.core.io.BinaryData"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromTable>
		<size public="1" set="method"><f a=""><x path="Int"/></f></size>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="sunaba.core.io.ByteObject"/>
</f></get>
		<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<c path="sunaba.core.io.ByteObject"/>
	<x path="Void"/>
</f></set>
		<resize public="1" set="method"><f a="size">
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<append public="1" set="method"><f a="value">
	<c path="sunaba.core.io.ByteObject"/>
	<x path="Void"/>
</f></append>
		<insert public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<c path="sunaba.core.io.ByteObject"/>
	<x path="Void"/>
</f></insert>
		<toTable public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<x path="Float"/>
</c></f></toTable>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":native"><e>"BinaryData"</e></m></meta>
	</class>
	<class path="sunaba.core.io.ByteObject" params="" file="G:\sunaba\sunaba/core/io/ByteObject.hx" extern="1">
		<fromInt public="1" set="method" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="sunaba.core.io.ByteObject"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromInt>
		<fromFloat public="1" set="method" static="1">
			<f a="value">
				<x path="Float"/>
				<c path="sunaba.core.io.ByteObject"/>
			</f>
			<meta><m n=":native"><e>"new"</e></m></meta>
		</fromFloat>
		<getInt public="1" set="method"><f a=""><x path="Int"/></f></getInt>
		<getFloat public="1" set="method"><f a=""><x path="Float"/></f></getFloat>
		<setInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></setInt>
		<setFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":native"><e>"Byte"</e></m></meta>
	</class>
	<class path="sunaba.core.io.IoInterface" params="" file="G:\sunaba\sunaba/core/io/IoInterface.hx" extern="1">
		<extends path="sunaba.core.BaseObject"/>
		<pathUri public="1"><c path="String"/></pathUri>
		<getFilePath public="1" set="method"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></getFilePath>
		<loadText public="1" set="method"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></loadText>
		<saveText public="1" set="method"><f a="path:text">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></saveText>
		<loadBinary public="1" set="method"><f a="path">
	<c path="String"/>
	<c path="sunaba.core.io.BinaryData"/>
</f></loadBinary>
		<saveBinary public="1" set="method"><f a="path:data">
	<c path="String"/>
	<c path="sunaba.core.io.BinaryData"/>
	<x path="Void"/>
</f></saveBinary>
		<getFileListAll public="1" set="method"><f a="?extension:?recursive">
	<c path="String"/>
	<x path="Bool"/>
	<x path="sunaba.core.StringArray"/>
</f></getFileListAll>
		<getFileList public="1" set="method"><f a="path:?extension:?recursive">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="sunaba.core.StringArray"/>
</f></getFileList>
		<fileExists public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></fileExists>
		<deleteFile public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></deleteFile>
		<moveFile public="1" set="method"><f a="src:dest">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></moveFile>
		<createDirectory public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></createDirectory>
		<deleteDirectory public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></deleteDirectory>
		<directoryExists public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></directoryExists>
		<meta><m n=":native"><e>"IoInterface"</e></m></meta>
	</class>
	<class path="sunaba.core.io.IoManager" params="" file="G:\sunaba\sunaba/core/io/IoManager.hx" extern="1">
		<extends path="sunaba.core.io.IoInterface"/>
		<add public="1" set="method"><f a="ioInterface">
	<c path="sunaba.core.io.IoInterface"/>
	<x path="Void"/>
</f></add>
		<remove public="1" set="method"><f a="ioInterface">
	<c path="sunaba.core.io.IoInterface"/>
	<x path="Void"/>
</f></remove>
		<getFileUri public="1" set="method"><f a="path:base_uri">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getFileUri>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":native"><e>"IoManager"</e></m></meta>
	</class>
	<class path="sunaba.input.InputEvent" params="" file="G:\sunaba\sunaba/input/InputEvent.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<castFrom public="1" set="method" static="1">
			<f a="res">
				<d/>
				<c path="sunaba.input.InputEvent"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<device public="1"><x path="Int"/></device>
		<accumulate public="1" set="method"><f a="event">
	<c path="sunaba.input.InputEvent"/>
	<x path="Void"/>
</f></accumulate>
		<asText public="1" set="method"><f a=""><c path="String"/></f></asText>
		<getActionStregth public="1" set="method"><f a="action">
	<c path="String"/>
	<x path="Float"/>
</f></getActionStregth>
		<isAction public="1" set="method">
			<f a="action:?exactMatch" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ exactMatch : false }</e></m></meta>
		</isAction>
		<isActionPressed public="1" set="method">
			<f a="action:?allowEcho:?exactMatch" v=":false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ exactMatch : false, allowEcho : false }</e></m></meta>
		</isActionPressed>
		<isActionReleased public="1" set="method">
			<f a="action:?exactMatch" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ exactMatch : false }</e></m></meta>
		</isActionReleased>
		<isActionType public="1" set="method"><f a=""><x path="Bool"/></f></isActionType>
		<isCanceled public="1" set="method"><f a=""><x path="Bool"/></f></isCanceled>
		<isEcho public="1" set="method"><f a=""><x path="Bool"/></f></isEcho>
		<isMatch public="1" set="method">
			<f a="event:?exactMatch" v=":false">
				<c path="sunaba.input.InputEvent"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ exactMatch : false }</e></m></meta>
		</isMatch>
		<isPressed public="1" set="method"><f a=""><x path="Bool"/></f></isPressed>
		<isReleased public="1" set="method"><f a=""><x path="Bool"/></f></isReleased>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"InputEvent"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.input.InputEventAbstract" params="" file="G:\sunaba\sunaba/input/InputEvent.hx" module="sunaba.input.InputEvent">
		<from>
			<icast><c path="sunaba.input.InputEvent"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.input.InputEvent"/></this>
		<to><icast><c path="sunaba.input.InputEvent"/></icast></to>
		<impl><class path="sunaba.input._InputEvent.InputEventAbstract_Impl_" params="" file="G:\sunaba\sunaba/input/InputEvent.hx" private="1" module="sunaba.input.InputEvent" final="1"><fromResource public="1" set="method" line="27" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.input.InputEventAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.input._InputEvent.InputEventAbstract_Impl_" params="" file="G:\sunaba\sunaba/input/InputEvent.hx" private="1" module="sunaba.input.InputEvent" final="1"><fromResource public="1" set="method" line="27" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.input.InputEventAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.input.Shortcut" params="" file="G:\sunaba\sunaba/input/Shortcut.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<castFrom public="1" set="method" static="1">
			<f a="res">
				<d/>
				<c path="sunaba.input.Shortcut"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<events public="1"><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.input.InputEvent"/>
</c></events>
		<getAsText public="1" set="method"><f a=""><c path="String"/></f></getAsText>
		<hasValidEvent public="1" set="method"><f a=""><x path="Bool"/></f></hasValidEvent>
		<matchesEvent public="1" set="method"><f a="event">
	<c path="sunaba.input.InputEvent"/>
	<x path="Bool"/>
</f></matchesEvent>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"InputEventShortcut"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.input.ShortcutAbstract" params="" file="G:\sunaba\sunaba/input/Shortcut.hx" module="sunaba.input.Shortcut">
		<from>
			<icast><c path="sunaba.input.Shortcut"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.input.Shortcut"/></this>
		<to><icast><c path="sunaba.input.Shortcut"/></icast></to>
		<impl><class path="sunaba.input._Shortcut.ShortcutAbstract_Impl_" params="" file="G:\sunaba\sunaba/input/Shortcut.hx" private="1" module="sunaba.input.Shortcut" final="1"><fromResource public="1" set="method" line="17" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.input.ShortcutAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.input._Shortcut.ShortcutAbstract_Impl_" params="" file="G:\sunaba\sunaba/input/Shortcut.hx" private="1" module="sunaba.input.Shortcut" final="1"><fromResource public="1" set="method" line="17" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.input.ShortcutAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.spatial.CameraAttributes" params="" file="G:\sunaba\sunaba/spatial/CameraAttributes.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<castFrom public="1" set="method" static="1">
			<f a="res">
				<d/>
				<c path="sunaba.spatial.CameraAttributes"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<autoExposureEnabled public="1"><x path="Bool"/></autoExposureEnabled>
		<autoExposureScale public="1"><x path="Float"/></autoExposureScale>
		<autoExposureSpeed public="1"><x path="Float"/></autoExposureSpeed>
		<exposureMultiplier public="1"><x path="Float"/></exposureMultiplier>
		<exposureSensitivity public="1"><x path="Float"/></exposureSensitivity>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"CameraAttributes"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.spatial.CameraAttributesAbstract" params="" file="G:\sunaba\sunaba/spatial/CameraAttributes.hx" module="sunaba.spatial.CameraAttributes">
		<from>
			<icast><c path="sunaba.spatial.CameraAttributes"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.spatial.CameraAttributes"/></this>
		<to><icast><c path="sunaba.spatial.CameraAttributes"/></icast></to>
		<impl><class path="sunaba.spatial._CameraAttributes.CameraAttributesAbstract_Impl_" params="" file="G:\sunaba\sunaba/spatial/CameraAttributes.hx" private="1" module="sunaba.spatial.CameraAttributes" final="1"><fromResource public="1" set="method" line="18" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.spatial.CameraAttributesAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.spatial._CameraAttributes.CameraAttributesAbstract_Impl_" params="" file="G:\sunaba\sunaba/spatial/CameraAttributes.hx" private="1" module="sunaba.spatial.CameraAttributes" final="1"><fromResource public="1" set="method" line="18" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.spatial.CameraAttributesAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.spatial.Sky" params="" file="G:\sunaba\sunaba/spatial/Sky.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<castFrom public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.spatial.Sky"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<processMode public="1"><x path="Int"/></processMode>
		<radianceSize public="1"><x path="Int"/></radianceSize>
		<skyMaterial public="1"><c path="sunaba.core.Material"/></skyMaterial>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Sky"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.spatial.SkyAbstract" params="" file="G:\sunaba\sunaba/spatial/Sky.hx" module="sunaba.spatial.Sky">
		<from>
			<icast><c path="sunaba.spatial.Sky"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.spatial.Sky"/></this>
		<to><icast><c path="sunaba.spatial.Sky"/></icast></to>
		<impl><class path="sunaba.spatial._Sky.SkyAbstract_Impl_" params="" file="G:\sunaba\sunaba/spatial/Sky.hx" private="1" module="sunaba.spatial.Sky" final="1"><fromResource public="1" set="method" line="17" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.spatial.SkyAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.spatial._Sky.SkyAbstract_Impl_" params="" file="G:\sunaba\sunaba/spatial/Sky.hx" private="1" module="sunaba.spatial.Sky" final="1"><fromResource public="1" set="method" line="17" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.spatial.SkyAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.spatial.World3D" params="" file="G:\sunaba\sunaba/spatial/World3D.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<castFrom public="1" set="method" static="1">
			<f a="res">
				<d/>
				<c path="sunaba.spatial.World3D"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<cameraAttributes public="1"><c path="sunaba.spatial.CameraAttributes"/></cameraAttributes>
		<environment public="1"><c path="sunaba.core.Environment"/></environment>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"World3D"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.spatial.World3DAbstract" params="" file="G:\sunaba\sunaba/spatial/World3D.hx" module="sunaba.spatial.World3D">
		<from>
			<icast><c path="sunaba.spatial.World3D"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.spatial.World3D"/></this>
		<to><icast><c path="sunaba.spatial.World3D"/></icast></to>
		<impl><class path="sunaba.spatial._World3D.World3DAbstract_Impl_" params="" file="G:\sunaba\sunaba/spatial/World3D.hx" private="1" module="sunaba.spatial.World3D" final="1"><fromResource public="1" set="method" line="16" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.spatial.World3DAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.spatial._World3D.World3DAbstract_Impl_" params="" file="G:\sunaba\sunaba/spatial/World3D.hx" private="1" module="sunaba.spatial.World3D" final="1"><fromResource public="1" set="method" line="16" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.spatial.World3DAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.ui.Control" params="" file="G:\sunaba\sunaba/ui/Control.hx" extern="1">
		<extends path="sunaba.core.CanvasItem"/>
		<toControl public="1" set="method" static="1">
			<f a="obj">
				<d/>
				<c path="sunaba.ui.Control"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</toControl>
		<anchorBottom public="1"><x path="Float"/></anchorBottom>
		<anchorLeft public="1"><x path="Float"/></anchorLeft>
		<anchorRight public="1"><x path="Float"/></anchorRight>
		<anchorTop public="1"><x path="Float"/></anchorTop>
		<autoTranslate public="1"><x path="Bool"/></autoTranslate>
		<clippingContents public="1"><x path="Bool"/></clippingContents>
		<customMinimumSize public="1"><c path="sunaba.core.Vector2"/></customMinimumSize>
		<focusMode public="1"><x path="Bool"/></focusMode>
		<focusNeighborBottom public="1"><c path="String"/></focusNeighborBottom>
		<focusNeighborLeft public="1"><c path="String"/></focusNeighborLeft>
		<focusNeighborRight public="1"><c path="String"/></focusNeighborRight>
		<focusNeighborTop public="1"><c path="String"/></focusNeighborTop>
		<focusNext public="1"><c path="String"/></focusNext>
		<focusPrevious public="1"><c path="String"/></focusPrevious>
		<globalPosition public="1"><c path="sunaba.core.Vector2"/></globalPosition>
		<growHorizontal public="1"><x path="Bool"/></growHorizontal>
		<growVertical public="1"><x path="Bool"/></growVertical>
		<layoutDirection public="1"><x path="Float"/></layoutDirection>
		<localizingNumeralSystem public="1"><x path="Bool"/></localizingNumeralSystem>
		<mouseFilter public="1"><x path="Int"/></mouseFilter>
		<mouseForcePassScrollEvents public="1"><x path="Bool"/></mouseForcePassScrollEvents>
		<offsetBottom public="1"><x path="Float"/></offsetBottom>
		<offsetLeft public="1"><x path="Float"/></offsetLeft>
		<offsetRight public="1"><x path="Float"/></offsetRight>
		<offsetTop public="1"><x path="Float"/></offsetTop>
		<physicsInterpolationMode public="1"><x path="Int"/></physicsInterpolationMode>
		<pivotOffset public="1"><c path="sunaba.core.Vector2"/></pivotOffset>
		<position public="1"><c path="sunaba.core.Vector2"/></position>
		<rotation public="1"><x path="Float"/></rotation>
		<rotationDegrees public="1"><x path="Float"/></rotationDegrees>
		<scale public="1"><c path="sunaba.core.Vector2"/></scale>
		<shortcutContext public="1"><c path="sunaba.core.Element"/></shortcutContext>
		<size public="1"><c path="sunaba.core.Vector2"/></size>
		<sizeFlagsHorizontal public="1"><x path="Int"/></sizeFlagsHorizontal>
		<sizeFlagsStretchRatio public="1"><x path="Float"/></sizeFlagsStretchRatio>
		<sizeFlagsVertical public="1"><x path="Int"/></sizeFlagsVertical>
		<theme public="1"><c path="sunaba.ui.Theme"/></theme>
		<themeTypeVariation public="1"><c path="String"/></themeTypeVariation>
		<toolTipAutoTranslateMode public="1"><x path="Int"/></toolTipAutoTranslateMode>
		<toolTipText public="1"><c path="String"/></toolTipText>
		<focusEntered public="1"><c path="sunaba.core.Event"/></focusEntered>
		<focusExited public="1"><c path="sunaba.core.Event"/></focusExited>
		<guiInput public="1"><c path="sunaba.core.Event"/></guiInput>
		<minimumSizeChanged public="1"><c path="sunaba.core.Event"/></minimumSizeChanged>
		<mouseEntered public="1"><c path="sunaba.core.Event"/></mouseEntered>
		<mouseExited public="1"><c path="sunaba.core.Event"/></mouseExited>
		<resized public="1"><c path="sunaba.core.Event"/></resized>
		<sizeFlagsChanged public="1"><c path="sunaba.core.Event"/></sizeFlagsChanged>
		<themeChanged public="1"><c path="sunaba.core.Event"/></themeChanged>
		<acceptEvent public="1" set="method"><f a=""><x path="Void"/></f></acceptEvent>
		<addThemeColorOverride public="1" set="method"><f a="name:color">
	<c path="String"/>
	<c path="sunaba.core.Color"/>
	<x path="Void"/>
</f></addThemeColorOverride>
		<addThemeConstantOverride public="1" set="method"><f a="name:constant">
	<c path="String"/>
	<x path="sunaba.core.Variant"/>
	<x path="Void"/>
</f></addThemeConstantOverride>
		<addThemeFontOverride public="1" set="method"><f a="name:font">
	<c path="String"/>
	<c path="sunaba.core.Font"/>
	<x path="Void"/>
</f></addThemeFontOverride>
		<addThemeFontSizeOverride public="1" set="method"><f a="name:size">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addThemeFontSizeOverride>
		<addThemeIconOverride public="1" set="method"><f a="name:icon">
	<c path="String"/>
	<c path="sunaba.core.Texture2D"/>
	<x path="Void"/>
</f></addThemeIconOverride>
		<addThemeStyleboxOverride public="1" set="method"><f a="name:stylebox">
	<c path="String"/>
	<c path="sunaba.ui.StyleBox"/>
	<x path="Void"/>
</f></addThemeStyleboxOverride>
		<beginBulkThemeOverride public="1" set="method"><f a=""><x path="Void"/></f></beginBulkThemeOverride>
		<endBulkThemeOverride public="1" set="method"><f a=""><x path="Void"/></f></endBulkThemeOverride>
		<findNextValidFocus public="1" set="method"><f a=""><c path="sunaba.ui.Control"/></f></findNextValidFocus>
		<findPrevValidFocus public="1" set="method"><f a=""><c path="sunaba.ui.Control"/></f></findPrevValidFocus>
		<findValidFocusNeighbor public="1" set="method"><f a="side">
	<x path="Int"/>
	<c path="sunaba.ui.Control"/>
</f></findValidFocusNeighbor>
		<forceDrag public="1" set="method"><f a="data:preview">
	<x path="sunaba.core.Variant"/>
	<c path="sunaba.ui.Control"/>
	<x path="Void"/>
</f></forceDrag>
		<getAnchor public="1" set="method"><f a="side">
	<x path="Int"/>
	<x path="Float"/>
</f></getAnchor>
		<getCombinedMinimumSize public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></getCombinedMinimumSize>
		<getCursorShape public="1" set="method"><f a="position">
	<c path="sunaba.core.Vector2"/>
	<x path="Int"/>
</f></getCursorShape>
		<getEnd public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></getEnd>
		<getFocusNeighbor public="1" set="method"><f a="side">
	<x path="Int"/>
	<c path="String"/>
</f></getFocusNeighbor>
		<getGlobalRect public="1" set="method"><f a=""><c path="sunaba.core.Rect2"/></f></getGlobalRect>
		<getScreenPosition public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></getScreenPosition>
		<getThemeColor public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="sunaba.core.Color"/>
</f></getThemeColor>
		<getThemeConstant public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="sunaba.core.Variant"/>
</f></getThemeConstant>
		<getThemeDefaultBaseScale public="1" set="method"><f a=""><x path="Float"/></f></getThemeDefaultBaseScale>
		<getThemeDefaultFont public="1" set="method"><f a=""><c path="sunaba.core.Font"/></f></getThemeDefaultFont>
		<getThemeDefaultFontSize public="1" set="method"><f a=""><x path="Float"/></f></getThemeDefaultFontSize>
		<getThemeFont public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="sunaba.core.Font"/>
</f></getThemeFont>
		<getThemeFontSize public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Float"/>
</f></getThemeFontSize>
		<getThemeIcon public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="sunaba.core.Texture2D"/>
</f></getThemeIcon>
		<getThemeStylebox public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="sunaba.ui.StyleBox"/>
</f></getThemeStylebox>
		<getTooltip public="1" set="method"><f a=""><c path="String"/></f></getTooltip>
		<grabClickFocus public="1" set="method"><f a=""><x path="Void"/></f></grabClickFocus>
		<grabFocus public="1" set="method"><f a=""><x path="Void"/></f></grabFocus>
		<hasFocus public="1" set="method"><f a=""><x path="Bool"/></f></hasFocus>
		<hasThemeColor public="1" set="method"><f a="name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasThemeColor>
		<hasThemeColorOverride public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasThemeColorOverride>
		<hasThemeConstant public="1" set="method"><f a="name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasThemeConstant>
		<hasThemeConstantOverride public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasThemeConstantOverride>
		<hasThemeFont public="1" set="method"><f a="name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasThemeFont>
		<hasThemeFontOverride public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasThemeFontOverride>
		<hasThemeFontSize public="1" set="method"><f a="name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasThemeFontSize>
		<hasThemeFontSizeOverride public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasThemeFontSizeOverride>
		<hasThemeIcon public="1" set="method"><f a="name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasThemeIcon>
		<hasThemeIconOverride public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasThemeIconOverride>
		<hasThemeStylebox public="1" set="method"><f a="name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasThemeStylebox>
		<hasThemeStyleboxOverride public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasThemeStyleboxOverride>
		<isDragSuccessful public="1" set="method"><f a=""><x path="Bool"/></f></isDragSuccessful>
		<isLayoutRtl public="1" set="method"><f a=""><x path="Bool"/></f></isLayoutRtl>
		<releaseFocus public="1" set="method"><f a=""><x path="Void"/></f></releaseFocus>
		<removeThemeColorOverride public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeThemeColorOverride>
		<removeThemeConstantOverride public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeThemeConstantOverride>
		<removeThemeFontOverride public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeThemeFontOverride>
		<removeThemeFontSizeOverride public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeThemeFontSizeOverride>
		<removeThemeIconOverride public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeThemeIconOverride>
		<removeThemeStyleboxOverride public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeThemeStyleboxOverride>
		<resetSize public="1" set="method"><f a=""><x path="Void"/></f></resetSize>
		<setAnchor public="1" set="method"><f a="side:anchor:?keepOffset:?pushOppositeAnchor">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setAnchor>
		<setAnchorAndOffset public="1" set="method"><f a="side:anchor:offset:?pushOppositeAnchor">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setAnchorAndOffset>
		<setAnchorsAndOffsetsPreset public="1" set="method"><f a="preset:?resizeMode:?margin">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setAnchorsAndOffsetsPreset>
		<setAnchorsPreset public="1" set="method"><f a="preset:?keepOffsets">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setAnchorsPreset>
		<setBegin public="1" set="method"><f a="position">
	<c path="sunaba.core.Vector2"/>
	<x path="Void"/>
</f></setBegin>
		<setDragPreview public="1" set="method"><f a="preview">
	<c path="sunaba.ui.Control"/>
	<x path="Void"/>
</f></setDragPreview>
		<setEnd public="1" set="method"><f a="position">
	<c path="sunaba.core.Vector2"/>
	<x path="Void"/>
</f></setEnd>
		<setFocusNeighbor public="1" set="method"><f a="side:neighbor">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></setFocusNeighbor>
		<setGlobalPosition public="1" set="method"><f a="position">
	<c path="sunaba.core.Vector2"/>
	<x path="Void"/>
</f></setGlobalPosition>
		<setOffset public="1" set="method"><f a="side:offset">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setOffset>
		<setOffsetsPreset public="1" set="method"><f a="preset:?resizeMode:?margin">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setOffsetsPreset>
		<setPosition public="1" set="method"><f a="position:?keepOffset">
	<c path="sunaba.core.Vector2"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setPosition>
		<setSize public="1" set="method"><f a="size:?keepOffsets">
	<c path="sunaba.core.Vector2"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setSize>
		<updateMinimumSize public="1" set="method"><f a=""><x path="Void"/></f></updateMinimumSize>
		<warpMouse public="1" set="method"><f a="position">
	<c path="sunaba.core.Vector2"/>
	<x path="Void"/>
</f></warpMouse>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Control"</e></m>
		</meta>
	</class>
	<class path="sunaba.ui.BaseButton" params="" file="G:\sunaba\sunaba/ui/BaseButton.hx" extern="1">
		<extends path="sunaba.ui.Control"/>
		<toBaseButton public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.ui.BaseButton"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</toBaseButton>
		<actionMode public="1"><x path="Int"/></actionMode>
		<buttonGroup public="1"><c path="sunaba.ui.ButtonGroup"/></buttonGroup>
		<buttonMask public="1"><x path="Int"/></buttonMask>
		<buttonPressed public="1"><x path="Bool"/></buttonPressed>
		<disabled public="1"><x path="Bool"/></disabled>
		<keepPressedOutside public="1"><x path="Bool"/></keepPressedOutside>
		<shortcut public="1"><c path="sunaba.input.Shortcut"/></shortcut>
		<shortcutFeedback public="1"><x path="Bool"/></shortcutFeedback>
		<toggleMode public="1"><x path="Bool"/></toggleMode>
		<buttonDown public="1"><c path="sunaba.core.Event"/></buttonDown>
		<buttonUp public="1"><c path="sunaba.core.Event"/></buttonUp>
		<pressed public="1"><c path="sunaba.core.Event"/></pressed>
		<toggled public="1"><c path="sunaba.core.Event"/></toggled>
		<getDrawMode public="1" set="method"><f a=""><x path="Int"/></f></getDrawMode>
		<isHovered public="1" set="method"><f a=""><x path="Bool"/></f></isHovered>
		<setPressedNoEvent public="1" set="method"><f a="pressed">
	<x path="Bool"/>
	<x path="Void"/>
</f></setPressedNoEvent>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"BaseButton"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.ui.BaseButtonAbstract" params="" file="G:\sunaba\sunaba/ui/BaseButton.hx" module="sunaba.ui.BaseButton">
		<from>
			<icast><c path="sunaba.ui.BaseButton"/></icast>
			<icast field="fromElement"><c path="sunaba.core.Element"/></icast>
		</from>
		<this><c path="sunaba.ui.BaseButton"/></this>
		<to><icast><c path="sunaba.ui.BaseButton"/></icast></to>
		<impl><class path="sunaba.ui._BaseButton.BaseButtonAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/BaseButton.hx" private="1" module="sunaba.ui.BaseButton" final="1"><fromElement public="1" set="method" line="32" static="1">
	<f a="element">
		<c path="sunaba.core.Element"/>
		<x path="sunaba.ui.BaseButtonAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromElement></class></impl>
	</abstract>
	<class path="sunaba.ui._BaseButton.BaseButtonAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/BaseButton.hx" private="1" module="sunaba.ui.BaseButton" final="1"><fromElement public="1" set="method" line="32" static="1">
	<f a="element">
		<c path="sunaba.core.Element"/>
		<x path="sunaba.ui.BaseButtonAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromElement></class>
	<class path="sunaba.ui.Button" params="" file="G:\sunaba\sunaba/ui/Button.hx" extern="1">
		<extends path="sunaba.ui.BaseButton"/>
		<toButton public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.ui.Button"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</toButton>
		<alignment public="1"><x path="Int"/></alignment>
		<autowrapMode public="1"><x path="Int"/></autowrapMode>
		<clipText public="1"><x path="Bool"/></clipText>
		<expandIcon public="1"><x path="Bool"/></expandIcon>
		<flat public="1"><x path="Bool"/></flat>
		<icon public="1"><c path="sunaba.core.Texture2D"/></icon>
		<iconAlignment public="1"><x path="Int"/></iconAlignment>
		<language public="1"><c path="String"/></language>
		<text public="1"><c path="String"/></text>
		<textDirection public="1"><x path="Int"/></textDirection>
		<textOverrunBehavior public="1"><x path="Int"/></textOverrunBehavior>
		<verticalIconAlignment public="1"><x path="Int"/></verticalIconAlignment>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Button"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.ui.ButtonAbstract" params="" file="G:\sunaba\sunaba/ui/Button.hx" module="sunaba.ui.Button">
		<from>
			<icast><c path="sunaba.ui.Button"/></icast>
			<icast field="fromElement"><c path="sunaba.core.Element"/></icast>
		</from>
		<this><c path="sunaba.ui.Button"/></this>
		<to><icast><c path="sunaba.ui.Button"/></icast></to>
		<impl><class path="sunaba.ui._Button.ButtonAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/Button.hx" private="1" module="sunaba.ui.Button" final="1">
	<fromElement public="1" set="method" line="26" static="1">
		<f a="element">
			<c path="sunaba.core.Element"/>
			<x path="sunaba.ui.ButtonAbstract"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromElement>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="sunaba.ui._Button.ButtonAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/Button.hx" private="1" module="sunaba.ui.Button" final="1">
		<fromElement public="1" set="method" line="26" static="1">
			<f a="element">
				<c path="sunaba.core.Element"/>
				<x path="sunaba.ui.ButtonAbstract"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromElement>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sunaba.ui.ButtonGroup" params="" file="G:\sunaba\sunaba/ui/ButtonGroup.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<castFrom public="1" set="method" static="1">
			<f a="type">
				<d/>
				<c path="sunaba.ui.ButtonGroup"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<allowUnpress public="1"><x path="Bool"/></allowUnpress>
		<pressed public="1"><c path="sunaba.core.Event"/></pressed>
		<getButtons public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="sunaba.ui.BaseButton"/>
</c></f></getButtons>
		<getPressedButton public="1" set="method"><f a=""><c path="sunaba.ui.BaseButton"/></f></getPressedButton>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"ButtonGroup"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.ui.ButtonGroupAbstract" params="" file="G:\sunaba\sunaba/ui/ButtonGroup.hx" module="sunaba.ui.ButtonGroup">
		<from>
			<icast><c path="sunaba.ui.ButtonGroup"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.ui.ButtonGroup"/></this>
		<to><icast><c path="sunaba.ui.ButtonGroup"/></icast></to>
		<impl><class path="sunaba.ui._ButtonGroup.ButtonGroupAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/ButtonGroup.hx" private="1" module="sunaba.ui.ButtonGroup" final="1"><fromResource public="1" set="method" line="18" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.ui.ButtonGroupAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.ui._ButtonGroup.ButtonGroupAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/ButtonGroup.hx" private="1" module="sunaba.ui.ButtonGroup" final="1"><fromResource public="1" set="method" line="18" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.ui.ButtonGroupAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<abstract path="sunaba.ui.ControlAbstract" params="" file="G:\sunaba\sunaba/ui/Control.hx" module="sunaba.ui.Control">
		<from>
			<icast><c path="sunaba.ui.Control"/></icast>
			<icast field="fromElement"><c path="sunaba.core.Element"/></icast>
		</from>
		<this><c path="sunaba.ui.Control"/></this>
		<to><icast><c path="sunaba.ui.Control"/></icast></to>
		<impl><class path="sunaba.ui._Control.ControlAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/Control.hx" private="1" module="sunaba.ui.Control" final="1"><fromElement public="1" set="method" line="140" static="1">
	<f a="element">
		<c path="sunaba.core.Element"/>
		<x path="sunaba.ui.ControlAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromElement></class></impl>
	</abstract>
	<class path="sunaba.ui._Control.ControlAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/Control.hx" private="1" module="sunaba.ui.Control" final="1"><fromElement public="1" set="method" line="140" static="1">
	<f a="element">
		<c path="sunaba.core.Element"/>
		<x path="sunaba.ui.ControlAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromElement></class>
	<class path="sunaba.ui.Label" params="" file="G:\sunaba\sunaba/ui/Label.hx" extern="1">
		<extends path="sunaba.ui.Control"/>
		<toLabel public="1" set="method" static="1">
			<f a="obj">
				<d/>
				<c path="sunaba.ui.Label"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</toLabel>
		<autowrapMode public="1"><x path="Int"/></autowrapMode>
		<clipText public="1"><x path="Bool"/></clipText>
		<ellipsisChar public="1"><c path="String"/></ellipsisChar>
		<horizontalAlignment public="1"><x path="Int"/></horizontalAlignment>
		<justificationFlags public="1"><x path="Int"/></justificationFlags>
		<labelSettings public="1"><c path="sunaba.core.LabelSettings"/></labelSettings>
		<language public="1"><c path="String"/></language>
		<linesSkipped public="1"><x path="Int"/></linesSkipped>
		<maxLinesSkipped public="1"><x path="Int"/></maxLinesSkipped>
		<paragraphSeparator public="1"><c path="String"/></paragraphSeparator>
		<structuredTextBidiOverride public="1"><x path="Int"/></structuredTextBidiOverride>
		<structuredTextBidiOverrideOptions public="1"><c path="sunaba.core.ArrayList"/></structuredTextBidiOverrideOptions>
		<tabStops public="1"><c path="lua.Table">
	<x path="Int"/>
	<x path="Float"/>
</c></tabStops>
		<text public="1"><c path="String"/></text>
		<textDirection public="1"><x path="Int"/></textDirection>
		<textOverrunBehavior public="1"><x path="Int"/></textOverrunBehavior>
		<uppercase public="1"><x path="Bool"/></uppercase>
		<verticalAlignment public="1"><x path="Int"/></verticalAlignment>
		<visibleCharacters public="1"><x path="Int"/></visibleCharacters>
		<visibleCharactersBehavior public="1"><x path="Int"/></visibleCharactersBehavior>
		<visibleRatio public="1"><x path="Float"/></visibleRatio>
		<getCharacterBounds public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="sunaba.core.Rect2"/>
</f></getCharacterBounds>
		<getTotalCharacterCount public="1" set="method"><f a=""><x path="Int"/></f></getTotalCharacterCount>
		<getVisibleLineCount public="1" set="method"><f a=""><x path="Int"/></f></getVisibleLineCount>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Label"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.ui.LabelAbstract" params="" file="G:\sunaba\sunaba/ui/Label.hx" module="sunaba.ui.Label">
		<from>
			<icast><c path="sunaba.ui.Label"/></icast>
			<icast field="fromElement"><c path="sunaba.core.Element"/></icast>
		</from>
		<this><c path="sunaba.ui.Label"/></this>
		<to><icast><c path="sunaba.ui.Label"/></icast></to>
		<impl><class path="sunaba.ui._Label.LabelAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/Label.hx" private="1" module="sunaba.ui.Label" final="1"><fromElement public="1" set="method" line="39" static="1">
	<f a="element">
		<c path="sunaba.core.Element"/>
		<x path="sunaba.ui.LabelAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromElement></class></impl>
	</abstract>
	<class path="sunaba.ui._Label.LabelAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/Label.hx" private="1" module="sunaba.ui.Label" final="1"><fromElement public="1" set="method" line="39" static="1">
	<f a="element">
		<c path="sunaba.core.Element"/>
		<x path="sunaba.ui.LabelAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromElement></class>
	<class path="sunaba.ui.StyleBox" params="" file="G:\sunaba\sunaba/ui/StyleBox.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<castFrom public="1" set="method" static="1">
			<f a="res">
				<d/>
				<c path="sunaba.ui.StyleBox"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<contentMarginTop public="1"><x path="Float"/></contentMarginTop>
		<contentMarginBottom public="1"><x path="Float"/></contentMarginBottom>
		<contentMarginLeft public="1"><x path="Float"/></contentMarginLeft>
		<contentMarginRight public="1"><x path="Float"/></contentMarginRight>
		<getContentMargin public="1" set="method"><f a="margin">
	<x path="Int"/>
	<x path="Float"/>
</f></getContentMargin>
		<getMargin public="1" set="method"><f a="margin">
	<x path="Int"/>
	<x path="Float"/>
</f></getMargin>
		<getMinimumSize public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></getMinimumSize>
		<getOffset public="1" set="method"><f a=""><c path="sunaba.core.Vector2"/></f></getOffset>
		<setContentMargin public="1" set="method"><f a="margin:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setContentMargin>
		<setMargin public="1" set="method"><f a="margin:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMargin>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"StyleBox"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.ui.StyleBoxAbstract" params="" file="G:\sunaba\sunaba/ui/StyleBox.hx" module="sunaba.ui.StyleBox">
		<from>
			<icast><c path="sunaba.ui.StyleBox"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.ui.StyleBox"/></this>
		<to><icast><c path="sunaba.ui.StyleBox"/></icast></to>
		<impl><class path="sunaba.ui._StyleBox.StyleBoxAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/StyleBox.hx" private="1" module="sunaba.ui.StyleBox" final="1"><fromResource public="1" set="method" line="24" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.ui.StyleBoxAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.ui._StyleBox.StyleBoxAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/StyleBox.hx" private="1" module="sunaba.ui.StyleBox" final="1"><fromResource public="1" set="method" line="24" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.ui.StyleBoxAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<class path="sunaba.ui.Theme" params="" file="G:\sunaba\sunaba/ui/Theme.hx" extern="1">
		<extends path="sunaba.core.Resource"/>
		<castFrom public="1" set="method" static="1">
			<f a="res">
				<d/>
				<c path="sunaba.ui.Theme"/>
			</f>
			<meta><m n=":native"><e>"cast"</e></m></meta>
		</castFrom>
		<defaultBaseScale public="1"><x path="Float"/></defaultBaseScale>
		<defaultFont public="1"><c path="sunaba.core.Font"/></defaultFont>
		<defaultFontSize public="1"><x path="Float"/></defaultFontSize>
		<addType public="1" set="method"><f a="themeType">
	<c path="String"/>
	<x path="Void"/>
</f></addType>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<clearColor public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></clearColor>
		<clearConstant public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></clearConstant>
		<clearFont public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></clearFont>
		<clearFontSize public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></clearFontSize>
		<clearIcon public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></clearIcon>
		<clearStyleBox public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></clearStyleBox>
		<clearThemeItem public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></clearThemeItem>
		<clearTypeVariation public="1" set="method"><f a="themeType">
	<c path="String"/>
	<x path="Void"/>
</f></clearTypeVariation>
		<getColor public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<c path="sunaba.core.Color"/>
</f></getColor>
		<getColorList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getColorList>
		<getColorTypeList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getColorTypeList>
		<getConstant public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
</f></getConstant>
		<getConstantList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getConstantList>
		<getConstantTypeList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getConstantTypeList>
		<getFont public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<c path="sunaba.core.Font"/>
</f></getFont>
		<getFontList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getFontList>
		<getFontTypeList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getFontTypeList>
		<getFontSize public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
</f></getFontSize>
		<getFontSizeList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getFontSizeList>
		<getFontSizeTypeList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getFontSizeTypeList>
		<getIcon public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<c path="sunaba.core.Texture2D"/>
</f></getIcon>
		<getIconList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getIconList>
		<getIconTypeList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getIconTypeList>
		<getStyleBox public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<c path="sunaba.ui.StyleBox"/>
</f></getStyleBox>
		<getStyleBoxList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getStyleBoxList>
		<getStyleBoxTypeList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getStyleBoxTypeList>
		<getThemeItem public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<c path="sunaba.core.Resource"/>
</f></getThemeItem>
		<getThemeItemList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getThemeItemList>
		<getThemeItemTypeList public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getThemeItemTypeList>
		<getTypeList public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></f></getTypeList>
		<getTypeVariationBase public="1" set="method"><f a="themeType">
	<c path="String"/>
	<c path="String"/>
</f></getTypeVariationBase>
		<getTypeVariationList public="1" set="method"><f a="themeType">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></getTypeVariationList>
		<hasColor public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasColor>
		<hasConstant public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasConstant>
		<hasDefaultBaseScale public="1" set="method"><f a=""><x path="Bool"/></f></hasDefaultBaseScale>
		<hasDefaultFont public="1" set="method"><f a=""><x path="Bool"/></f></hasDefaultFont>
		<hasDefaultFontSize public="1" set="method"><f a=""><x path="Bool"/></f></hasDefaultFontSize>
		<hasFont public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasFont>
		<hasFontSize public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasFontSize>
		<hasIcon public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasIcon>
		<hasStyleBox public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasStyleBox>
		<hasThemeItem public="1" set="method"><f a="name:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasThemeItem>
		<isTypeVariation public="1" set="method"><f a="themeType:baseType">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></isTypeVariation>
		<mergeWith public="1" set="method"><f a="theme">
	<c path="sunaba.ui.Theme"/>
	<x path="Void"/>
</f></mergeWith>
		<removeType public="1" set="method"><f a="themeType">
	<c path="String"/>
	<x path="Void"/>
</f></removeType>
		<renameColor public="1" set="method"><f a="name:type:newName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></renameColor>
		<renameConstant public="1" set="method"><f a="name:type:newName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></renameConstant>
		<renameFont public="1" set="method"><f a="name:type:newName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></renameFont>
		<renameFontSize public="1" set="method"><f a="name:type:newName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></renameFontSize>
		<renameIcon public="1" set="method"><f a="name:type:newName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></renameIcon>
		<renameStyleBox public="1" set="method"><f a="name:type:newName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></renameStyleBox>
		<renameThemeItem public="1" set="method"><f a="name:type:newName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></renameThemeItem>
		<setColor public="1" set="method"><f a="name:type:color">
	<c path="String"/>
	<c path="String"/>
	<c path="sunaba.core.Color"/>
	<x path="Void"/>
</f></setColor>
		<setConstant public="1" set="method"><f a="name:type:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setConstant>
		<setDefaultBaseScale public="1" set="method"><f a="scale">
	<x path="Float"/>
	<x path="Void"/>
</f></setDefaultBaseScale>
		<setDefaultFont public="1" set="method"><f a="font">
	<c path="sunaba.core.Font"/>
	<x path="Void"/>
</f></setDefaultFont>
		<setDefaultFontSize public="1" set="method"><f a="size">
	<x path="Float"/>
	<x path="Void"/>
</f></setDefaultFontSize>
		<setFont public="1" set="method"><f a="name:type:font">
	<c path="String"/>
	<c path="String"/>
	<c path="sunaba.core.Font"/>
	<x path="Void"/>
</f></setFont>
		<setFontSize public="1" set="method"><f a="name:type:size">
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFontSize>
		<setIcon public="1" set="method"><f a="name:type:icon">
	<c path="String"/>
	<c path="String"/>
	<c path="sunaba.core.Texture2D"/>
	<x path="Void"/>
</f></setIcon>
		<setStyleBox public="1" set="method"><f a="name:type:styleBox">
	<c path="String"/>
	<c path="String"/>
	<c path="sunaba.ui.StyleBox"/>
	<x path="Void"/>
</f></setStyleBox>
		<setThemeItem public="1" set="method"><f a="name:type:item">
	<c path="String"/>
	<c path="String"/>
	<x path="sunaba.core.Variant"/>
	<x path="Void"/>
</f></setThemeItem>
		<setTypeVariation public="1" set="method"><f a="themeType:baseType">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setTypeVariation>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Theme"</e></m>
		</meta>
	</class>
	<abstract path="sunaba.ui.ThemeAbstract" params="" file="G:\sunaba\sunaba/ui/Theme.hx" module="sunaba.ui.Theme">
		<from>
			<icast><c path="sunaba.ui.Theme"/></icast>
			<icast field="fromResource"><c path="sunaba.core.Resource"/></icast>
		</from>
		<this><c path="sunaba.ui.Theme"/></this>
		<to><icast><c path="sunaba.ui.Theme"/></icast></to>
		<impl><class path="sunaba.ui._Theme.ThemeAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/Theme.hx" private="1" module="sunaba.ui.Theme" final="1"><fromResource public="1" set="method" line="85" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.ui.ThemeAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class></impl>
	</abstract>
	<class path="sunaba.ui._Theme.ThemeAbstract_Impl_" params="" file="G:\sunaba\sunaba/ui/Theme.hx" private="1" module="sunaba.ui.Theme" final="1"><fromResource public="1" set="method" line="85" static="1">
	<f a="resource">
		<c path="sunaba.core.Resource"/>
		<x path="sunaba.ui.ThemeAbstract"/>
	</f>
	<meta><m n=":from"/></meta>
</fromResource></class>
	<typedef path="sys.FileStat" params="" file="C:\HaxeToolkit\haxe\std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all file systems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File information, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
</haxe>